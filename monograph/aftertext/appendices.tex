

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter[Manual do Formatador]{Manual do Formatador de Código}
\label{manualDoFormatadorDeCodigo}


Esse apêndice apresenta um manual da ferramenta.
Não recomenda~=se que usuários que não possuam conhecimentos sobre a semântica das linguagens de programação\advisor{}{,
} utilizem esta ferramenta para realizar a formatação de código~=fonte.
Neste caso,
o mais indicado é que seja utilizado as demais ferramentas de formatação,
que são mais especificas para cada linguagem individualmente e
possuem inerentemente os conhecimentos específicos da sintaxe e
semântica da linguagem a ser formatada.

Não foi criada nenhuma interface gráfica ou
de linha de comando que faça a entrada do programa a ser formatado e
das configurações do formatador de código~=fonte.
Existem duas implementações que utilizam a metalinguagem (\typeref{grammarsGrammarPushdown}).
Uma utiliza a metalinguagem para adicionar cores (\typeref{codeHighlighterPy}),
como feito em editores de texto e
a outra realiza a formatação de código~=fonte (\typeref{codeFormatterPy}).

Nos \typeref{MainFormatterPy,MainHighlighterPy,utilitiesPy},
encontra~=se um exemplo simples de programa que pode ser construído para executar o Formatador de Código e
a Adição de Cores.
Sua construção é a mesma utilizada para a criação dos testes de unidade (\typeref{unitTestsPy}).
Tanto o \typeref{MainFormatterPy} quanto do o \typeref{MainHighlighterPy} geram como resultado um arquivo HTML,
contendo como conteúdo o resultado de seu trabalho,
i.e., respectivamente,
o código~=fonte formatado ou
com a adição de cores.

Nos \typeref{MainFormatterPyResult,MainHighlighterPyResult},
serão encontrados como nós folha das árvores,
os \textit{tokens} criados pelo analisador léxico.
Eles seguem o mesmo padrão de notação do que os \textit{tokens} utilizados pelo Analisador ANTLR \cite{antlrBookTerrentParr}.
A implementação da exibição dos \textit{tokens} no formato do analisador ANTLR 4 foi uma das implementações feitas no \textit{fork} ``pushdown'' do Analisador Lark (Veja a \fullref{GrammarsGrammar}).

Um \textit{token} como ``\mintinline{shell}{[@7,151:166='comment.line.sma'<TEXT_CHUNK_END_>,7:25]}'' segue o modelo de representação do ANTLR 4 \cite{antlrBookTerrentParr} e
contém as seguintes informações:
\begin{inparaenum}[1)]
\item ``\mintinline{shell}{@7}'' significa que ele é o sétimo \textit{token};
\item ``\mintinline{text}{151:166}'' é a posição caracteres do \textit{token} no programa de entrada;
\item ``\mintinline{shell}{='comment.line.sma'}'' é o lexema (Veja a \fullref{compiladoresEtradutores}) ou
conteúdo do \textit{token} propriamente dito;
\item ``\mintinline{shell}{<TEXT_CHUNK_END_>}'' é o nome do \textit{token} atribuído pela gramática de entrada,
por fim;
\item ``\mintinline{text}{7:25}'' é a linha e
coluna do \textit{token} no programa de entrada.
\end{inparaenum}%

Tanto para a escrita do \typeref{codeHighlighterPy},
quanto para a escrita do \typeref{codeFormatterPy},
por consequência,
foi utilizado em um primeiro momento a biblioteca ``dominate'' para realizar a construção da página HTML com a adição de cores ou
código~=formatado. Entretanto,
devido a \textit{bugs} na biblioteca ``dominate'',
a página HTML era gerada de forma errada.
Por fim,
optou~=se em escrever o código necessário para gerar a páginas HTML,
fazendo o uso da biblioteca ``dominate'' somente para realizar a conversão de caracteres especiais para seus correspondes em HTML.
Por exemplo,
o caractere ``<'' em HTML é escrito como ``\&lt;''.

Não foi escolhido procurar uma outra biblioteca para fazer a criação de páginas HTML por que é não é fácil encontrar bibliotecas que façam somente a geração de páginas HTML.
Em geral,
as bibliotecas que geram páginas HTML são também servidores HTML ou
Web,
que vão além das necessidades deste projeto.
Portando,
optou~=se por fazer todo o código necessário para geração de páginas HTML.
Dispensando a possibilidade de escolher~=se novamente uma outra ferramenta com mais \textit{bugs}.

Para se realizar a execução de qualquer arquivo deste projeto,
é necessário ter um interpretador ``Python 3.6'' instalado,
junto com as bibliotecas ``pip3'',
``debug\_tools'', ``dominate'' e
``pushdown''.
Em uma instalação tradicional ``Ubuntu'',
estes pacotes podem ser instalados com os seguintes comandos:
\begin{enumerate}[1)]
\item \mintinline{shell}{sudo apt-get install python3 python3-pip}
\item \mintinline{shell}{pip3 install -r requirements.txt} (\typeref{requirementsTxt})
\item \mintinline{shell}{python3 main_formatter.py} (\typeref{MainFormatterPy})
\item \mintinline{shell}{python3 main_highlighter.py} (\typeref{MainHighlighterPy})
\end{enumerate}

\begin{code}
\caption{Arquivo ``source/requirements.txt''}
\label{requirementsTxt}
\inputminted{python3}{../source/requirements.txt}
\end{code}

\begin{code}
\caption{Arquivo ``source/main\_formatter.py''}
\label{MainFormatterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/main_formatter.py}
\end{code}

\begin{code}
\caption{Arquivo ``source/main\_highlighter.py''}
\label{MainHighlighterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/main_highlighter.py}
\end{code}

\begin{code}
\caption{Arquivo ``source/utilities.py''}
\label{utilitiesPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/utilities.py}
\end{code}


\chapter[main\_formatter.py]{Execução de ``main\_formatter.py''}

O programa do \typeref{MainFormatterPy} faz a criação de 5 artefatos de resultado.
Duas árvores em forma de figura,
duas arvores em forma de texto e
uma arquivo HTML.
No \typeref{MainFormatterHtml},
encontra~=se o arquivo HTML gerado pelo programa de exemplo (\typeref{MainFormatterPy}).

Nas \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree},
encontram~=se as imagens geradas pelo programa ``main\_formatter.py'' (\typeref{MainFormatterPy}).
No \typeref{MainFormatterPyResult},
encontra~=se a saída da linha de comando que se obtém ao realizar a execução do programa de exemplo (\typeref{MainFormatterPy}).
Ambas as figuras \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree} quanto o \typeref{MainFormatterPyResult} representam os mesmos dados,
mas mostrados de formas diferentes (figura \textit{versus} textual) e
com níveis de detalhes diferentes.
No \typeref{MainFormatterPyResult},
são mostrado os nós folhas das árvores com maior nível de detalhes.
Já nas \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree} os nós folhas são mostrados com simplificações para que a figura possa vista em uma única tela.
\begin{code}
\caption{Arquivo HTML gerado pelo programa de exemplo ``main\_formatter.py''}
\label{MainFormatterHtml}
\begin{minted}{html}
<!DOCTYPE html><html><head><title>Abstract Machine Language - source.sma</title></head>
<body style="white-space: pre; font-family: monospace;"><span setting="unformatted" grammar_scope="if.statement.definition" setting_scope="" original_program="if(">if(</span><span setting="2" grammar_scope="if.statement.body" setting_scope="if.statement.body" original_program="something">  something  </span><span setting="unformatted" grammar_scope="if.statement.definition" setting_scope="" original_program=")">)</span><span grammar_scope="none" setting_scope="none"> bar</span></body></html>
\end{minted}
\end{code}

\begin{figure}[h]
\caption{Árvore de Sintaxe ``main\_formatter\_syntax\_tree.png''}
\label{MainFormatterSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_formatter_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{figure}[h]
\caption{Árvore de Sintaxe Abstrata ``main\_formatter\_abstract\_syntax\_tree.png''}
\label{MainFormatterAbstractSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_formatter_abstract_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{code}
\caption{Resultado da execução do arquivo ``source/main\_formatter.py''}
\label{MainFormatterPyResult}
\begin{minted}{text}
$ python main_formatter.py
Syntax Tree
language_syntax
  preamble_statements
    master_scope_name_statement
      free_input_string
        text_chunk_end  [@1,7:16='source.sma'<TEXT_CHUNK_END_>,1:8]
    target_language_name_statement
      free_input_string
        text_chunk_end  [@2,24:48='Abstract Machine Language'<TEXT_CHUNK_END_>,2:7]
  language_construct_rules
    indentation_block
      enter_block       [@3,60:60='{'<OPEN_BRACE>,3:11]
      statements_list
        match_statement
          braced_free_input_string
            braced_text_chunk_end       [@4,73:76='if\\('<BRACED_TEXT_CHUNK_END_>,4:12]
          statements_list
            scope_name_statement
              free_input_string
                text_chunk_end  [@5,95:117='if.statement.definition'<TEXT_CHUNK_END_>,5:16]
          statements_list
            push_statement
              indentation_block
                enter_block     [@6,133:133='{'<OPEN_BRACE>,6:15]
                statements_list
                  meta_scope_statement
                    free_input_string
                      text_chunk_end    [@7,159:175='if.statement.body'<TEXT_CHUNK_END_>,7:25]
                statements_list
                  match_statement
                    braced_free_input_string
                      braced_text_chunk_end     [@8,196:197='\\)'<BRACED_TEXT_CHUNK_END_>,8:20]
                    statements_list
                      scope_name_statement
                        free_input_string
                          text_chunk_end        [@9,224:246='if.statement.definition'<TEXT_CHUNK_END_>,9:24]
                    statements_list
                      pop_statement
                        free_input_string
                          text_chunk_end        [@10,269:272='true'<TEXT_CHUNK_END_>,10:22]
                leave_block     [@11,296:296='}'<CLOSE_BRACE>,12:9]
      leave_block       [@12,304:304='}'<CLOSE_BRACE>,14:1]

Abstract Syntax Tree
language_syntax
  preamble_statements
    master_scope_name_statement InputString str: , is_out_of_scope: [], chunks: [source.sma], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
    target_language_name_statement      InputString str: , is_out_of_scope: [], chunks: [Abstract Machine Language], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
  language_construct_rules
    indentation_block
      statements_list
        match_statement
          InputString str: if\(, is_out_of_scope: [], chunks: [if\(], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: True;
          statements_list
            scope_name_statement        InputString str: , is_out_of_scope: [], chunks: [if.statement.definition], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
          statements_list
            push_statement
              indentation_block
                statements_list
                  meta_scope_statement  InputString str: , is_out_of_scope: [], chunks: [if.statement.body], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
                statements_list
                  match_statement
                    InputString str: \), is_out_of_scope: [], chunks: [\)], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: True;
                    statements_list
                      scope_name_statement      InputString str: , is_out_of_scope: [], chunks: [if.statement.definition], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
                    statements_list
                      pop_statement     InputString str: , is_out_of_scope: [], chunks: [true], definitions: {}, errors: [], indentations: [<indent 2, open 133, close 296>, <indent 1, open 60, close 304>], is_resolved: False;
\end{minted}
\end{code}


\chapter[main\_highlighter.py]{Execução de ``main\_highlighter.py''}

O programa do \typeref{MainHighlighterPy} faz a criação de 5 artefatos de resultado.
Duas árvores em forma de figura,
duas arvores em forma de texto e
uma arquivo HTML.
No \typeref{MainHighlighterHtml},
encontra~=se o arquivo HTML gerado pelo programa de exemplo (\typeref{MainHighlighterPy}).

Nas \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree},
encontram~=se as imagens geradas pelo programa ``main\_highlighter.py'' (\typeref{MainHighlighterPy}).
No \typeref{MainHighlighterPyResult},
encontra~=se a saída da linha de comando que se obtém ao realizar a execução do programa de exemplo (\typeref{MainHighlighterPy}).
Ambas as figuras \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree} quanto o \typeref{MainHighlighterPyResult} representam os mesmos dados,
mas mostrados de formas diferentes (figura \textit{versus} textual) e
com níveis de detalhes diferentes.
No \typeref{MainHighlighterPyResult},
são mostrado os nós folhas das árvores com maior nível de detalhes.
Já nas \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree} os nós folhas são mostrados com simplificações para que a figura possa vista em uma única tela.
\begin{code}
\caption{Arquivo HTML gerado pelo programa de exemplo ``main\_highlighter.py''}
\label{MainHighlighterHtml}
\begin{minted}{html}
<!DOCTYPE html><html><head><title>Abstract Machine Language - source.sma</title></head>
<body style="white-space: pre; font-family: monospace;"><font color="#FF0000" grammar_scope="comment.start.sma" theme_scope="comment">//</font><font color="#00FF00" grammar_scope="comment.line.sma" theme_scope="comment.line"> Example single line commentary</font></body></html>
\end{minted}
\end{code}

\begin{figure}[h]
\caption{Árvore de Sintaxe ``main\_highlighter\_syntax\_tree.png''}
\label{MainHighlighterSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_highlighter_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{figure}[h]
\caption{Árvore de Sintaxe Abstrata ``main\_highlighter\_abstract\_syntax\_tree.png''}
\label{MainHighlighterAbstractSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_highlighter_abstract_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{code}
\caption{Resultado da execução do arquivo ``source/main\_highlighter.py''}
\label{MainHighlighterPyResult}
\begin{minted}{text}
$ python main_highlighter.py
Syntax Tree
language_syntax
  preamble_statements
    master_scope_name_statement
      free_input_string
        text_chunk_end  [@1,7:16='source.sma'<TEXT_CHUNK_END_>,1:8]
    target_language_name_statement
      free_input_string
        text_chunk_end  [@2,24:48='Abstract Machine Language'<TEXT_CHUNK_END_>,2:7]
  language_construct_rules
    indentation_block
      enter_block       [@3,60:60='{'<OPEN_BRACE>,3:11]
      statements_list
        match_statement
          braced_free_input_string
            braced_text_chunk_end       [@4,73:74='//'<BRACED_TEXT_CHUNK_END_>,4:12]
          statements_list
            scope_name_statement
              free_input_string
                text_chunk_end  [@5,93:109='comment.start.sma'<TEXT_CHUNK_END_>,5:16]
          statements_list
            push_statement
              indentation_block
                enter_block     [@6,125:125='{'<OPEN_BRACE>,6:15]
                statements_list
                  meta_scope_statement
                    free_input_string
                      text_chunk_end    [@7,151:166='comment.line.sma'<TEXT_CHUNK_END_>,7:25]
                statements_list
                  match_statement
                    braced_free_input_string
                      braced_text_chunk_end     [@8,187:191='\\n|\\$'<BRACED_TEXT_CHUNK_END_>,8:20]
                    statements_list
                      pop_statement
                        free_input_string
                          text_chunk_end        [@9,216:219='true'<TEXT_CHUNK_END_>,9:22]
                leave_block     [@10,243:243='}'<CLOSE_BRACE>,11:9]
      leave_block       [@11,251:251='}'<CLOSE_BRACE>,13:1]

Abstract Syntax Tree
language_syntax
  preamble_statements
    master_scope_name_statement InputString str: , is_out_of_scope: [], chunks: [source.sma], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: False;
    target_language_name_statement      InputString str: , is_out_of_scope: [], chunks: [Abstract Machine Language], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: False;
  language_construct_rules
    indentation_block
      statements_list
        match_statement
          InputString str: //, is_out_of_scope: [], chunks: [//], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: True;
          statements_list
            scope_name_statement        InputString str: , is_out_of_scope: [], chunks: [comment.start.sma], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: False;
          statements_list
            push_statement
              indentation_block
                statements_list
                  meta_scope_statement  InputString str: , is_out_of_scope: [], chunks: [comment.line.sma], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: False;
                statements_list
                  match_statement
                    InputString str: \n|$, is_out_of_scope: [], chunks: [\n|\$], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: True;
                    statements_list
                      pop_statement     InputString str: , is_out_of_scope: [], chunks: [true], definitions: {}, errors: [], indentations: [<indent 2, open 125, close 243>, <indent 1, open 60, close 251>], is_resolved: False;
\end{minted}
\end{code}


\chapter[Testes de Unidade]{Código dos Testes de Unidade}

Para se executar os testes de unidade,
basta executar o comando ``\mintinline{shell}{python3 unit_tests.py}''.
No \typeref{unitTestsResults},
pode~=se encontrar um exemplo de execução dos testes de unidade apresentados no \typeref{unitTestsPy}.
Primeiro foi desenvolvida a ferramenta de Adição de Cores para facilitar os testes da metalinguagem e
do Analisador Semântico.
Uma vez que se comprovou o funcionamento da metalinguagem,
foi realizada um implementação mínima de um formatador de código~=fonte.

Tanto as implementações do módulo de Adição de Cores quanto a do Formatador de Código são somente uma prova de conceito do que pode ser feito com a metalinguagem desenvolvida.
No \typeref{unitTestsPy},
a classe ``TestingGrammarUtilities'' é uma classe abstrata \cite{understandingDataAbstraction} que contém características necessárias a todos os tipos de testes de unidades implementados,
tanto os testes de unidade de Adição de Cores quanto os testes de unidade do Formatador de Código.
No total existem 22 testes:
\begin{enumerate}[i)]
\item 16 testes do Analisador Semântico \typeref{semanticAnalyzerPy} na classe testes ``TestSemanticRules'';
\item 5 testes de Adição de Cores \typeref{codeHighlighterPy} na classe testes ``TestCodeHighlighterBackEnd'';
\item 1 testes de Formatação de Código \typeref{codeFormatterPy} na classe testes ``TestCodeFormatterBackEnd''.
\end{enumerate}%

Como a ferramenta de Adição de Cores foi a primeira desenvolvida,
ela obteve a criação de mais testes de unidade para assegurar que a implementação do Analisador Semântico \typeref{semanticAnalyzerPy} e
da Metagramática estão funcionais.
Uma vez feito isso,
duplicou~=se o código~=fonte da implementação de adição de cores \typeref{codeHighlighterPy} e
realizou~=se as alterações necessárias para que se faça a formatação de código~=fonte \typeref{codeFormatterPy}.
\begin{code}
\caption{Resultado da execução dos Testes de Unidade}
\label{unitTestsResults}
\begin{minted}{text}
$ python3 unit_tests.py
00:02:41:738.736391 1.52e-04 - source.<module>:52 - Importing __main__
......................
----------------------------------------------------------------------
Ran 22 tests in 2.086s

OK
\end{minted}
\end{code}
\begin{code}
\caption{Arquivo ``source/unit\_tests.py''}
\label{unitTestsPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/unit_tests.py}
\end{code}


\chapter[Analisador Semântico]{Código do Analisador Semântico}

De todos os códigos~=fonte criados neste trabalho,
o Analisador Semântico (\typeref{semanticAnalyzerPy}) é o maior deles.
Sua implementação é utilizada diretamente pelo módulo de Adição de Cores e
Formatação de Código.
As regras do Analisador Semântico estão divididas entre dois tipos,
erros e
alertas.
Um erro é algo que impede completamente o programa final de funcionar.
Um alerta é algo que não impede que o programa final funcione corretamente,
mas é algo que precisa ser revisto.

Os testes das regras do Analisador Semântico podem ser encontradas na classe ``TestSemanticRules'' do \typeref{unitTestsPy}.
A seguir pode~=se encontrar algumas das regras semânticas implementadas pelo Analisador Semântico do \typeref{semanticAnalyzerPy}.
O nome de cada uma das regras a seguir começa com o prefixo ``test\_'' que corresponde ao nome do teste de unidade,
criado para verificar tal regra semântica na classe de testes ``TestSemanticRules'' (\typeref{unitTestsPy}).
\begin{enumerateoptional}[1)]
    \item[\bfseries\mintinline{text}{test_duplicatedContext}] Detecção de contextos duplicados e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_duplicatedIncludes}] Detecção de inclusões duplicadas  e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_invalidRegexInput}] Detecção de expressões regulares inválidas e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingIncludeDetection}] Detecção da inclusão um bloco inexistente e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_duplicatedGlobalNames}] Detecção de múltiplas definições do nome da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingScopeGlobalName}] Detecção da falta da definição do nome do escopo global da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingNameGlobal}] Detecção de esquecer de definir o nome da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_unsusedInclude}] Detecção de criação de um contexto e
    em esquecer de utilizar ele e
    emissão de um alerta;

    \item[\bfseries\mintinline{text}{test_redifinedConst}] Detecção de redefinir um valor constante e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_unsusedConstantDeclaration}] Detecção de definir um valor constante e esquecer de utilizar ele e
    emissão de um alerta;

    \item[\bfseries\mintinline{text}{test_usingConstOutOfScope}] Detecção de tentativa de usar um valor constante fora do escopo dele e
    emissão de um erro semântico.
\end{enumerateoptional}%
\begin{code}
\caption{Arquivo ``source/semantic\_analyzer.py''}
\label{semanticAnalyzerPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/semantic_analyzer.py}
\end{code}


\chapter{Código de Adição de Cores}

Neste capítulo,
pode~=se ver na íntegra o arquivo do formatador de código~=fonte (\typeref{codeHighlighterPy}) que faz uso da metagramática no \typeref{grammarsGrammarPushdown}.
No \typeref{MainHighlighterPy},
pode~=se encontrar um exemplo explicito de utilização do \typeref{codeHighlighterPy}.
\begin{code}
\caption{Arquivo ``source/code\_highlighter.py''}
\label{codeHighlighterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/code_highlighter.py}
\end{code}


\chapter{Código do Formatador}

Neste capítulo,
pode~=se ver na íntegra o arquivo do formatador de código~=fonte (\typeref{codeFormatterPy}) que faz uso da metagramática no \typeref{grammarsGrammarPushdown}.
No \typeref{MainFormatterPy},
pode~=se encontrar um exemplo explicito de utilização do \typeref{codeFormatterPy}.
\begin{code}
\caption{Arquivo ``source/code\_formatter.py''}
\label{codeFormatterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/code_formatter.py}
\end{code}


\chapter{Código da Metagramática}

Neste capítulo,
pode~=se ver na íntegra o arquivo da gramática (\typeref{grammarsGrammarPushdown}) utilizadas pela adição de cores e
formatação de código~=fonte.
Nos \typeref{MainFormatterPy,MainHighlighterPy},
pode~=se ver o importe explicito deste arquivo de gramática e
seu recebimento pela Analisador Lark (Veja a \fullref{GrammarsGrammar}).
Nesta gramática,
pode ser encontrado expressões redundantes como \mintinline{antlr}{enter_block:
OPEN_BRACE} que servem para fazer com que a árvore de sintaxe tenha um nó com o nome ``\mintinline{text}{enter_block}'' e
com que o analisador léxico gere um \textit{token} com o nome ``\mintinline{text}{OPEN_BRACE}''.
Estas características facilitam a manipulação da árvore de sintaxe e
operações com \textit{tokens}.
\begin{code}
\caption{Arquivo ``source/grammars\_grammar.pushdown''}
\label{grammarsGrammarPushdown}
\inputminted[firstline=39,firstnumber=1]{antlr}{../source/grammars_grammar.pushdown}
\end{code}
