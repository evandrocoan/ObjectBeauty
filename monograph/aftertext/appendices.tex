

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter[Manual do Formatador]{Manual do Formatador de Código}
\label{manualDoFormatadorDeCodigo}

Esse apêndice apresenta um manual da ferramenta.
Não recomenda~=se que usuários que não possuam conhecimentos sobre a semântica das linguagens de programação\advisor{}{,
} utilizem esta ferramenta para realizar a formatação de código~=fonte.
Neste caso,
o mais indicado é que sejam utilizados as demais ferramentas de formatação,
que hoje são mais especificas para cada linguagem individualmente e
possuem inerentemente os conhecimentos específicos da sintaxe e
semântica da linguagem a ser formatada.

Não foi criada nenhuma interface gráfica ou
de linha de comando que faça a entrada do programa a ser formatado e
das configurações do formatador de código~=fonte.
Existem duas implementações que utilizam a metalinguagem (\typeref{grammarsGrammarPushdown}).
Uma utiliza a metalinguagem para adicionar cores (\typeref{codeHighlighterPy}),
como feito em editores de texto e
a outra realiza a formatação de código~=fonte (\typeref{codeFormatterPy}).

Nos \typeref{MainFormatterPy,MainHighlighterPy,utilitiesPy},
encontra~=se um exemplo simples de programa que pode ser construído para executar o Formatador de Código e
a Adição de Cores.
Sua construção é a mesma utilizada para a criação dos testes de unidade (\typeref{unitTestsPy}).
Para manter a implementação simples,
tanto o \typeref{MainFormatterPy} quanto o \typeref{MainHighlighterPy} geram como resultado arquivos HTML \cite{parallelParserForHTML},
contendo como conteúdo o resultado de seu trabalho,
i.e., respectivamente,
o código~=fonte formatado ou
com a adição de cores.
Também,
gerando páginas HTML para o formatador de código~=fonte será possível observar com mais facilidade o código~=fonte original e
formatado,
e as metainformações atribuídas pela gramática da linguagem como atributos das tags HTML.

Nos \typeref{MainFormatterPyResult,MainHighlighterPyResult},
serão encontrados como nós~=folha das árvores,
os \textit{tokens} criados pelo analisador léxico.
Eles seguem o mesmo padrão de notação dos \textit{tokens} utilizados pelo Analisador ANTLR \cite{antlrBookTerrentParr}.
A implementação da exibição dos \textit{tokens} no formato do analisador ANTLR 4 foi uma das implementações feitas no \textit{fork} ``pushdown'' do Analisador Lark (Veja a \fullref{GrammarsGrammar}).

Um \textit{token} como ``\mintinline{text}{[@7,151:166='comment.line.sma'<TEXT_CHUNK_END_>,7:25]}'' segue o modelo de representação do ANTLR 4 \cite{antlrBookTerrentParr} e
contém as seguintes informações:
\begin{inparaenum}[1)]
\item ``\mintinline{text}{@7}'' significa que ele é o sétimo \textit{token};
\item ``\mintinline{text}{151:166}'' é o início e
fim do lexema do \textit{token} no programa de entrada,
contado apartir de 0 até o fim do programa;
\item ``\mintinline{text}{='comment.line.sma'}'' é o lexema (Veja a \fullref{compiladoresEtradutores}) ou
conteúdo do \textit{token} propriamente dito;
\item ``\mintinline{text}{<TEXT_CHUNK_END_>}'' é o nome do \textit{token} atribuído pela gramática de entrada,
por fim;
\item ``\mintinline{text}{7:25}'' é a linha e
coluna do \textit{token} no programa de entrada.
\end{inparaenum}%

Tanto para a escrita do \typeref{codeHighlighterPy},
quanto para a escrita do \typeref{codeFormatterPy},
por consequência,
foi utilizado em um primeiro momento a biblioteca ``dominate'' para realizar a construção da página HTML com a adição de cores ou
código~=formatado. Entretanto,
devido a \textit{bugs} na biblioteca ``dominate'',
a página HTML era gerada de forma errada.
Por fim,
optou~=se em escrever o código necessário para gerar a páginas HTML,
fazendo o uso da biblioteca ``dominate'' somente para realizar a conversão de caracteres especiais para seus correspondes em HTML.
Por exemplo,
o caractere ``<'' em HTML é escrito como ``\&lt;''.

Não foi escolhido procurar uma outra biblioteca para fazer a criação de páginas HTML,
porque ao pesquisar por bibliotecas que tinham somente esta função,
não foi encontrado nenhuma similar.
Para realizar a pesquisa,
por uma nova biblioteca de geração de HTML,
foram utilizados os seguintes critérios:
\begin{inparaenum}[1)]
\item ser um biblioteca de código~=aberto (\textit{open~=source});
\item ser ativa,
i.e.,
possuir novos recursos (\textit{features}) ou
\textit{bugs} sendo reportados e
corrigidos no último ano.
\end{inparaenum}%

Somente foram encontrados bibliotecas com \citeonline{flaskPython} conseguem gerar páginas HTML,
mas que também são servidores HTML ou
Web,
que vão muito além das necessidades deste projeto.
Portando,
optou~=se por fazer todo o código necessário para geração de páginas HTML.
Dispensando a necessidade de escolher outra ferramenta.
Não existe a necessidade explicita de utilizar um biblioteca HTML para gerar páginas HTML.
Pode~=se tranquilamente escrever o código HTML necessário para as necessidades deste projeto,
sem o uso de um biblioteca HTML.
A vantagem de utilizar uma biblioteca HTML é uma melhor legibilidade do código escrito em Python,
que será mais parecido com o código HTML \cite{webDevelopmentWithDjango}.

Para se realizar a execução de qualquer arquivo deste projeto,
é necessário ter um interpretador ``Python 3.6'' instalado,
junto com as bibliotecas ``pip3'',
``debug\_tools'', ``dominate'' e
``pushdown''.
Em uma instalação tradicional ``Ubuntu'',
estes pacotes podem ser instalados com os seguintes comandos:
\begin{enumerate}[1)]
\item \mintinline{shell}{sudo apt-get install python3 python3-pip}
\item \mintinline{shell}{pip3 install -r requirements.txt} (\typeref{requirementsTxt})
\item \mintinline{shell}{python3 main_formatter.py} (\typeref{MainFormatterPy})
\item \mintinline{shell}{python3 main_highlighter.py} (\typeref{MainHighlighterPy})
\end{enumerate}

\begin{code}
\caption{Arquivo ``source/requirements.txt''}
\label{requirementsTxt}
\inputminted{python3}{../source/requirements.txt}
\end{code}

\begin{code}
\caption{Arquivo ``source/main\_formatter.py''}
\label{MainFormatterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/main_formatter.py}
\end{code}

\begin{code}
\caption{Arquivo ``source/main\_highlighter.py''}
\label{MainHighlighterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/main_highlighter.py}
\end{code}

\begin{code}
\caption{Arquivo ``source/utilities.py''}
\label{utilitiesPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/utilities.py}
\end{code}


\chapter[main\_formatter.py]{Execução de ``main\_formatter.py''}
\label{chapter:execucaoDeMainFormatter}

O programa do \typeref{MainFormatterPy},
faz a criação de 5 artefatos de resultado.
Duas árvores em forma de figura,
duas árvores em forma de texto e
uma arquivo HTML.
No \typeref{MainFormatterHtml},
encontra~=se o arquivo HTML gerado pelo programa de exemplo (\typeref{MainFormatterPy}).

Nas \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree},
encontram~=se as imagens geradas pelo programa ``main\_formatter.py'' (\typeref{MainFormatterPy}).
No \typeref{MainFormatterPyResult},
encontra~=se a saída da linha de comando que se obtém ao realizar a execução do programa de exemplo (\typeref{MainFormatterPy}).
Ambas as figuras \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree} quanto o \typeref{MainFormatterPyResult} representam os mesmos dados,
mas mostrados de formas diferentes (figura \textit{versus} textual) e
com níveis de detalhe diferentes.
No \typeref{MainFormatterPyResult},
são mostrado os nós~=folhas das árvores com maior nível de detalhe.
Já nas \typeref{MainFormatterSyntaxTree,MainFormatterAbstractSyntaxTree},
os nós~=folhas são mostrados com simplificações para que a figura possa ser vista em uma única tela.
\begin{code}
\caption{Arquivo HTML gerado pelo programa de exemplo ``main\_formatter.py''}
\label{MainFormatterHtml}
\begin{minted}{html}
<!DOCTYPE html><html><head><title>Abstract Machine Language - source.sma</title></head>
<body style="white-space: pre; font-family: monospace;"><span setting="unformatted" grammar_scope="if.statement.definition" setting_scope="" original_program="if(">if(</span><span setting="2" grammar_scope="if.statement.body" setting_scope="if.statement.body" original_program="something">  something  </span><span setting="unformatted" grammar_scope="if.statement.definition" setting_scope="" original_program=")">)</span><span grammar_scope="none" setting_scope="none"> bar</span></body></html>
\end{minted}
\end{code}

\begin{figure}[!htb]
\caption{Árvore Sintática ``main\_formatter\_syntax\_tree.png''}
\label{MainFormatterSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_formatter_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{figure}[!htb]
\caption{Árvore Sintática Abstrata ``main\_formatter\_abstract\_syntax\_tree.png''}
\label{MainFormatterAbstractSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_formatter_abstract_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{code}
\caption{Resultado da execução do arquivo ``source/main\_formatter.py''}
\label{MainFormatterPyResult}
\inputminted{text}{aftertext/main_formatter_output.txt}
\end{code}


\chapter[main\_highlighter.py]{Execução de ``main\_highlighter.py''}

O programa do \typeref{MainHighlighterPy},
faz a criação de 5 artefatos de resultado.
Duas árvores em forma de figura,
duas árvores em forma de texto e
uma arquivo HTML.
No \typeref{MainHighlighterHtml},
encontra~=se o arquivo HTML gerado pelo programa exemplo (\typeref{MainHighlighterPy}).

Nas \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree},
encontram~=se as imagens geradas pelo programa ``main\_highlighter.py'' (\typeref{MainHighlighterPy}).
No \typeref{MainHighlighterPyResult},
encontra~=se a saída da linha de comando que se obtém ao realizar a execução do programa de exemplo (\typeref{MainHighlighterPy}).
Ambas as figuras \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree} quanto o \typeref{MainHighlighterPyResult} representam os mesmos dados,
mas mostrados de formas diferentes (figura \textit{versus} textual) e
com níveis de detalhe diferentes.
No \typeref{MainHighlighterPyResult} são mostrado os nós~=folhas das árvores com maior nível de detalhe.
Já nas \typeref{MainHighlighterSyntaxTree,MainHighlighterAbstractSyntaxTree},
os nós~=folhas são mostrados com simplificações para que a figura possa ser vista em uma única tela.
\begin{code}
\caption{Arquivo HTML gerado pelo programa de exemplo ``main\_highlighter.py''}
\label{MainHighlighterHtml}
\begin{minted}{html}
<!DOCTYPE html><html><head><title>Abstract Machine Language - source.sma</title></head>
<body style="white-space: pre; font-family: monospace;"><font color="#FF0000" grammar_scope="comment.start.sma" theme_scope="comment">//</font><font color="#00FF00" grammar_scope="comment.line.sma" theme_scope="comment.line"> Example single line commentary</font></body></html>
\end{minted}
\end{code}

\begin{figure}[!htb]
\caption{Árvore Sintática ``main\_highlighter\_syntax\_tree.png''}
\label{MainHighlighterSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_highlighter_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{figure}[!htb]
\caption{Árvore Sintática Abstrata ``main\_highlighter\_abstract\_syntax\_tree.png''}
\label{MainHighlighterAbstractSyntaxTree}
\centering
\includegraphics[width=1.0\textwidth]{main_highlighter_abstract_syntax_tree.png}
\fonte{Própria}
\end{figure}

\begin{code}
\caption{Resultado da execução do arquivo ``source/main\_highlighter.py''}
\label{MainHighlighterPyResult}
\inputminted{text}{aftertext/main_highlighter_output.txt}
\end{code}


\chapter[Testes de Unidade]{Código dos Testes de Unidade}

Primeiro foi desenvolvida a ferramenta de Adição de Cores para facilitar os testes da metalinguagem e
do Analisador Semântico.
Uma vez que se comprovou o funcionamento da metalinguagem,
foi realizada uma implementação mínima de um formatador de código~=fonte.

Tanto as implementações do módulo de Adição de Cores quanto do Formatador de Código são somente uma prova de conceito do que pode ser feito com a metalinguagem desenvolvida.
No \typeref{unitTestsPy},
a classe ``TestingGrammarUtilities'' é uma classe abstrata \cite{understandingDataAbstraction} que contém características necessárias a todos os tipos de testes de unidades implementados,
tanto os testes de unidade de Adição de Cores quanto os testes de unidade do Formatador de Código.
No total existem 22 testes:
\begin{enumerate}[i)]
\item 16 testes do Analisador Semântico (\typeref{semanticAnalyzerPy}) na classe testes ``TestSemanticRules'';
\item 5 testes de Adição de Cores (\typeref{codeHighlighterPy}) na classe testes ``TestCodeHighlighterBackEnd'';
\item 1 testes de Formatação de Código (\typeref{codeFormatterPy}) na classe testes ``TestCodeFormatterBackEnd''.
\end{enumerate}%

A ferramenta de Adição de Cores foi a primeira desenvolvida,
portanto obteve a criação de mais testes de unidade para verificar a implementação do Analisador Semântico (\typeref{semanticAnalyzerPy}).
Para se executar os testes de unidade,
basta executar o comando ``\mintinline{text}{python3 unit_tests.py}''.
No \typeref{unitTestsResults},
pode~=se encontrar um exemplo de execução dos testes de unidade apresentados no \typeref{unitTestsPy}.
\begin{code}
\caption{Resultado da execução dos Testes de Unidade}
\label{unitTestsResults}
\begin{minted}{text}
$ python3 unit_tests.py
00:02:41:738.736391 1.52e-04 - source.<module>:52 - Importing __main__
......................
----------------------------------------------------------------------
Ran 22 tests in 2.086s

OK
\end{minted}
\end{code}
\begin{code}
\caption{Arquivo ``source/unit\_tests.py''}
\label{unitTestsPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/unit_tests.py}
\end{code}


\chapter[Analisador Semântico]{Código do Analisador Semântico}

De todos os códigos~=fonte criados neste trabalho,
o Analisador Semântico (\typeref{semanticAnalyzerPy}) é o maior deles.
Sua implementação é utilizada diretamente pelo módulo de Adição de Cores e
Formatação de Código.
As regras do Analisador Semântico estão divididas entre dois tipos,
erros e
alertas.
Um erro é algo que impede completamente a gramática final de funcionar.
Um alerta é algo que precisa pode precisar ser revisado.

A seguir pode~=se encontrar algumas regras semânticas implementadas pelo Analisador Semântico (\typeref{semanticAnalyzerPy}).
A classe ``TestSemanticRules'' (\typeref{unitTestsPy}),
apresenta testes automatizados do Analisador Semântico.
O nome de cada uma das regras a seguir começa com o prefixo ``test\_'' que corresponde ao nome do teste de unidade automatizado,
criado para verificar tal regra semântica na classe de testes ``TestSemanticRules'' (\typeref{unitTestsPy}).
\begin{enumerateoptional}[1)]
    \item[\bfseries\mintinline{text}{test_duplicatedContext}] Detecção de contextos duplicados e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_duplicatedIncludes}] Detecção de inclusões duplicadas  e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_invalidRegexInput}] Detecção de expressões regulares inválidas e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingIncludeDetection}] Detecção da inclusão um bloco inexistente e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_duplicatedGlobalNames}] Detecção de múltiplas definições do nome da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingScopeGlobalName}] Detecção da falta da definição do nome do escopo global da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_missingNameGlobal}] Detecção de esquecer de definir o nome da gramática e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_unsusedInclude}] Detecção de criação de um contexto e
    em esquecer de utilizar ele e
    emissão de um alerta;

    \item[\bfseries\mintinline{text}{test_redifinedConst}] Detecção de redefinir um valor constante e
    emissão de um erro semântico;

    \item[\bfseries\mintinline{text}{test_unsusedConstantDeclaration}] Detecção de definir um valor constante e esquecer de utilizar ele e
    emissão de um alerta;

    \item[\bfseries\mintinline{text}{test_usingConstOutOfScope}] Detecção de tentativa de usar um valor constante fora do escopo dele e
    emissão de um erro semântico.
\end{enumerateoptional}%
\begin{code}
\caption{Arquivo ``source/semantic\_analyzer.py''}
\label{semanticAnalyzerPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/semantic_analyzer.py}
\end{code}


\chapter{Código de Adição de Cores}

Neste capítulo,
pode~=se ver na íntegra o arquivo do formatador de código~=fonte (\typeref{codeHighlighterPy}),
que faz uso da metagramática no \typeref{grammarsGrammarPushdown}.
No \typeref{MainHighlighterPy},
pode~=se encontrar um exemplo explicito de utilização do \typeref{codeHighlighterPy}.
\begin{code}
\caption{Arquivo ``source/code\_highlighter.py''}
\label{codeHighlighterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/code_highlighter.py}
\end{code}


\chapter{Código do Formatador}
\label{chapter:codigoDoFormatador}

Neste capítulo,
pode~=se ver na íntegra o arquivo do formatador de código~=fonte (\typeref{codeFormatterPy}) que faz uso da metagramática no \typeref{grammarsGrammarPushdown}.
No \typeref{MainFormatterPy},
pode~=se encontrar um exemplo explicito de utilização do \typeref{codeFormatterPy}.
\begin{code}
\caption{Arquivo ``source/code\_formatter.py''}
\label{codeFormatterPy}
\inputminted[firstline=39,firstnumber=1]{python3}{../source/code_formatter.py}
\end{code}


\chapter{Código da Metagramática}
\label{chapter:codigoDaMetagramatica}

Neste capítulo,
pode~=se ver na íntegra o arquivo da gramática (\typeref{grammarsGrammarPushdown}) utilizada pela adição de cores e
formatação de código~=fonte.
Nos \typeref{MainFormatterPy,MainHighlighterPy},
pode~=se ver o uso explicito deste arquivo de gramática (\mintinline{text}{get_relative_path( "grammars_grammar.pushdown",
__file__ )})) e
seu recebimento pelo Analisador Lark (Veja a \fullref{GrammarsGrammar}).
Nesta gramática,
podem ser encontradas produções como \mintinline{text}{enter_block:
OPEN_BRACE} que servem para fazer com que a árvore sintática tenha um nó com o nome ``\mintinline{text}{enter_block}'' e
com que o analisador léxico gere um \textit{token} com o nome ``\mintinline{text}{OPEN_BRACE}''.
Estas características facilitam a manipulação da árvore sintática e
operações com \textit{tokens}.
\begin{code}
\caption{Arquivo ``source/grammars\_grammar.pushdown''}
\label{grammarsGrammarPushdown}
\inputminted[firstline=39,firstnumber=1]{antlr}{../source/grammars_grammar.pushdown}
\end{code}
