

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{Uma Ferramenta de Formatação}
\label{software_implementation}

Neste capítulo será explicado o funcionamento e
implementação de uma nova ferramenta de formatação e
os desafios de trabalhos futuros sobre esta implementação.


\section{Uma Gramática de Gramáticas}

Na \fullref{introducaoGramaticas},
foi explicado o que são gramáticas.
Mas,
como gramáticas podem ser expressadas?
Isso depende de como o Analisador delas foi implementado,
sendo assim,
um detalhe de implementação.
Usualmente,
os Analisadores seguem uma notação comum como EBNF\footnote{
Do inglês,
\textit{Extended Backus–Naur Form} uma extensão do padrão BNF.
}\cite{teachingEbnf,antlrBookTerrentParr},
que não difere muito de um Analisador para outros,
exceto por detalhes de implementação específicos de cada Analisador.

Para realizar a implementação da nova ferramenta de formatação de código,
foi realizado a construção de uma nova gramática de gramáticas de uma nova linguagem chamada de ``ObjectBeauty'',
uma meta~=linguagem \cite{compilersCompilerMetaLanguage}.
Na \typeref{MyWorflowForLarkTraduzido} é apresentado o fluxo de uso comum para um analisador.
Neste processo,
o desenvolvedor da linguagem escreve a gramática de especificação desta linguagem,
que é entregue a algum Analisador e
gera~=se um Compilador para tal linguagem.
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido.png}
\caption[Fluxo de uso comum de um Analisador]{Fluxo de uso comum de um Analisador -- Fonte Própria \cite{larkErrorRecovery}}
\label{MyWorflowForLarkTraduzido}
\end{figure}

Já este trabalho faz um uso fora do comum.
Como mostrado na \typeref{MyWorflowForLarkTraduzido2},
primeiro especifica~=se uma gramática de gramáticas (meta~=linguagem) que será utilizada pelos usuários da nova ferramenta de formatação.
Para escrever esta nova meta~=linguagem,
utilizou~=se a ferramenta Lark \cite{larkContextualLexer}.
Usualmente a ferramenta ``Lark'' é utilizada somente como um gerador de compiladores \typeref{MyWorflowForLarkTraduzido},
entretanto neste contexto é utilizado como um compilador de compiladores \typeref{MyWorflowForLarkTraduzido2}.
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido2.png}
\caption[Uso feito pela nova ferramenta de formatação]{Uso feito pela nova ferramenta de formatação -- Fonte Própria \cite{larkErrorRecovery}}
\label{MyWorflowForLarkTraduzido2}
\end{figure}

Em vez de permitir com que o usuário final da aplicação opere diretamente com o Analisador da \typeref{MyWorflowForLarkTraduzido},
foi criado uma nova gramática de gramáticas como mostrado nas \typeref{MyWorflowForLarkTraduzido2}.
Esta nova gramática simplifica o processo de escrita de gramáticas ao criar uma nova especificação de gramáticas,
somente com os recursos necessários para se possa trabalhar com formatação de código.
A final,
não é objetivo deste trabalho fazer a análise completa de programas,
pela sua sintaxe e
semântica e
gerar código~=binário executável.

Na \typeref{ParsersPublicAudienceTraduzido},
pode~=se encontrar uma relação entre o funcionamento das diversas partes da ferramenta de formatação de código~=fonte e
a audiência alvo.
Basicamente existem três grupos distintos de usuários ou
audiência:
\begin{inparaenum}[1)]
\item quem escreve ou
desenvolve a ferramenta de formatação de código~=fonte desenvolvida neste trabalho e
defini as regras da metalinguagem (especificada pela sua metagramática,
i.e.,
a gramática de gramáticas),
\item quem escreve ou
desenvolve gramáticas de linguagens para serem formatados de acordo com as regras da metalinguagem e
\item quem escreve ou
desenvolvedor programas de computador e
deseja realizar a formatação de seus códigos~=fonte.
\end{inparaenum}%
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{ParsersPublicAudienceTraduzido.png}
\caption[Relacionamentos entre os Diferentes Públicos deste Projeto]{Relacionamentos Entre os Diferentes Públicos deste Projeto -- Fonte Própria \cite{larkErrorRecovery}}
\label{ParsersPublicAudienceTraduzido}
\end{figure}

Esta não é a primeira vez que uma gramática de gramáticas com simplificação foi escrita.
Em trabalhos como \citeonline{rustSublimeTextSyntaxSyntec,sublimeTextSyntax,vsCodeSyntaxHighlighthing} foram realizados as mesmos simplificações aqui apresentadas.
Existem algumas diferenças técnicas da gramática de gramáticas deste trabalho com as dos recém apresentados.
Como por exemplo,
esta gramática de gramáticas não suporta a classificação do mesmo trecho de código~=fonte por múltiplos tipos de escopo \cite{vsCodeSyntaxHighlighthing}.

Foi escolhido a criação de uma nova metagramática por que as gramáticas já existentes como \citeonline{rustSublimeTextSyntaxSyntec,vsCodeSyntaxHighlighthing}
\begin{inparaenum}[1)]
\item não são capazes de reconhecer todas as características de todas as linguagens de formatação e
\item não possuem sintaxe própria,
i.e.,
elas utilizam de outras linguagens como YAML,
XML e
JSON para fazer a especificação da gramática.
\end{inparaenum}
Assim,
fazendo a especificação de uma nova metagramática,
é possível adaptar~=se a especificação da sintaxe das gramáticas de acordo as necessidades específicas sem ter que depender de características de outras linguagens como YAML,
XML ou
JSON.


\subsection{Escopos}

Na \typeref{TexMateScopes} é mostrado na primeira linha o trecho de código~=fonte ``function f1 () \{'' e
nas demais linhas são apresentados as diversas classificações de escopos aplicados a cada um dos trechos do código~=fonte de amostra.
Por exemplo, a palavra ``function'' possui simultaneamente os escopos
\begin{inparaenum}[1)]
\item ``source.js''
\item ``meta.function.js'' e
\item ``storage.type.function.js''.
\end{inparaenum}
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{TexMateScopes.png}
\caption[Exemplo de Classificação de Código~=Fonte com Múltiplos Escopos]{Exemplo de Classificação de Código~=Fonte com Múltiplos Escopos -- Fonte \citeonline{vsCodeSyntaxHighlighthing}}
\label{TexMateScopes}
\end{figure}

Os nomes utilizados na \typeref{TexMateScopes} podem ser qualquer texto que usuário especificador daquela gramática desejar.
Entretanto,
pode~=se perceber que o nome dos escopos recém apresentados aparentam seguir um padrão.
Por conversão,
desenvolvedores de gramáticas para os editores de texto como \citeonline{sublimeTextSyntax,vsCodeSyntaxHighlighthing},
seguem uma conversão de nomes para que as utilizações dos escopos gerados pelas gramáticas sejam compatíveis entre si.

Fazendo o uso desta convenção,
as gramáticas ficam compatíveis com um maior número de arquivos de temas onde são especificados os nomes dos escopos serão utilizados para especificar as cores a serem utilizadas pelo editor de texto.
Para mais informações sobre a utilização de arquivos de temas em editores de texto veja \citeonline{sublimeTextScopeNaming,vsCodeSyntaxHighlighthing}.


\section{Metalinguagem}

Como já explicado na seção anterior,
uma metagramática é gramática de gramáticas e
foi utilizado a ferramenta ``Lark'' \cite{larkContextualLexer} como um meta~=compilador ou
compilador de compiladores.
Nesta seção será explicado a como a metalinguagem (especificada pela metagramática) utilizada foi construída,
começando com o seu símbolo inicial.
No \typeref{simboloInicialDaMetalinguagem},
defini~=se que o programa é constituído de três grandes áreas,
que devem acontecer uma em sequencia da outra:
\begin{enumerate}
\item A produção ``preamble\_statements'' define características globais da gramática como um nome,
e um escopo que será atribuído a toda gramática.
\item A produção ``language\_construct\_rules'' define qual será o símbolo inicial da gramática.
Em comparação com linguagens de programação como ``C'',
ele pode ser considerado similar ao método ``main''.
\item A produção ``miscellaneous\_language\_rules'' permite a definição de diversos contextos\footnote{
Contexto refere~=se a um bloco de operadores ou
instruções como ``include'' e
``match''.
} com grupos de produções da gramática (\fullref{definicaoDeGramatica}),
que podem ser incluídos a partir do símbolo inicial da gramática definido no item ``language\_construct\_rules''.
\end{enumerate}%
\begin{lstlisting}[caption={Simbolo Inicial da Metagramática ``ObjectBeauty''},label={simboloInicialDaMetagramatica},style=yaml_style]
language_syntax: _NEWLINE? preamble_statements _NEWLINE?
                    language_construct_rules _NEWLINE?
                    ( miscellaneous_language_rules _NEWLINE? )*
                    _NEWLINE?

preamble_statements: ( (
                        target_language_name_statement
                        | master_scope_name_statement
                        | constant_definition
                    ) _NEWLINE )+

language_construct_rules: "contexts" ": " indentation_block
miscellaneous_language_rules: /[^:\n]+/ ": " indentation_block

target_language_name_statement: "name" ": " free_input_string
master_scope_name_statement: "scope" ": " free_input_string
\end{lstlisting}

Entre os \typeref{exemploDeGramaticaPawn1,exemploDeGramaticaPawn2,exemploDeGramaticaPawn3,exemploDeGramaticaPawn4},
encontra~=se pequenos exemplos de gramáticas escritas na metalinguagem ``ObjectBeauty'' brevemente apresentada.
No \typeref{exemploDeGramaticaPawn1},
encontra~=se a definição do símbolo inicial da gramática da linguagem sendo descrita (pela metagramática) e
pode~=se ver a metalinguagem sendo utilizada para definir uma linguagem chamada de ``Abstract Machine Language''.
Por padrão,
toda gramática ``ObjectBeauty'' precisa ter um contexto inicial ou
símbolo inicial chamado de ``contexts''.

O \typeref{exemploDeGramaticaPawn1} faz uso dos operadores ``include'' e
``match''.
O operador ``include'' serve incluir partes de outras gramáticas ou
mesmo gramáticas inteiras no contexto da gramática atual.
Entretanto,
a implementação de ``include'' realizada neste trabalho somente consegue realizar includes de contextos definidos no mesmo arquivo.

No exemplo \typeref{exemploDeGramaticaPawn1},
o operador ``include'' está incluindo contextos da gramática atual que serão definidas mais tarde neste mesmo arquivo.
Já o operador ``match'' utilizado no final serve para realizar propriamente o reconhecimento do programa de entrada e
atribuir a ele o escopo ``constant.boolean.language.pawn''.

Mais tarde,
as informações de escopo atribuídas por operadores como ``match'' e
``captures'' serão utilizadas pelo formatador de código~=fonte.
Com estas informações,
o formatador de código~=fonte será capaz de realizar as operações de formatação somente sobre os trechos de código que o usuário definir.
\begin{lstlisting}[caption={Exemplo de Gramática -- Símbolo Inicial},label={exemploDeGramaticaPawn1},style=yaml_style]
name: Abstract Machine Language
scope: source.sma

contexts: {
    include: parens
    include: numbers
    include: check_brackets

    match: (true|false) {
        scope: constant.boolean.language.pawn
    }
}
\end{lstlisting}

No \typeref{exemploDeGramaticaPawn2},
é introduzido o uso dos operadores ``push'',
``meta\_scope'' e
``pop''.
O operadores ``push'' e
``pop'' são responsáveis por manter uma pilha de contextos que permite aplicar um mesmo escopo por várias linhas utilizado o operador ``meta\_scope''.

A diferença entre o operador ``scope'' e
``meta\_scope'' é que o operador ``scope'' atribuí o escopo diretamente ao texto reconhecido pelo um operador ``match''.
Já o operador ``meta\_scope'' permite aplicar o escopo a todo o texto desde o primeiro até o último ``match'',
que desempilha com o operador ``pop'',
o contexto empilhado inicialmente com um ``push''.
\begin{lstlisting}[caption={Exemplo de Gramática -- Contextos},label={exemploDeGramaticaPawn2},style=yaml_style]
parens: {
    match: \( {
        scope: parens.begin.pawn
        push: {
            meta_scope: meta.group.pawn
            match: \) {
                scope: parens.end.pawn
                pop: true
            }
            include: numbers
        }
    }
}
\end{lstlisting}

No \typeref{exemploDeGramaticaPawn3},
é introduzido o uso do operador ``captures''.
O operador ``captures'' atribuí simultaneamente diversos escopos com uma única expressão regular.
Cada um dos números listados equivalem a um dos grupos de captura \cite{expressionGrammarsWithRegexLikeCaptures} da expressão regular utilizada no operador ``captures''.

O operador ``scope'' pode ser considerado um caso especial do operador ``captures'' quando utiliza~=se o grupo de captura 0,
que refere~=se a toda a expressão regular encontrada.
Por exemplo,
ao invés de utilizar o operador``scope:
algo'',
poderia~=se utilizar equivalentemente o operador ``captures:
0.
algo''.
\begin{lstlisting}[caption={Exemplo de Gramática -- Grupos de Captura},label={exemploDeGramaticaPawn3},style=yaml_style]
numbers: {
    match: '(\d+)(\.\{2\})(\d+)' {
        captures: {
            0: constant.numeric.pawn
            1: constant.numeric.int.pawn
            2: keyword.operator.switch-range.pawn
            3: constant.numeric.int.pawn
        }
    include: numeric
}
\end{lstlisting}

No \typeref{exemploDeGramaticaPawn4},
é mostrado mais alguns exemplos de uso do operador ``match'' classificando diversos tipos de numéricos (da linguagem sendo descrita pela gramática).
É importante notar que a ordem no qual os operadores como ``match'' aparecem é importante.
Ao realizar o reconhecido o programa de entrada utilizando esta gramática,
a Árvore de Sintaxe Abstrata será interpretada diversas vezes,
iniciando no símbolo inicial até chegar ao último símbolo da gramática.

O processo de interpretação irá reiniciar infinitamente até que nenhum texto seja mais consumido por nenhum dos operadores da gramática.
Assim,
uma vez que um trecho de código~=fonte já foi classificado,
ele será ignorado quando os próximos operadores forem aplicados,
evitando assim que o programa execute infinitamente.
\begin{lstlisting}[caption={Exemplo de Gramática -- Tipos numéricos},label={exemploDeGramaticaPawn4},style=yaml_style]
numeric: {
    match: ([-]?0x[\da-f]+) {
        scope: constant.numeric.hex.pawn
    }
    match: \b(\d+\.\d+)\b {
        scope: constant.numeric.float.pawn
    }
    match: \b(\d+)\b {
        scope: constant.numeric.int.pawn
    }
}
\end{lstlisting}

Por fim,
no \typeref{exemploDeGramaticaPawn5} é mostrado um exemplo não relacionado com formatação de código~=fonte.
A construção utilizada é comum para gramáticas que serão utilizadas para realizar a aplicação de cores em editores de texto \cite{vsCodeSyntaxHighlighthing}.
Com ela é possível colorir o código~=fonte como invalido no editor de texto,
uma vez que a inconsistência foi encontrada na linguagem sendo analisada.

Construções como a do \typeref{exemploDeGramaticaPawn5} funcionam usualmente quando elas são a última regra da gramática.
Uma vez que todas as regras que consomem o programa de entrada e
o classifica em escopos terminam seu trabalho,
não deveria existir mais nenhum texto ser reconhecido.
Caso exista,
ou a gramática não estava preparada para reconhecer todo o programa de entrada,
ou estes trechos de código são frutos de algum erro no programa de entrada.
\begin{lstlisting}[caption={Exemplo de Gramática -- Reconhecimento de Erros},label={exemploDeGramaticaPawn5},style=yaml_style]
check_brackets: {
    match: \) {
        scope: invalid.illegal.stray-bracket-end
    }
}
\end{lstlisting}

