

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{Formatador Desenvolvido}
\label{chapter:software_implementation}

Neste capítulo,
será explicado o funcionamento e
implementação de uma nova ferramenta de formatação.
A proposta desta nova ferramenta é permitir que usuários possam entrar com a gramática de qualquer linguagem,
por meio de uma metagramática\footnote{
Em Ciências da Computação,
quando algo é prefixado com ``meta'',
isso significa que ele refere~=se sobre o seu tipo ou
categoria \cite{theUseOfMetaRules}.
Por exemplo,
``metadata'' são dados sobre os dados.
} para então formatar o código~=fonte da linguagem descrita pela gramática.

Para desenvolver este trabalho foi utilizada a linguagem Python \cite{webDevelopmentWithDjango},
porque Python é uma linguagem simples de entender,
e permite que se escreva códigos com maior velocidade.
Em contra~=partida,
Python como sendo uma linguagem interpretada,
apresentada menor eficiência do que linguagens compiladas como C++.
Entretanto,
não é objetivo deste trabalho ter eficiência em tempo de execução.
Somente apresentar uma prototipação rápida de algoritmos para uma nova proposta de formatadores de código~=fonte.

Como Python é a linguagem de desenvolvimento deste trabalho,
escolheu~=se utilizar o Analisador Lark porque ele é um dos analisadores escritos inteiramente na linguagem Python.
Dentre os motivos para se utilizar o Analisador Lark,
pode~=se citar:
\begin{inparaenum}[1)]
\item implementa vários algoritmos de análise como LALR \cite{lalrDeRemer1982},
Earley \cite{JayEarley} e CYK \cite{hopcroftBook},
podendo reconhecer todas as gramáticas livre de contexto (\fullref{section:classesDeComplexidade});
\item não possui dependência de nenhuma outra biblioteca;
\item tanto Analisador Léxico quanto Analisador Sintática são totalmente integrados na construção da gramática no formato EBNF,
sem a necessidade de escrever nenhum código de programação (Python) adicional para fazer a Análise Léxica ou
Sintática;
\item é um projeto ativo de desenvolvimento \cite{larkCommitHistory},
constantemente recebendo correções de problemas (\textit{bugs},
\citeonline{findingRegressionsInProjects,debuggingIntoExamples}) e
adição de novos recursos (\textit{features}).
\end{inparaenum}%
No fim,
qualquer analisador que atenda estas características de flexibilidade pode ser utilizado.

Para este trabalho,
foi realizado um \textit{fork}\footnote{
Uma cópia do código~=fonte,
usualmente feita para realizar modificações no código~=fonte original.
}
\cite{overviewOfGitHubForks,mayTheForkBeWithYou,collaborationAmongGitHubUsers} do Analisador Lark,
renomeado o Analisador Lark \cite{larkContextualLexer} para ``pushdown''\footnote{%
O código~=fonte do \textit{fork} pode ser encontrado em \url{https://github.com/evandrocoan/pushdownparser}.
}.
Foi realizado um \textit{fork} do Analisador Lark para poder realizar pequenas alterações que facilitam o entendimento do funcionamento interno da ferramenta como adição de logs e
alterações nos algoritmos de navegação sobre as árvores geradas pela ferramenta.
Por isso,
em alguns lugares do código~=fonte é encontrado o nome ``pushdown'' ao invés de ``lark''.
Já em outros,
Lark continua sendo chamado de Lark para simplificar a retrocompatibilidade com a biblioteca original e
facilitar a realização da integração de novas atualizações vindos do repositório original do Analisador Lark para o \textit{fork} realizado.


\section{Visão Geral}
\label{section:softwareImplementationVisaoGeral}

Nesta seção,
será simplificadamente explicado como o algoritmo de formatação de código~=fonte deste trabalho funciona.
Para mais tarde nas próximas seções,
poder~=se entrar com mais detalhes sobre partes específicas do funcionamento,
sem se preocupar com detalhes básicos do funcionamento do formatador de código~=fonte.
No \typeref{code:exemploDeUmProgramaNaLinguagemJava},
é apresentado um programa completo e
funcional na linguagem Java,
que imprime ``\mintinline{text}|Hello World!|'' quando chamado sem nenhum argumento de linha de comando (CLI\footnote{
Do inglês,
\textit{Command Line Interface}.
},
\cite{commandLineInterface}).
Quando este mesmo programa Java é chamado com qualquer número de argumentos pela linha de comando,
ele imprime ``\mintinline{text}|Bye World!|'' na saída padrão.
\begin{code}
\caption{Exemplo de um programa na linguagem Java}
\label{code:exemploDeUmProgramaNaLinguagemJava}
\begin{minted}{java}
public class Main
{
    public static void main(String[] args)
    {
        if(args.length > 0)
        {
            System.out.println("Bye World!");
        }
        else
        {
            System.out.println("Hello World!");
        }
    }
}
\end{minted}
\end{code}

Tendo como o exemplo o código~=fonte em Java apresentado no \typeref{code:exemploDeUmProgramaNaLinguagemJava},
irá ser introduzido o algoritmo de formatação proposto de forma ``simples\footnote{
Com ``simples'',
refere~=se a simplificação da Metagramática e
Gerador de Formatadores utilizados nesta seção.
Para uma apresentação mais complexa,
confira a \fullref{section:metalinguagemGrammar}.
}'',
capaz que pegar algum elemento com uma estrutura como ``\mintinline{text}|if(args.length > 0)|'',
de um programa de entrada em uma linguagem qualquer e
realizar a sua formatação.
No \typeref{code:exemploMinimoDeMetagramatica},
inicia~=se com a apresentação de uma simplificação da metagramática utilizada neste trabalho.
A metagramática completa pode encontrada no \fullref{chapter:codigoDaMetagramatica}.
Ela segue as mesmas regras do Analisador Lark explicadas na \fullref{section:introducaoGramaticas}.
Uma melhor descrição do uso dos operadores ``\mintinline{text}|match|'' e
``\mintinline{text}|scope|'' definidos por essa metagramática,
podem ser encontrados mais tarde na \fullref{section:metalinguagemGrammar}.
\begin{code}
\caption{Exemplo mínimo da metagramática}
\label{code:exemploMinimoDeMetagramatica}
\begin{minted}{antlr}
language_syntax: _NEWLINE? ( match_statement | scope_name_statement )+ _NEWLINE?

match_statement: "match" ": " /.+/ _NEWLINE
scope_name_statement: "scope" ": " /.+/ _NEWLINE

CR: "/r"
LF: "/n"

_NEWLINE: ( /\r?\n[\t ]*/ )+
SPACES: /[\t \f]+/

%ignore SPACES
\end{minted}
\end{code}

No \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica},
é apresentado um exemplo de gramática válida definida pelas regras da metagramática apresentada no \typeref{code:exemploMinimoDeMetagramatica}.
Com a gramática do \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica} é possível reconhecer qualquer programa em que exista a estrura ``\mintinline{text}|if|'' com a seguinte forma ``\mintinline{text}|if(alguma coisa)|'' ou
somente ``\mintinline{text}|if()|''.
Uma vez que esses ``\mintinline{text}|if|\s'' sejam reconhecidos,
eles serão atribuídos ao escopo ``\mintinline{text}|if.statement.body|'',
que representa a região do código~=fonte onde encontra~=se o conteúdo do ``\mintinline{text}|if|''.
No exemplo do \typeref{code:exemploDeUmProgramaNaLinguagemJava} o escopo ``\mintinline{text}|if.statement.body|'' seria equivalente ao trecho de código~=fonte ``\mintinline{text}|args.length > 0|''.
\begin{lstlisting}[caption={Exemplo de gramática pelas regras da mínima metagramática},label={code:exemploDeGramaticaPelasRegrasDaMetagramatica},style=yaml_style]
match: (?<=if\().*(?=\))
scope: if.statement.body
\end{lstlisting}

Agora,
o quê pode ser feito com a gramática do \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica}?
Ela junto com a metagramática (\typeref{code:exemploMinimoDeMetagramatica}) devem ser entrada do Analisador Lark (\typeref{code:exemploDeUsoDaMetagramaticaEUmaGramatica}),
que irá devolver como resultado a Árvore Sintática (\fullref{section:compiladoresEtradutores}).
Então envia~=se a Árvore Sintática para o Analisador Semântico (\fullref{section:analisadoresSintaticos,section:analiseSemantica}) verificar se o programa (gramática) de entrada está semanticamente correta,
para então devolver como resultado a Árvore Sintática Abstrata\footnote{%
Do inglês (AST),
Abstract Syntax Tree.
}
(\fullref{section:desempenhoDoFormator,section:AnalisadorSemantico}).

A Árvore Sintática Abstrata representa a estrutura do programa de uma linguagem de programação \cite{improvingRefactoringSpeed,annotationAssistant}.
Ela é originalmente construída a partir da Árvore Sintática,
adicionado~=se informações adicionais sobre o significado programa e
removendo~=se elementos textuais como parenteses de procedência de operadores,
que podem ser representados pela estrutura da árvore\advisor{}{
(\typeref{code:Abstract_syntax_tree_for_Euclidean_algorithm,figure:Abstract_syntax_tree_for_Euclidean_algorithm})}.
Veja no \fullref{chapter:execucaoDeMainFormatter} um exemplo de uma Árvore Sintática e
uma Árvore Sintática Abstrata e
as compare.

No \typeref{code:exemploDeUsoDaMetagramaticaEUmaGramatica},
é apresentado um programa em Python que faz uso do Analisador Lark recebendo a metagramática e
gramática dos \typeref{code:exemploMinimoDeMetagramatica,code:exemploDeGramaticaPelasRegrasDaMetagramatica}.
Este exemplo de uso do Analisador Lark é igual ao já apresentado na \fullref{section:introducaoGramaticas},
com exceção da gramática (aqui representando um metagramática) e
o programa de entrada (aqui representando uma gramática).
\begin{code}
\caption{Exemplo de uso da metagramática e uma gramática}
\label{code:exemploDeUsoDaMetagramaticaEUmaGramatica}
\begin{minted}{python}
import pushdown

parser = pushdown.Lark(
    r"""
        language_syntax: _NEWLINE? ( match_statement | scope_name_statement )+ _NEWLINE?

        match_statement: "match" ": " /.+/ _NEWLINE
        scope_name_statement: "scope" ": " /.+/ _NEWLINE

        CR: "/r"
        LF: "/n"

        _NEWLINE: ( /\r?\n[\t ]*/ )+
        SPACES: /[\t \f]+/

        %ignore SPACES
    """,
    start='language_syntax',
    parser="lalr",
)

def parseit(program, filename):
    pushdown.tree.pydot__tree_to_png(
            parser.parse( program ), filename, "TB", debug=1, dpi=600 )

parseit(
    r"""
        match: (?<=if\().*(?=\))
        scope: if.statement.body
    """,
    "arvore_da_gramatica.png"
)
\end{minted}
\end{code}

Na \typeref{figure:arvoreSintaticaDaGramaticaDaMetagramatica} é apresentado a Árvore Sintática da gramática construída no programa Python de exemplo no \typeref{code:exemploDeUsoDaMetagramaticaEUmaGramatica}.
Com uma Árvore Sintática agora pode~=se programaticamente navegar pelos nós da árvore e
fazer uso do conteúdo dos nós em algum algoritmo específico.
\begin{figure}[H]
\caption{Árvore Sintática do \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica} criada pelo \typeref{code:exemploDeUsoDaMetagramaticaEUmaGramatica}}
\label{figure:arvoreSintaticaDaGramaticaDaMetagramatica}
\centering
\includegraphics[max width=1.0\textwidth]{arvore_da_gramatica.png}
\fonte{Própria}
\end{figure}

Assumindo que neste ponto,
o programa (a gramática de entrada) já está semanticamente validado (e a Árvore Sintática Abstrata já foi criada),
utiliza~=se a Árvore Sintática Abstrata da gramática da linguagem do código~=fonte (\typeref{code:exemploDeUmProgramaNaLinguagemJava}) para construir algum algoritmo ou
estratégia que possa ser utilizada para realizar a formatação do código~=fonte inicialmente apresentado no \typeref{code:exemploDeUmProgramaNaLinguagemJava}.

Seguindo a mesma estratégia utilizada por editores de texto em suas gramáticas (\fullref{section:sourceCodeHighlightersGrammars}),
realizar~=se o consumo do programa de entrada,
removendo dele as estruturas descritas pela gramática no \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica},
até que não se possa mais remover nenhum elemento novo,
terminando a reconhecimento do programa de entrada pela gramática utilizada.
\ifadvisor
\else
    \begin{code}
    \caption{Pseudo~=código do algoritmo Euclidiano \cite{analysisOfTheBinaryEuclideanAlgorithm}}
    \label{code:Abstract_syntax_tree_for_Euclidean_algorithm}
    \begin{minted}[xleftmargin=2em]{python}
    while b != 0
      if a > b
        a := a - b
      else
        b := b - a
    return a
    \end{minted}
    \end{code}

    \begin{figure}[!htb]
    \caption{Árvore Sintática Abstrata do \typeref{code:Abstract_syntax_tree_for_Euclidean_algorithm}}
    \label{figure:Abstract_syntax_tree_for_Euclidean_algorithm}
    \centering
    \includegraphics[width=1.0\textwidth]{Abstract_syntax_tree_for_Euclidean_algorithm.png}
    \fonte{\citeonline{abstractSyntaxTreeForEuclideanAlgorithm}}
    \end{figure}
\fi

Ao fazer o processo de reconhecimento do programa de entrada,
remove~=se os caracteres reconhecidos,
substituíndo eles por algum outro caractere de marcação (como ``\mintinline{text}|§|'',
\textit{símbolo de seção}\footnote{%
Do inglês,
section sign.
Também conhecido sinal de seção ou
sinal de corte.
}) para que não altere~=se o tamanho original do programa de entrada.
No \typeref{code:resultadoDoReconhecimentoDoProgramaJava} se pode ver como o programa original (\typeref{code:exemploDeUmProgramaNaLinguagemJava}) ficou ao final do processo de reconhecimento pela gramática no \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica}.
Essa foi uma estratégia utilizada para se possa no final do processo de formatação se possa facilmente reintroduzir no programa os novos trechos de código~=fonte que foram formatados.
\begin{code}
\caption{Resultado do reconhecimento do programa Java pela gramática}
\label{code:resultadoDoReconhecimentoDoProgramaJava}
\begin{minted}{java}
{
    public static void main(String[] args)
    {
        if(§§§§§§§§§§§§§§§)
        {
            System.out.println("Bye World!");
        }
        else
        {
            System.out.println("Hello World!");
        }
    }
}
\end{minted}
\end{code}

Como pode ser percebido,
a gramática de entrada no \typeref{code:exemploDeGramaticaPelasRegrasDaMetagramatica} não consome todo o programa de entrada (\typeref{code:exemploDeUmProgramaNaLinguagemJava}) no final do processo de reconhecimento (\typeref{code:resultadoDoReconhecimentoDoProgramaJava}).
Esta é uma característica importante dos formatadores de código deste trabalho.
Todo texto que não é consumido,
ou pela gramática de entrada,
ou pelo formatador de código ou
adição de cores,
será mantido intacto no final do processo de formatação ou
adição de cores.
Assim,
pode~=se ter o formatador de código já em funcionamento com gramática mais simples possível,
ou que já atenda as características mínimas que se deseja formatar ou
adicionar de cores.

Até este ponto,
ainda não se mostrou como a parte mais importante deste trabalho deve acontecer,
a formatação de código~=fonte.
A estratégia deste trabalho foi realizar a formatação de código~=fonte ao reconhecer o programa de entrada (\typeref{code:exemploDeUmProgramaNaLinguagemJava}) ``removendo'' os caracteres reconhecidos,
atribuíndo escopos (\fullref{section:sourceCodeHighlightersGrammars}) para cada um deles.
Uma vez que o trecho de código~=fonte ``removido'' possui um escopo atribuído,
um arquivo de configurações JSON como o \typeref{code:exemploDeConfiguracaoUtilizadaMinimaDoFormatadorDeCodigo} é consultado.
Caso exista uma ``configuração'' relacionada ao escopo recém~=reconhecido,
o trecho de código~=fonte é enviado para um formatador especializado de código~=fonte como o \typeref{code:exemploMinimoDeFormatadorDeCodigo}.
\begin{code}
\caption{Exemplo de configuração utilizada mínima do Formatador de Código}
\label{code:exemploDeConfiguracaoUtilizadaMinimaDoFormatadorDeCodigo}
\begin{minted}{python}
{
    "if.statement.body" : 2,
}
\end{minted}
\end{code}

O \typeref{code:exemploMinimoDeFormatadorDeCodigo} é uma especialização de uma classe maior responsável por navegar pela Árvore Sintática Abstrata das gramáticas das linguagens sendo formatadas.
A sua função ``\mintinline{text}|format_text|'' será chamada sempre que um escopo for encontrado pela metagramática.
Os valores dos parâmetros ``\mintinline{text}|code_to_format|'' e
``\mintinline{text}|setting_value|'' serão o nome do escopo encontrado pela gramática e
o valor da ``configuração'' correspondente encontrado no arquivo do \typeref{code:exemploDeConfiguracaoUtilizadaMinimaDoFormatadorDeCodigo}.
\begin{code}
\caption{Exemplo mínimo de Formatador de Código}
\label{code:exemploMinimoDeFormatadorDeCodigo}
\begin{minted}{python}
class SingleSpaceFormatter(AbstractFormatter):

    def format_text(self, code_to_format, setting_value):
        code_to_format = code_to_format.strip( " " )

        if setting_value:
            return " " * setting_value + code_to_format + " " * setting_value
        else:
            return code_to_format
\end{minted}
\end{code}

Por fim,
no \typeref{code:resultadoDoFormatadorDeCodigoParaJava} encontra~=se o resultado da formatador para comparação com o código~=fonte original (\typeref{code:exemploDeUmProgramaNaLinguagemJava}).
Como pode~=se perceber,
esta formatação realizada não foi muito significativa.
Entretanto,
está~=se trabalhando várias simplificações de implementação.
Para trabalhos futuros a este (\fullref{section:trabalhosFuturos}) é necessário criar maiores abstrações que permitam trabalhar com gramáticas de linguagens utilizado uma pilha de múltiplos contextos (\fullref{section:metalinguagemGrammar}),
com já feito em editores de texto (\fullref{section:sourceCodeHighlighters}) que serviram de inspiração a este trabalho.
\begin{code}
\caption{Resultado do Formatador de Código para Java}
\label{code:resultadoDoFormatadorDeCodigoParaJava}
\begin{minted}{java}
public class Main
{
    public static void main(String[] args)
    {
        if(  args.length > 0  )
        {
            System.out.println("Bye World!");
        }
        else
        {
            System.out.println("Hello World!");
        }
    }
}
\end{minted}
\end{code}

Nas próximas seções,
será explicado em pouco mais de detalhes o mesmo funcionamento recém~=apresentado brevemente.
Para maiores detalhes,
consulte a implementação e
exemplos de uso destes algoritmos nos \fullref{chapter:execucaoDeMainFormatter,chapter:codigoDoFormatador}.


\section{Introdução à Metagramática}
\label{section:GrammarsGrammar}

Na \fullref{section:introducaoGramaticas},
foi explicado o que são gramáticas.
Mas,
como gramáticas podem ser expressadas?
Isso depende de como seu analisador foi implementado\advisor{.}{,
sendo assim,
um detalhe de implementação.%
} \advisor{Analisadores}{Usualmente,
analisadores} seguem uma notação comum como EBNF \cite{teachingEbnf,antlrBookTerrentParr,larkGrammarReference,larkStyleCheat},
\advisor{que diverge de acordo com detalhes de implementação.
}{%
que não difere muito de um analisador para outro,
exceto por detalhes de implementação específicos de cada analisador.
}

Para realizar a implementação da nova ferramenta de formatação de código~=fonte,
foi realizado a construção de uma nova gramática de gramáticas de uma nova linguagem chamada de ``\mintinline{text}|ObjectBeauty|'',
uma metalinguagem \cite{compilersCompilerMetaLanguage}.
Na \typeref{figure:MyWorflowForLarkTraduzido},
é apresentado o fluxo de uso comum para um analisador.
Neste processo,
o desenvolvedor da linguagem escreve a gramática de especificação\advisor{}{
desta linguagem} que é entregue a algum analisador e
gera~=se um compilador para tal linguagem.
\begin{figure}[!htb]
\caption{Fluxo de uso comum de um analisador}
\label{figure:MyWorflowForLarkTraduzido}
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido.png}
\fonte{Própria, traduzido e adaptado de \citeonline{larkErrorRecovery}}
\nota{Própria,
traduzido e
adaptado,
são figuras desenvolvidas pelo autor,
mas inicialmente publicadas em outro local,
idioma e
com o conteúdo um pouco diferente.}
\end{figure}

Com algumas exceções,
compiladores são usualmente construídos utilizando um Compilador de Compiladores (ou Analisadores) \cite{compilersCompilerMetaLanguage}.
Utilizando um Analisador (\typeref{figure:MyWorflowForLarkTraduzido}),
é escrita a gramática da linguagem para qual se quer construir um compilador (\fullref{section:introducaoGramaticas}).
Após isso,
o Analisador gera o código~=fonte do analisador léxico e
sintático que aceita como entrada o programas da linguagem a ser compilada.
Então,
uma vez que os analisadores léxico e
sintático terminam seu trabalho,
tem~=se como resultado a Árvore Sintática do programa de entrada.

A Árvore Sintática é utilizada então para realizar a Análise Semântica e
geração de código,
completando~=se a construção de um compilador.
Para o processo de construção de um compilador,
não basta somente utilizar~=se de um Analisador,
mas também é necessário a escrita do código~=fonte do Analisador Semântico e
a geração de código binário executável (\fullref{section:compiladoresEtradutores}).
\advisor{Este trabalho faz um uso diferente}{Já este trabalho faz um uso fora do comum}.
Como mostrado na \typeref{figure:MyWorflowForLarkTraduzido2},
primeiro especifica~=se uma metalinguagem que será utilizada pelos usuários da nova ferramenta de Formatação de Código.
Para escrever esta nova metalinguagem,
utilizou~=se o Analisador Lark.
\begin{figure}[!htb]
\caption{Uso feito pela nova ferramenta de Formatação de Código}
\label{figure:MyWorflowForLarkTraduzido2}
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido2.png}
\fonte{Própria, traduzido e adaptado de \citeonline{larkErrorRecovery}}
\end{figure}

Diferente da \typeref{figure:MyWorflowForLarkTraduzido},
na \typeref{figure:MyWorflowForLarkTraduzido2} é adicionado mais uma etapa ao uso do Analisador.
Antes exista somente o fluxo de comunicação ``Analisador -> Compilador'',
agora o fluxo de informações segue como ``Gerador de Analisadores -> Gerador de Formadores -> Formatador''.
Neste novo fluxo,
``Gerador de Analisadores'' é o equivalente ao antigo ``Analisador'' e
``Formatador'' é o equivalente ao antigo ``Compilador''.
Entre eles,
foi adicionado o ``Gerador de Formadores'',
que é a criação de um novo tipo de Analisador de propósito específico,
para uma DSL\footnote{%
Do inglês,
\textit{Domain-Specific Language}.
} \cite{areThereDomainSpecificLanguages,yamlSpecificModelChecking},
uma linguagem de propósito específico (neste caso,
a linguagem de uma gramática,
uma metalinguagem).

Esta nova DSL trata~=se de uma especificação de gramáticas\footnote{
Assim como DSL\s,
estas gramáticas também são de para um propósito específico e
não poderiam ser utilizadas para descrever linguagens de propósito geral,
i.e.,
a criação de outras metagramáticas de propósito geral \cite{turingCompleteRegularLanguages}.
},
baseada nas gramáticas já utilizadas por editores de texto para adicionar cores aos códigos~=fontes exibidos em sua interface gráfica (\fullref{section:sourceCodeHighlightersGrammars}).
Diferente das gramáticas já utilizadas por editores de texto para adicionar cores,
é criada uma nova especificação de gramáticas para que no futuro ela posso conter recursos específicos para formatação de código~=fonte\footnote{
\advisor{Não}{A final,
não} é objetivo deste trabalho fazer a análise completa de programas,
pela sua sintaxe, semântica,
e gerar código~=binário executável (\fullref{section:compiladoresEtradutores}).
}
(e não adição de cores),
e para que ela não seja dependente de características de linguagens como YAML ou
XML utilizada pelos editores de texto para especificação de suas gramáticas (\fullref{section:sourceCodeHighlighters}).

Usualmente,
o Analisador Lark é utilizado somente como um gerador de compiladores (\typeref{figure:MyWorflowForLarkTraduzido}),
entretanto,
neste contexto Lark é utilizado como um ``Compilador de Compiladores'' (\typeref{figure:MyWorflowForLarkTraduzido2}).
A vantagem de utilizar outro analisador (Lark) para criar outro analisador (Gerador de Formatadores),
é que a gramática de especificação do Gerador de Formatadores pode usufruir da flexibilidade que a utilização que analisadores trazem na especificação das gramáticas de uma linguagem.
A facilidade em alterar a gramática da linguagem utilizada,
neste caso,
a gramática de gramáticas (ou metagramática).

Na \typeref{figure:ParsersPublicAudienceTraduzido},
pode~=se encontrar uma relação entre o funcionamento das diversas partes da ferramenta de Formatação de Código e
a audiência alvo.
Basicamente existem três grupos distintos de usuários ou
audiência:
\begin{inparaenum}[1)]
\item quem escreve ou
desenvolve a ferramenta de Formatação de Código proposta por este trabalho e
define as regras da metalinguagem (especificada pela sua metagramática,
i.e.,
a gramática de gramáticas);
\item quem escreve ou
desenvolve gramáticas de linguagens para serem formatadas de acordo com as regras da metalinguagem e;
\item quem escreve ou
desenvolve programas de computador e
deseja realizar a formatação de seus códigos~=fonte.
\end{inparaenum}%
\begin{figure}[!htb]
\caption{Relacionamentos entre os diferentes públicos deste projeto}
\label{figure:ParsersPublicAudienceTraduzido}
\centering
\includegraphics[width=1.0\textwidth]{ParsersPublicAudienceTraduzido.png}
\fonte{Própria, traduzido e adaptado de \citeonline{larkErrorRecovery}}
\end{figure}

Até este ponto,
já falou~=se de metagramática e
metalinguagem com a exceção dos metaprogramas \cite{tradeoffsInMetaprogramming}.
Nas \typeref{figure:MyWorflowForLarkTraduzido2,figure:ParsersPublicAudienceTraduzido},
por simplificação foram omitidos o relacionamento dos metaprogramas com a metagramática e
metalinguagem.
Metaprogramas fazem parte da entrada do metacompilador (\typeref{figure:MetacompilerMetagrammarMetaprogram}) junto com a metagramática para gerar um novo compilador (ou Formatador de Código).
Neste trabalho,
os metaprogramas serão as gramáticas que serão utilizadas pelos formatadores de código~=fonte.

Os metaprogramas (ou gramáticas) são entradas diretas do metacompilador,
o Analisador Lark na \typeref{figure:MyWorflowForLarkTraduzido2},
utilizado para analisar uma gramática LALR(1) (\fullref{chapter:codigoDaMetagramatica}).
Na \typeref{figure:ParsersPublicAudienceTraduzido},
não pode~=se ver diretamente que as gramáticas das linguagens serão os metaprogramas,
mas o quadro em azul mais à esquerda ligado por linhas pontilhadas explica~=se que os erros léxicos e
sintáticos nas gramáticas de entrada serão mostrados pelo Analisador Lark.
Isso acontece porque as gramáticas (ou metaprogramas) são entradas diretamente no Analisador Lark.

Na \typeref{figure:MetacompilerMetagrammarMetaprogram},
encontra~=se uma extensão da \typeref{figure:MyWorflowForLarkTraduzido2},
e pode~=se ver claramente as relações entre Metagramáticas,
Metacompiladores e Metaprogramas. Por simplificação,
mostra~=se o nó ``Árvore Sintática'' sem explicitamente falar sobre sua Análise Semântica e
propriamente a construção do Compilador (ou do Formatador de Código).
Vale lembrar que trata~=se de um Compilador de Analisadores de uma DSL,
e não um Compilador de Analisadores de propósito geral.
Isso significa que as gramáticas aceitas pelos analisadores gerados não são capazes de gerar analisadores de linguagens de propósito geral ou
específico.
\begin{figure}[!htb]
\caption{Relação entre Metagramáticas, Metacompiladores e Metaprogramas}
\label{figure:MetacompilerMetagrammarMetaprogram}
\centering
\includegraphics[width=1.0\textwidth]{MetacompilerMetagrammarMetaprogram.png}
\fonte{Própria, traduzido e adaptado de \citeonline{larkErrorRecovery}}
\end{figure}

Esta não é a primeira vez que uma metagramática com simplificações foi escrita.
Em trabalhos relacionados com esta implementação de metagramática (\fullref{section:sourceCodeHighlighters}),
foram realizadas as mesmas simplificações aqui apresentadas.
Existem algumas diferenças técnicas da metagramática deste trabalho com as dos recém~=apresentados.
Como por exemplo,
a implementação da metagramática realizada ainda não suporta a classificação do mesmo trecho de código~=fonte por múltiplos tipos de escopo \cite{vsCodeSyntaxHighlighthing}.

Foi escolhida a criação de uma nova metagramática porque as implementações de metagramáticas já existentes como \citeonline{rustSublimeTextSyntaxSyntec,vsCodeSyntaxHighlighthing}:
\begin{inparaenum}[1)]
\item não utilizam explicitamente nenhum analisador,
realizando a programação das produções da gramática diretamente no código~=fonte (\fullref{section:gramaticasVersusLinguagens});
\item não são capazes de reconhecer todas as características de todas as linguagens de programação (devido a optimizações para maior desempenho);
\item não possuem sintaxe própria,
i.e.,
utilizam~=se de outras linguagens como YAML,
XML e JSON\footnote{%
Do inglês,
\textit{JavaScript Object Notation}.
} \cite{foundationsOfJSONSchema} para fazer a especificação da metagramática.
\end{inparaenum}%
Fazendo a especificação de uma nova metagramática,
é possível adaptar~=se a especificação da sintaxe das gramáticas de acordo com as necessidades específicas sem ter que depender de características de outras linguagens como YAML,
XML ou
JSON.

Na \typeref{figure:MetacompilerMetagrammarMetaprogram},
percebe~=se que os Metaprogramas (ou gramáticas) são entradas diretas dos Metacompilador,
e não do Formatador de Código como mostrado nas figuras anteriores (\typeref{figure:MyWorflowForLarkTraduzido,figure:MyWorflowForLarkTraduzido2,figure:ParsersPublicAudienceTraduzido}).
Ambas as figuras estão corretas,
entretanto,
a \typeref{figure:MetacompilerMetagrammarMetaprogram} é uma versão mais resumida de como o processo de análise léxica e
sintática acontece.
Analisadores sempre precisam como entrada ter uma gramática e
a palavra de uma dada linguagem (que pode ou
não ser aceita pelo analisador).

Como já explicado no início desta seção (\fullref{section:GrammarsGrammar}),
a ligação direta entre a gramática e
a palavra da linguagem não precisa acontecer diretamente com o analisador da \typeref{figure:MetacompilerMetagrammarMetaprogram}.
Caso o analisador suporte,
ao contrário de pedir para que o analisador gere o código~=fonte de um Analisador Léxico e
Sintático (e funcione como um Compilador de Compiladores),
ele pode ser utilizado diretamente recebendo como entrada a gramática da linguagem e
uma palavra para análise.
Retornando uma Árvore Sintática como resultado do processo ou
erro de análise caso a palavra de entrada não pertença a linguagem.

A existência do processo de receber somente como entrada a gramática de uma linguagem e
gerar código~=fonte de um Analisador Léxico e
Sintático,
capaz de receber um programa de entrada e
gerar uma Árvore Sintática,
é o que caracteriza um ``Analisador'' como um ``Compilador de Compiladores''.
Quando um ``Analisador'' não é capaz de gerar código~=fonte de um Analisador Léxico e
Sintático somente a partir de uma gramática de entrada,
ele não é um ``Compilador de Compiladores''.
Trata~=se somente de um ``Analisador'',
que então precisa receber como entrada diretamente a gramática e
a palavra da linguagem a ser analisada\footnote{
A título de curiosidade,
o Analisador Lark deste trabalho foi utilizado como um Analisador,
entretanto Lark é capaz de funcionar tanto como um Analisador quanto como um ``Compilador de Compiladores'' \cite{antlrBookTerrentParr}.
}.
Para então devolver como resultado a Árvore Sintática do programa de entrada ou
um erro de análise,
caso programa de entrada não pertença a linguagem da gramática.


\section{Especificação da Metalinguagem}
\label{section:metalinguagemGrammar}

Como já explicado na seção anterior (\fullref{section:GrammarsGrammar}),
uma metagramática é gramática de gramáticas e
foi utilizado o Analisador Lark como um ``Metacompilador'' ou
``Compilador de Compiladores''.
Nesta seção será discutido como a metalinguagem (especificada pela metagramática) utilizada foi construída,
começando com o seu símbolo inicial.
No \typeref{code:simboloInicialDaMetagramatica},
a metagramática define que o programa é constituído de três grandes áreas,
que devem acontecer uma em sequência da outra:
\begin{enumerate}
\item A produção ``\mintinline{text}|preamble_statements|'' define características globais da gramática como um nome,
e um escopo que será atribuído a toda gramática;
\item A produção ``\mintinline{text}|language_construct_rules|'' define qual será o símbolo inicial da gramática.
Em comparação com linguagens de programação como ``\mintinline{text}|C|'',
ele pode ser considerado similar ao método ``\mintinline{text}|main|'';
\item A produção ``\mintinline{text}|miscellaneous_language_rules|'' permite a definição de diversos contextos\footnote{
Na regras da gramática,
contexto refere~=se a um bloco de operadores ou
conjunto de instruções como ``\mintinline{text}|include|'' e
``\mintinline{text}|match|''.
} com grupos de produções da gramática (\fullref{item:definicaoDeGramatica}),
que podem ser incluídos a partir do símbolo inicial da gramática definido no item ``\mintinline{text}|language_construct_rules|''.
\end{enumerate}%
\begin{code}
\caption[Símbolo Inicial da Metagramática ``ObjectBeauty'']{Símbolo Inicial da Metagramática ``\mintinline{text}|ObjectBeauty|'' (\typeref{chapter:codigoDaMetagramatica})}
\label{code:simboloInicialDaMetagramatica}
\begin{minted}{antlr}
language_syntax: _NEWLINE? preamble_statements _NEWLINE?
                    language_construct_rules _NEWLINE?
                    ( miscellaneous_language_rules _NEWLINE? )* _NEWLINE?

preamble_statements: ( (
                        target_language_name_statement
                        | master_scope_name_statement
                        | constant_definition
                    ) _NEWLINE )+

language_construct_rules: "contexts" ": " indentation_block
miscellaneous_language_rules: /[^:\n]+/ ": " indentation_block

target_language_name_statement: "name" ": " free_input_string
master_scope_name_statement: "scope" ": " free_input_string

indentation_block: enter_block _NEWLINE ( statements_list _NEWLINE )+ leave_block
statements_list: match_statement | include_statement | push_statement
                | pop_statement| constant_definition | scope_name_statement
                | capturing_block | meta_scope_statement

enter_block: OPEN_BRACE
leave_block: CLOSE_BRACE
OPEN_BRACE: "{"
CLOSE_BRACE: "}"

...
\end{minted}
\end{code}

Entre os \typeref{code:exemploDeGramaticaPawn1,code:exemploDeGramaticaPawn2,code:exemploDeGramaticaPawn3,code:exemploDeGramaticaPawn4},
encontram~=se pequenos exemplos de gramáticas escritas na metalinguagem ``\mintinline{text}|ObjectBeauty|'' brevemente apresentada.
No \typeref{code:exemploDeGramaticaPawn1},
encontra~=se a definição do símbolo inicial da gramática da linguagem sendo descrita (pela metagramática) e
pode~=se ver a metalinguagem sendo utilizada para definir uma linguagem chamada de ``\mintinline{text}|Abstract Machine Language|''.
Por padrão,
toda gramática ``\mintinline{text}|ObjectBeauty|'' precisa ter um contexto inicial ou
símbolo inicial chamado de ``\mintinline{text}|contexts|''.

Como já inicialmente apresentado na \fullref{section:sourceCodeHighlightersGrammars},
na \typeref{figure:TexMateScopes} é mostrado na primeira linha o trecho de código~=fonte ``\mintinline{text}|function f1 () {|'' e
nas demais linhas são apresentados as diversas classificações de escopo aplicados a cada um dos trechos do código~=fonte de amostra.
Por exemplo,
a palavra ``\mintinline{text}|function|'' possui simultaneamente a pilha de escopos:
\begin{inparaenum}[1)]
\item ``\mintinline{text}|source.js|'';
\item ``\mintinline{text}|meta.function.js|'' e;
\item ``\mintinline{text}|storage.type.function.js|''.
\end{inparaenum}%
Enquanto o caractere ``\mintinline{text}|{|'' (chave de abertura de bloco) possui simultaneamente a pilha de escopos:
\begin{inparaenum}[1)]
\item ``\mintinline{text}|source.js|'';
\item ``\mintinline{text}|meta.function.js|'';
\item ``\mintinline{text}|meta.block.js|'' e;
\item ``\mintinline{text}|punctuation.definition.block.js|''.
\end{inparaenum}%
\begin{figure}[!htb]
\caption{Exemplo de classificação de código~=fonte com múltiplos escopos}
\label{figure:TexMateScopes}
\centering
\includegraphics[width=1.0\textwidth]{TexMateScopes.png}
\fonte{\citeonline{vsCodeSyntaxHighlighthing}}
\end{figure}

Os nomes utilizados na \typeref{figure:TexMateScopes},
podem ser qualquer texto que usuário especificador daquela gramática atribuiu.
Entretanto,
pode~=se perceber que o nome dos escopos recém apresentados parecem seguir um padrão.
Por conversão,
desenvolvedores de gramáticas para os editores de texto como \citeonline{sublimeTextSyntax,vsCodeSyntaxHighlighthing},
seguem uma conversão de nomes para que as utilizações dos escopos gerados pelas gramáticas sejam compatíveis entre si.

Fazendo o uso de uma conversão para nomes de escopos,
as gramáticas ficam compatíveis com um maior número de arquivos de temas (ou configurações de cores),
onde são especificados os nomes dos escopos serão utilizados para especificar as cores a serem utilizadas pelo editor de texto (\fullref{section:sourceCodeHighlightersGrammars}).
\advisor{}{Para mais informações sobre a utilização de arquivos de temas em editores de texto veja \citeonline{sublimeTextScopeNaming,vsCodeSyntaxHighlighthing}.}

O \typeref{code:exemploDeGramaticaPawn1},
faz uso dos operadores ``\mintinline{text}|include|'' e
``\mintinline{text}|match|''.
O operador ``\mintinline{text}|include|'' serve para incluir partes de outras gramáticas ou
mesmo gramáticas inteiras no contexto da gramática atual.
Entretanto,
a implementação de ``\mintinline{text}|include|'' realizada neste trabalho somente consegue realizar includes de contextos definidos no mesmo arquivo.
No exemplo do \typeref{code:exemploDeGramaticaPawn1},
o operador ``\mintinline{text}|include|'' está incluindo contextos (\fullref{section:metalinguagemGrammar}) da gramática atual que serão definidos mais tarde neste mesmo arquivo.
Já o operador ``\mintinline{text}|match|'' utilizado no final serve para realizar propriamente o reconhecimento do programa de entrada e
atribuir a ele o escopo ``\mintinline{text}|constant.boolean.language.pawn|''.

Mais tarde,
as informações de escopo atribuídas por operadores como ``\mintinline{text}|match|'' e
``\mintinline{text}|captures|'' serão utilizadas pelo formatador de código~=fonte.
Com estas informações,
o Formatador de Código será capaz de realizar as operações de formatação somente sobre os trechos de código~=fonte que o usuário definir.
Realizando assim,
a formatação seletiva de código~=fonte,
contrário da formatação total de código~=fonte como acontece nos demais trabalhos (\fullref{section:desempenhoDoFormator}).
\begin{lstlisting}[caption={Exemplo de Gramática, Símbolo Inicial},label={code:exemploDeGramaticaPawn1},style=yaml_style]
name: Abstract Machine Language
scope: source.sma

contexts: {
    include: parens
    include: numbers
    include: check_brackets

    match: (true|false) {
        scope: constant.boolean.language.pawn
    }
}
\end{lstlisting}

No \typeref{code:exemploDeGramaticaPawn2},
é introduzido o uso dos operadores ``\mintinline{text}|push|'',
``\mintinline{text}|meta_scope|'' e
``\mintinline{text}|pop|''.
O operadores ``\mintinline{text}|push|'' e
``\mintinline{text}|pop|'' são responsáveis por manter uma pilha de contextos que permite aplicar um mesmo escopo por várias linhas utilizado o operador ``\mintinline{text}|meta_scope|''.
A diferença entre o operador ``\mintinline{text}|scope|'' e
``\mintinline{text}|meta_scope|'' é que o operador ``\mintinline{text}|scope|'' atribuí o escopo diretamente ao texto reconhecido pelo operador ``\mintinline{text}|match|''.
Já o operador ``\mintinline{text}|meta_scope|'' permite aplicar o escopo a todo o texto desde o primeiro até o último ``\mintinline{text}|match|'',
que desempilha com o operador ``\mintinline{text}|pop|'',
o contexto empilhado inicialmente com o operador ``\mintinline{text}|push|''.
\begin{lstlisting}[caption={Exemplo de Gramática, Contextos},label={code:exemploDeGramaticaPawn2},style=yaml_style]
parens: {
    match: \( {
        scope: parens.begin.pawn
        push: {
            meta_scope: meta.group.pawn
            match: \) {
                scope: parens.end.pawn
                pop: true
            }
            include: numbers
        }
    }
}
\end{lstlisting}

No \typeref{code:exemploDeGramaticaPawn3},
é introduzido o uso do operador ``\mintinline{text}|captures|''.
O operador ``\mintinline{text}|captures|'' atribuí simultaneamente diversos escopos com uma única expressão regular.
Cada um dos números listados equivalem a um dos grupos de captura da expressão regular utilizada no operador ``\mintinline{text}|captures|''.
O operador ``\mintinline{text}|scope|'' pode ser considerado um caso especial do operador ``\mintinline{text}|captures|'' quando utiliza~=se o Grupo de Captura 0.

Motores de expressões regulares geralmente suportam um recurso chamado de Grupos de Captura \cite{expressionGrammarsWithRegexLikeCaptures}.
Por exemplo,
a expressão regular ``\mintinline{text}|foo(bar)zoo(car)|'' possuí 3 grupos de captura quando analisado o texto de entrada ``\mintinline{text}|foobarzoocar|'':
\begin{inparaenum}[1)]\setcounter{enumi}{-1}
\item foobarzoocar;
\item bar;
\item car;
\end{inparaenum}%
onde o grupo de captura 0 refere~=se a toda a expressão regular encontrada.
Portanto,
ao invés de utilizar~=se o operador ``\mintinline{text}|scope|:
constant.numeric.pawn'',
poderia~=se utilizar equivalentemente o operador ``\mintinline{text}|captures|:
0.
constant.numeric.pawn''.
\begin{lstlisting}[caption={Exemplo de Gramática, Grupos de Captura},label={code:exemploDeGramaticaPawn3},style=yaml_style]
numbers: {
    match: '(\d+)(\.\{2\})(\d+)' {
        captures: {
            0: constant.numeric.pawn
            1: constant.numeric.int.pawn
            2: keyword.operator.switch-range.pawn
            3: constant.numeric.int.pawn
        }
    include: numeric
}
\end{lstlisting}

No \typeref{code:exemploDeGramaticaPawn4},
são apresentados mais alguns exemplos de uso do operador ``\mintinline{text}|match|'' classificando diversos tipos de numéricos (da linguagem sendo descrita pela gramática).
É importante notar que a ordem na qual os operadores como ``\mintinline{text}|match|'' aparecem é importante.
Ao realizar o reconhecido o programa de entrada utilizando esta gramática,
a Árvore Sintática Abstrata \cite{ahoCompilerDragonBook} será interpretada diversas vezes,
partindo do símbolo inicial até chegar ao último símbolo da gramática.

O processo de interpretação irá reiniciar indefinidamente até que nenhum texto seja mais consumido por nenhum dos operadores da gramática.
Assim,
uma vez que um trecho de código~=fonte já foi classificado,
ele será ignorado quando os próximos operadores forem aplicados,
evitando assim que o programa execute infinitamente.
\begin{lstlisting}[caption={Exemplo de Gramática, Tipos numéricos},label={code:exemploDeGramaticaPawn4},style=yaml_style]
numeric: {
    match: ([-]?0x[\da-f]+) {
        scope: constant.numeric.hex.pawn
    }
    match: \b(\d+\.\d+)\b {
        scope: constant.numeric.float.pawn
    }
    match: \b(\d+)\b {
        scope: constant.numeric.int.pawn
    }
}
\end{lstlisting}

Por fim,
no \typeref{code:exemploDeGramaticaPawn5},
é apresentado um exemplo não relacionado com formatação de código~=fonte.
A construção utilizada é comum para gramáticas que serão utilizadas para realizar a aplicação de cores em editores de texto \cite{vsCodeSyntaxHighlighthing}.
Com ela é possível colorir o código~=fonte,
destacando~=o como inválido no editor de texto,
uma vez que uma inconsistência sintática foi encontrada na linguagem sendo analisada.

Construções como a do \typeref{code:exemploDeGramaticaPawn5},
funcionam usualmente quando elas são a última regra da gramática.
Uma vez que todas as regras que consomem o programa de entrada e
o classifica em escopos terminam seu trabalho,
não deveria existir mais nenhum texto ser reconhecido.
Caso exista,
ou a gramática não estava preparada para reconhecer todo o programa de entrada,
ou estes trechos de código~=fonte são frutos de algum erro no programa de entrada.
\begin{lstlisting}[caption={Exemplo de Gramática, Reconhecimento de Erros},label={code:exemploDeGramaticaPawn5},style=yaml_style]
check_brackets: {
    match: \) {
        scope: invalid.illegal.stray-bracket-end
    }
}
\end{lstlisting}


\section{Analisador Semântico}
\label{section:AnalisadorSemantico}

Depois que um metaprograma da metalinguagem apresentada na seção anterior (\fullref{section:metalinguagemGrammar}) é reconhecido pelo Analisador Lark,
o Analisador Lark entrega a Árvore Sintática da gramática da linguagem sendo descrita pelo metaprograma (\typeref{figure:MetacompilerMetagrammarMetaprogram}).
Todas as verificações de corretude da sintaxe da gramática são executadas pelo Analisador Lark,
com base na metagramática da metalinguagem.
Portanto,
somente resta ser implementado o Analisador Semântico para verificar se a linguagem descrita respeita as regras semânticas da metalinguagem explicadas na seção anterior (\fullref{section:metalinguagemGrammar}).

Um Diagrama de Classes é apresentado na \typeref{figure:CodeFormatterClassDiagram}.
Nele,
o Analisador Semântico que deriva de ``\mintinline{text}|Transformer|'' recebe como entrada a Árvore Sintática do programa de entrada,
e uma vez que o Analisador Semântico termina seu trabalho,
ele devolve Árvore Sintática Abstrata completa.
Então,
utilizando a Árvore Sintática Abstrata,
``\mintinline{text}|Backend|'' que deriva de ``\mintinline{text}|Interpreter|'',
realiza a formatação de código~=fonte recebendo um programa de entrada e
as configurações do formatador (\typeref{figure:ParsersPublicAudienceTraduzido,figure:MetacompilerMetagrammarMetaprogram}).
\begin{figure}[!htb]
\caption{Diagrama das principais classes}
\label{figure:CodeFormatterClassDiagram}
\centering
\includegraphics[width=1.0\textwidth]{CodeFormatterClassDiagram.png}
\fonte{Própria}
\end{figure}

No \typeref{code:semanticAnalizerConstructor},
pode~=se ver o construtor do Analisador Semântico.
Pode~=se notar que seu construtor não recebe como parâmetro a Árvore Sintática.
Entretanto,
a ela não é passada pelo construtor mas sim por um método chamado ``\mintinline{text}|transform(tree)|''.
Esta é uma característica do Analisador Lark utilizado.
A função ``\mintinline{text}|transform(tree)|'' do Analisador Lark simplesmente inicia a análise do programa visitando todos os nós da Árvore Sintática,
partindo das folhas até chegar na raíz (\fullref{section:compiladoresEtradutores}).
\begin{code}
\caption[Construtor do Analisador Semântico]{Construtor do Analisador Semântico (\typeref{chapter:codigoDoAnalisadorSemantico})}
\label{code:semanticAnalizerConstructor}
\begin{minted}{python}
class TreeTransformer(pushdown.Transformer):
    """
        Transforms the Derivation Tree nodes into meaningful string representations,
        allowing simple recursive parsing and conversion to Abstract Syntax Tree.
    """

    def __init__(self):
        ## Saves all the semantic errors detected so far
        self.errors = []

        ## Saves all warnings noted so far
        self.warnings = []

        ## Whether the mandatory/obligatory global scope name statement was declared
        self.is_master_scope_name_set = False

        ## Whether the mandatory/obligatory global language name statement was declared
        self.is_target_language_name_set = False

        ## Can only be one scope called `contexts`
        self.has_called_language_construct_rules = False

        ## Pending constants declarations
        self.constant_usages = {}

        ## Pending constants usages
        self.constant_definitions = {}

        ## A list of miscellaneous_language_rules include contexts defined for duplication checking
        self.defined_includes = {}

        ## A list of required includes to check for missing includes
        self.required_includes = {}

        ## A list of regular expressions used on match statements,
        ## for validation when the constants definitions are completely know
        self.pending_match_statements = []

        ## Responsible for calculating all open and close commands scoping
        self.open_blocks = {}
        self.indentation_level = 0
        self.indentation_blocks = []
\end{minted}
\end{code}

A visita dos nós da Árvore Sintática pela função ``\mintinline{text}|transform(tree)|'' acontece simplesmente chamando os métodos que a classe ``\mintinline{text}|TreeTransformer|'' (\typeref{code:semanticAnalizerConstructor}) define e
que possuem os mesmos nomes que os símbolos não~=terminais definidos pela metagramática.
Então,
cada nó ou
função deve devolver qual será o novo nó que irá o substituir na Árvore Sintática.
Assim,
no final do processo,
um a um,
cada nó da Árvore Sintática será convertido para um nó da Árvore Sintática Abstrata.

Um jeito fácil de excluir um nó da Árvore Sintática é simplesmente definir uma função com o nome de seu não~=terminal que devolve ``\mintinline{text}|null|''.
Por exemplo,
o trecho da metagramática apresentado no \typeref{code:simboloInicialDaMetagramatica},
possui alguns símbolos não~=terminais como ``\mintinline{text}|preamble_statements|'' e
``\mintinline{text}|language_construct_rules|''. Então,
para estes dados símbolos,
serão chamados os métodos da classe ``\mintinline{text}|TreeTransformer|'' que possuem os nomes ``\mintinline{text}|preamble_statements|'' e
``\mintinline{text}|language_construct_rules|''.

Caso não existam os métodos ``\mintinline{text}|preamble_statements|'' e
``\mintinline{text}|language_construct_rules|'' na classe ``\mintinline{text}|TreeTransformer|'',
os nós ``\mintinline{text}|preamble_statements|'' e
``\mintinline{text}|language_construct_rules|'' da Árvore Sintática não serão visitados e
``poderão'' ser excluídos da Análise Semântica (mas não da Árvore Sintática Abstrata).
Nós não analisados pela classe ``\mintinline{text}|TreeTransformer|'' não serão excluídos da Árvore Sintática Abstrata,
eles serão mantidos intactos,
a não ser que algum outro nó os altere diretamente na Árvore Sintática.

Mesmo que na classe ``\mintinline{text}|TreeTransformer|'' não existam definidos os métodos ``\mintinline{text}|preamble_statements|'' e
``\mintinline{text}|language_construct_rules|'',
eles também podem ser visitados diretamente a partir de algum nó pai ou
até de algum de seus filhos.
Inclusive,
esta foi uma das alterações realizadas no \textit{fork} ``pushdown'' do Analisador Lark.
Por padrão,
ao navegar pela árvore,
o Analisador Lark somente passa como parâmetro da função (de ``\mintinline{text}|TreeTransformer|'') o nó correspondente ao método atualmente sendo chamado e
uma lista de nós~=filhos.
Entretanto,
``pushdown'' agora também passa um terceiro parâmetro que é uma referência para o nó raíz da árvore e
mantém a variável ``\mintinline{text}|parent|'' (que aponta para o pai do nó atual da árvore),
acessível como um atributo da classe ``\mintinline{text}|TreeTransformer|''.


\section{Formatador de Código}
\label{section:desempenhoDoFormator}

O Formatador de Código não é composto somente por uma parte única e
altamente acoplada.
Mas pelo contrário,
um conjunto de partes altamente coesas e
completamente independentes onde cada uma dessas partes recebe a Árvore Sintática Abstrata,
para então realizar a formatação do programa de entrada junto com as configurações que esta parte aceita.

Continuamente chamar diversos algoritmos independentes acarreta uma perda de desempenho em comparação com os formatadores de código~=fonte apresentados no \fullref{chapter:source_code_beautifiers}.
Estes formatadores tem como principal características realizar a formatação de código~=fonte em uma única passada,
i.e.,
a Árvore Sintática de programa de entrada é completamente reconstruída,
para então ser serializada novamente em texto de acordo com as configurações de formatador.

Este trabalho permite que o usuário entre com a gramática da linguagem a ser formatada,
diferente de outros trabalhos onde a gramática já é incluída ao código~=fonte do formatador.
Formadores de código~=fonte como apresentados na \fullref{chapter:source_code_beautifiers} são construídos programando~=se as produções da gramática diretamente no código~=fonte do formatador (Descendentes Recursivos,
reveja a \fullref{section:gramaticasVersusLinguagens}).

Ao não permitir~=se que o usuário possa entrar com a gramática do programa,
restringe~=se o formatador a somente funcionar com as gramáticas que foram programadas dentro do seu código~=fonte.
Uma vez que o usuário da ferramenta precisa programar o formatador de código para ter suporte a sua linguagem,
isso dificulta a adição do suporte de novas linguagens ao formatador,
pois precisa~=se programar as suas gramáticas diretamente dentro do código~=fonte do formatador.

Um formatador pode ter pré~=configurado algumas gramáticas de algumas linguagens de programação,
como acontece com o formatador Uncrustify (\fullref{section:trabalhosRelacionados}).
O que Uncrustify consegue fazer é formatar um conjunto de linguagens onde sua gramática é parecida na maior parte dos aspectos.
Caso fosse necessário expandir o formatador Uncrustify a suportar linguagens pouco relacionadas com as linguagens já existentes,
o código~=fonte da implementação atual do formatador seria muito mais complexa.
\advisor{}{Imagine como seria escrever uma única gramática que represente todas as linguagens de programação?}

No \typeref{code:construtorDoFormatador},
pode ser encontrado o construtor do formatador de código~=fonte.
Comparando~=o com o construtor do Analisador Semântico (\typeref{code:semanticAnalizerConstructor}),
pode~=se notar algumas diferenças.
Em ambos os casos,
o processo todo se completará ao percorrer toda a árvore.
No caso do Analisador Semântico,
a Árvore Sintática,
e no caso do Formatador de Código,
a Árvore Sintática Abstrata.
\begin{code}
\caption[Construtor do Formatador]{Construtor do Formatador (\typeref{chapter:codigoDoFormatador})}
\label{code:construtorDoFormatador}
\begin{minted}{python}
class Backend(pushdown.Interpreter):

    def __init__(self, formatter, tree, program, settings):
        super().__init__()
        self.tree = tree
        self.program = formatter( program, settings )

        ## A list of lists, where each list saves all the matches performed by
        ## the last match_statement on scope_name_statement
        self.last_match_stack = []

        ## This is set to False every push statement, and set to True, after
        ## every match statement. This way we can know whether there is a match
        ## statement after a push statement.
        self.is_there_push_after_match = False
        self.is_there_scope_after_match = False

        self.cached_includes = {}
        self.cache_includes( tree )

        self.visit( tree )
        log( 4, "Tree: \n%s", tree.pretty( debug=0 ) )

    def target_language_name_statement(self, tree):
        target_language_name = tree.children[0]

        self.target_language_name = target_language_name
        log( 4, "target_language_name: %s", target_language_name )

    def master_scope_name_statement(self, tree):
        master_scope_name = tree.children[0]

        self.master_scope_name = master_scope_name
        log( 4, "master_scope_name: %s", master_scope_name )

    def include_statement(self, tree):
        include_statement = str( tree.children[0] )

        log( 4, "include_statement: %s", include_statement )
        self.visit_children( self.cached_includes[include_statement] )
\end{minted}
\end{code}

Diferentemente do Analisador Semântico,
o Formatador de Código faz herança do tipo ``\mintinline{text}|Interpreter|'' em vez de ``\mintinline{text}|Transformer|'' (\typeref{figure:CodeFormatterClassDiagram}).
A diferença é simples,
``\mintinline{text}|Interpreter|'' visita a árvore partindo das folhas até chegar na raíz visitando todos os nós filhos (\fullref{section:compiladoresEtradutores}),
já ``\mintinline{text}|Transformer|'' visita a árvore partindo da raíz até chegar nos nós pais,
i.e.,
ele não visita os nós~=filhos automaticamente como ``\mintinline{text}|Transformer|'' faz.
Foi escolhido utilizar ``\mintinline{text}|Interpreter|'' ao contrário de ``\mintinline{text}|Transformer|'' para fazer a interpretação da gramática,
porque ele segue naturalmente o algoritmo de consumo do programa que gramáticas utilizadas para adição de cores já seguem (\fullref{section:sourceCodeHighlightersGrammars}).
Enquanto o tipo ``\mintinline{text}|Transformer|'' segue melhor o fluxo para transformação e
criação de uma nova árvore,
neste caso,
a Árvore Sintática Abstrata.

``\mintinline{text}|Interpreter|'' diferente de ``\mintinline{text}|Transformer|'',
recebe diretamente no construtor qual será a árvore que ele irá navegar sobre.
Nos demais aspectos,
``\mintinline{text}|Interpreter|'' funciona igual ao ``\mintinline{text}|Transformer|'',
exceto no ponto onde ``\mintinline{text}|Transformer|'' cria uma nova árvore no final do processo,
enquanto ``\mintinline{text}|Interpreter|'' não cria árvore alguma.
O parâmetro chamado ``\mintinline{text}|program|'',
que o construtor de ``\mintinline{text}|Transformer|'' recebe,
é o programa a ser formatado pelo formatador.
No final do processo,
``\mintinline{text}|Interpreter|'' terá em sua variável ``\mintinline{text}|self.program|'' o novo programa completamente formatado.

Enquanto ``\mintinline{text}|Interpreter|'' é responsável por somente ``passear'' pela Árvore Sintática Abstrata,
a classe ``\mintinline{text}|AbstractFormatter|'' (\typeref{code:construtorDeParsedProgram}) é responsável por realmente fazer a formatação de código~=fonte de acordo com a instruções vindas da Árvore Sintática Abstrata.
No final do processo,
``\mintinline{text}|AbstractFormatter|'' terá na variável ``\mintinline{text}|new_program|'' todos os pedaços do programa formatado.
Uma vez que ``\mintinline{text}|Interpreter|'' termina de construir todos os pedaços de código~=fonte formatado,
a função ``\mintinline{text}|get_new_program|'' irá unir dos os pedaços e
salvá~=los na variável ``\mintinline{text}|cached_new_program|'',
para evitar ter que recalcular o novo programa toda vez que for solicitado a sua nova versão.
\begin{code}
\caption[Construtor de ``AbstractFormatter'']{Construtor de ``\mintinline{text}|AbstractFormatter|'' (\typeref{chapter:codigoDoFormatador})}
\label{code:construtorDeParsedProgram}
\begin{minted}{python}
class AbstractFormatter(object):
    """
        Represents a program as chunks of data as (text_chunk_start_position,
        text_chunk).
    """

    def __init__(self, program, settings):
        super().__init__()
        self.initial_size = len( program )
        self.program = program
        self.settings = OrderedDict( sorted( settings.items(), key=lambda item: len( str( item ) ) ) )

        self.new_program = []
        self.cached_new_program = []
        log( 4, "program %s: `%s`", len( str( self.program ) ), self.program )
\end{minted}
\end{code}

A linha ``\mintinline{text}{sorted}'' realiza a ordenação das configurações sem nenhuma necessidade prática neste caso.
Ela garante que a ordem no qual as configurações irão ser processadas seja sempre a mesma.
Entretanto,
no caso da Adição de Cores,
a linha ``\mintinline{text}{sorted}'' é uma função obrigatória para garantir que os nomes das cores das configurações sejam atribuídas de acordo com a ordem correta do tema (seleção de cores \cite{vsCodeSyntaxHighlighthing,sublimeTextScopeNaming}).

A linha ``\mintinline{text}{len( program )}'' não possui nenhuma influência nos resultados do programa,
seja para formatação ou
adição de cores.
Entretanto,
ela é constantemente verificada durante as operações que realizam o consumo do programa de entrada pelas regras da metagramática para garantir que o tamanho do programa original não seja alterado.
É necessário que os novos trechos de programa que são formatados saibam qual era a posição deles no programa de original (antes da formatação iniciar),
para que as partes do programa original (que não foram formatadas) possam ser adicionadas no novo programa formatado no final do processo de formatação\footnote{
Assim que os algoritmos de adição de cores ou
formatação estiverem propriamente testados,
não seria mais necessário manter o uso da variável ``\mintinline{text}{len( program )}''.
}.

Durante o processo de consumo,
o programa de entrada é modificado e
os caracteres que foram consumidos pela gramática são substituídos por algum caractere qualquer\footnote{
Não existe a necessidade de utilizar algum caractere em específico,
mas é recomendável que este caractere já não exista no texto de entrada para evitar ambiguidades na gramática (\fullref{section:metalinguagemGrammar}) fornecida pelo usuário da ferramenta.
}
e fixo como ``\mintinline{text}|§|'' (\textit{símbolo de seção}) para impedir que eles sejam reconsumidos.
A utilização do caractere ``\mintinline{text}|§|'' (\textit{símbolo de seção}) foi realizada para simplificar a implementação do algoritmo de consumo.
Com o caractere ``\mintinline{text}|§|'' (\textit{símbolo de seção}) colocado no lugar dos caracteres que já foram consumidos,
é possível reconstruir o programa de entrada no final da análise simplesmente ordenando todos os pedaços do programa formatado que estão armazenada na variável ``\mintinline{text}|new_program|''.
Como o tamanho do programa original não foi modificado,
também é possível facilmente integrar no programa formatado,
todas as partes do programa original que não foram formatados,
no caso do formatador de código~=fonte,
ou não coloridas do caso da adição de cores.

Neste capítulo,
foi visto um pouco sobre detalhes da implementação de metaprogramas,
metagramáticas e
metacompiladores para uso como um formatador de código~=fonte.
No próximo capítulo será visto um pouco sobre o que se pode concluir sobre este trabalho e
esperar dos seus trabalhos futuros.
