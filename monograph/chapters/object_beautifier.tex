

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{Uma Ferramenta de Formatação}
\label{software_implementation}

Neste capítulo será explicado o funcionamento e
implementação de uma nova ferramenta de formatação e
os desafios de trabalhos futuros sobre esta implementação.


\section{Uma Gramática de Gramáticas}

Na \fullref{introducaoGramaticas},
foi explicado o que são gramáticas.
Mas,
como gramáticas podem ser expressadas?
Isso depende de como o Analisador delas foi implementado,
sendo assim,
um detalhe de implementação.
Usualmente,
os Analisadores seguem uma notação comum como EBNF\footnote{
Do inglês,
\textit{Extended Backus–Naur Form} uma extensão do padrão BNF.
}\cite{teachingEbnf,antlrBookTerrentParr},
que não difere muito de um Analisador para outros,
exceto por detalhes de implementação específicos de cada Analisador.

Para realizar a implementação da nova ferramenta de formatação de código,
foi realizado a construção de uma nova gramática de gramáticas de uma nova linguagem chamada de ``ObjectBeauty'',
uma meta~=linguagem \cite{compilersCompilerMetaLanguage}.
Na \typeref{MyWorflowForLarkTraduzido} é apresentado o fluxo de uso comum para um analisador.
Neste processo,
o desenvolvedor da linguagem escreve a gramática de especificação desta linguagem,
que é entregue a algum Analisador e
gera~=se um Compilador para tal linguagem.
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido.png}
\caption[Fluxo de uso comum de um Analisador]{Fluxo de uso comum de um Analisador -- Fonte Própria \cite{larkErrorRecovery}}
\label{MyWorflowForLarkTraduzido}
\end{figure}

Já este trabalho faz um uso fora do comum.
Como mostrado na \typeref{MyWorflowForLarkTraduzido2},
primeiro especifica~=se uma gramática de gramáticas (meta~=linguagem) que será utilizada pelos usuários da nova ferramenta de formatação.
Para escrever esta nova meta~=linguagem,
utilizou~=se a ferramenta Lark \cite{larkContextualLexer}.
Usualmente a ferramenta ``Lark'' é utilizada somente como um gerador de compiladores \typeref{MyWorflowForLarkTraduzido},
entretanto neste contexto é utilizado como um compilador de compiladores \typeref{MyWorflowForLarkTraduzido2}.
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{MyWorflowForLarkTraduzido2.png}
\caption[Uso feito pela nova ferramenta de formatação]{Uso feito pela nova ferramenta de formatação -- Fonte Própria \cite{larkErrorRecovery}}
\label{MyWorflowForLarkTraduzido2}
\end{figure}

Em vez de permitir com que o usuário final da aplicação opere diretamente com o Analisador da \typeref{MyWorflowForLarkTraduzido},
foi criado uma nova gramática de gramáticas como mostrado nas \typeref{MyWorflowForLarkTraduzido2}.
Esta nova gramática simplifica o processo de escrita de gramáticas ao criar uma nova especificação de gramáticas,
somente com os recursos necessários para se possa trabalhar com formatação de código.
A final,
não é objetivo deste trabalho fazer a análise completa de programas,
pela sua sintaxe e
semântica e
gerar código binário executável.

Na \typeref{ParsersPublicAudienceTraduzido},
pode~=se encontrar uma relação entre o funcionamento das diversas partes da ferramenta de formatação de código~=fonte e
a audiência alvo.
Basicamente existem três grupos distintos de usuários ou
audiência:
\begin{inparaenum}[1)]
\item quem escreve ou
desenvolve a ferramenta de formatação de código~=fonte desenvolvida neste trabalho e
defini as regras da metalinguagem (especificada pela sua metagramática,
i.e.,
a gramática de gramáticas),
\item quem escreve ou
desenvolve gramáticas de linguagens para serem formatados de acordo com as regras da metalinguagem e
\item quem escreve ou
desenvolvedor programas de computador e
deseja realizar a formatação de seus códigos~=fonte.
\end{inparaenum}%
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{ParsersPublicAudienceTraduzido.png}
\caption[Relacionamentos entre os Diferentes Públicos deste Projeto]{Relacionamentos Entre os Diferentes Públicos deste Projeto -- Fonte Própria \cite{larkErrorRecovery}}
\label{ParsersPublicAudienceTraduzido}
\end{figure}

Esta não é a primeira vez que uma gramática de gramáticas com simplificação foi escrita.
Em trabalhos como \citeonline{rustSublimeTextSyntaxSyntec,sublimeTextSyntax,vsCodeSyntaxHighlighthing} foram realizados as mesmos simplificações aqui apresentadas.
Existem algumas diferenças técnicas da gramática de gramáticas deste trabalho com as dos recém apresentados.
Como por exemplo,
esta gramática de gramáticas não suporta a classificação do mesmo trecho de código por múltiplos tipos de escopo \cite{vsCodeSyntaxHighlighthing}.

Foi escolhido a criação de uma nova metagramática por que as gramáticas já existentes como \citeonline{rustSublimeTextSyntaxSyntec,vsCodeSyntaxHighlighthing}
\begin{inparaenum}[1)]
\item não são capazes de reconhecer todas as características de todas as linguagens de formatação e
\item não possuem sintaxe própria,
i.e.,
elas utilizam de outras linguagens como YAML,
XML e
JSON para fazer a especificação da gramática.
\end{inparaenum}
Assim,
fazendo a especificação de uma nova metagramática,
é possível adaptar~=se a especificação da sintaxe das gramáticas de acordo as necessidades específicas sem ter que depender de características de outras linguagens como YAML,
XML ou
JSON.


\subsection{Escopos}

Na \typeref{TexMateScopes} é mostrado na primeira linha o trecho de código ``function f1 () \{'' e
nas demais linhas são apresentados as diversas classificações de escopos aplicados a cada um dos trechos do código~=fonte de amostra.
Por exemplo, a palavra ``function'' possui simultaneamente os escopos
\begin{inparaenum}[1)]
\item ``source.js''
\item ``meta.function.js'' e
\item ``storage.type.function.js''.
\end{inparaenum}
\begin{figure}[h]
\centering
\includegraphics[width=1.0\textwidth]{TexMateScopes.png}
\caption[Exemplo de Classificação de Código com Múltiplos Escopos]{Exemplo de Classificação de Código com Múltiplos Escopos -- Fonte \citeonline{vsCodeSyntaxHighlighthing}}
\label{TexMateScopes}
\end{figure}

Os nomes utilizados na \typeref{TexMateScopes} podem ser qualquer texto que usuário especificador daquela gramática desejar.
Entretanto,
pode~=se perceber que o nome dos escopos recém apresentados aparentam seguir um padrão.
Por conversão,
desenvolvedores de gramáticas para os editores de texto como \citeonline{sublimeTextSyntax,vsCodeSyntaxHighlighthing},
seguem uma conversão de nomes para que as utilizações dos escopos gerados pelas gramáticas sejam compatíveis entre si.

Fazendo o uso desta convenção,
as gramáticas ficam compatíveis com um maior número de arquivos de temas onde são especificados os nomes dos escopos serão utilizados para especificar as cores a serem utilizadas pelo editor de texto.
Para mais informações sobre a utilização de arquivos de temas em editores de texto veja \citeonline{sublimeTextScopeNaming,vsCodeSyntaxHighlighthing}.


\section{Metalinguagem}

Como já explicado na seção anterior,
uma metagramática é gramática de gramáticas e
foi utilizado a ferramenta ``Lark'' \cite{larkContextualLexer} como um meta~=compilador ou
compilador de compiladores.
Nesta seção será explicado a como a metalinguagem (especificada pela metagramática) utilizada foi construída,
começando com o seu símbolo inicial.
No \typeref{simboloInicialDaMetalinguagem},
defini~=se que o programa é constituído de três grandes áreas,
que devem acontecer uma em sequencia da outra:
\begin{enumerate}
\item A produção ``preamble\_statements'' define características globais da gramática como um nome,
e um escopo que será atribuído a toda gramática.
\item A produção ``language\_construct\_rules'' define qual será o símbolo inicial da gramática.
Em comparação com linguagens de programação como ``C'',
ele pode ser considerado similar ao método ``main''.
\item A produção ``miscellaneous\_language\_rules'' permite a definição de diversos contextos com grupos de produções da gramática \typeref{definicaoDeGramatica},
que podem ser incluídos a partir do símbolo inicial da gramática definido no item ``language\_construct\_rules''.
\end{enumerate}%
\begin{lstlisting}[caption={Simbolo Inicial da Metalinguagem},label={simboloInicialDaMetalinguagem},language=C++]
language_syntax: _NEWLINE? preamble_statements _NEWLINE?
                    language_construct_rules _NEWLINE?
                    ( miscellaneous_language_rules _NEWLINE? )*
                    _NEWLINE?

preamble_statements: ( (
                        target_language_name_statement
                        | master_scope_name_statement
                        | constant_definition
                    ) _NEWLINE )+

language_construct_rules: "contexts" ": " indentation_block
miscellaneous_language_rules: /[^:\n]+/ ": " indentation_block

target_language_name_statement: "name" ": " free_input_string
master_scope_name_statement: "scope" ": " free_input_string
\end{lstlisting}

\begin{lstlisting}[caption={Exemplo de Gramática},label={exemploDeGramaticaPawn}]
name: Abstract Machine Language
scope: source.sma

contexts: {
    include: parens
    include: numbers
    include: check_brackets

    match: (true|false) {
        scope: constant.boolean.language.pawn
    }
}

parens: {
    match: \( {
        scope: parens.pawn
        push: {
            meta_scope: meta.group.pawn
            match: \) {
                scope: parens.pawn
                pop: true
            }
            include: main
        }
    }
}

numbers: {
    match: '(\d+)(\.\{2\})(\d+)' {
        captures: {
            1: constant.numeric.int.pawn
            2: keyword.operator.switch-range.pawn
            3: constant.numeric.int.pawn
        }
    }

    match: ([-]?0x[\da-f]+) {
        scope: constant.numeric.hex.pawn
    }
    match: \b(\d+\.\d+)\b {
        scope: constant.numeric.float.pawn
    }
    match: \b(\d+)\b {
        scope: constant.numeric.int.pawn
    }
}

check_brackets: {
    match: \) {
        scope: invalid.illegal.stray-bracket-end
    }
}
\end{lstlisting}


Para processar a árvore de sintática, é necessário iterar várias vezes pela árvore, que novos escopos não sejam mais aplicados.
Por exemplo,
\begin{lstlisting}
match: " {
    scope: punctuation.definition.string.begin.sma
    push: {
        meta_scope: string.quoted.double.sma
        match: " {
            scope: punctuation.definition.string.end.sma
            pop: true
        }
    }
}
\end{lstlisting}
Essa gramática é válida para reconhecer strings, mas se pegar a primeira expressão
regular e fizer um findall(), eu também vou retornar o fechamento da string.
Assim, quando eu chegar no fecha aspas, ele já vai está consumido.

Criar uma nova linguagem para entrar com a syntaxe como sublime text, mas sem utilizar YAML.
Assim, faz isso como trabalho final de compiladores, onde o seu backend será o formatador.


