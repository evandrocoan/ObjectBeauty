

\chapter{Estado da Arte}
\label{chapter:source_code_beautifiers}

% \section{\lang{What does coding is}{Programação de computadores}}

\lang{
    Coding is like writing and
    reading a book for the large people,
    you like it to look beautifully.
    Or at least do you expect such when you buy a book,
    for example,
    to learn programming for you first time \cite{howNovicesRead}.
    You expect:
    \begin{enumerate}
        \item
            Things to be well organized,
            so you do not get lost;
        \item
            The colors to be properly placed,
            so you do not get distracted from the main content;
        \item
            The spacing between paragraphs,
            words, chapters, sections subsections, etc,
            to be well adjusted.
            Not everything cluttered in only one file,
            line, function, class,
            or whatsoever so;
    \end{enumerate}
}{%
    Programar pode ser considerado pela maioria das pessoas como escrever um livro,
    e para tal,
    a facilidade de leitura é desejável\advisor{.}{
    e
    gostar~=se mais caso este ``livro'' tenha uma boa aparência.%
    }
    Existem livros \advisor{difíceis de ler}{muito horríveis de se ler}:
    fontes inadequadas ou
    pequenas,
    com folhas que brilham contra a luz.
    No mínimo espera~=se algumas características chave ao comprar~=se um livro \cite{visualizationsInAFunctionalProgramming}.
    Por exemplo,
    quando compra~=se um livro,
    \advisor{}{para aprender a programar pela primeira vez,
    }espera~=se que \cite{howNovicesRead}:
    \begin{enumerate}
        \item
            Seu conteúdo esteja bem organizado,
            para que o leitor não se perca durante a leitura;
        \item
            Que suas cores \advisor{sejam}{estejam} propriamente escolhidas e
            utilizadas,
            para que elas não distraiam o leitor ou tirem o foco do principal,
            o conteúdo do livro;
        \item
            Que o espaçamento entre os parágrafos,
            palavras, capítulos, seções, subseções, etc, estejam propriamente ajustados,
            e não\advisor{}{ todo} aglomerado ou desordenado em um único parágrafo,
            frase, capítulo\advisor{.}{, etc.}
    \end{enumerate}
}


\advisor{}{%
    \section{\lang{Computer Assisted Programming}{Programação auxiliada}}

    \lang{%
        Your computer should help you with these unforeseen tasks.
        Why should I spend my precious time checking whether I am actually copying something space indented,
        when I am actually coping something tab indented?
        Perhaps we should sit and
        cry while waiting for some greater force to come and
        rescue us.
        Or may be you should stop crying and
        actually do something about other than keep waiting for you mommy to come and
        save you from the darkness growing behind you back leading you to endless unsleepy nights fixing your code just because everything just went wrong.
    }{%
        Seu computador deveria ajudar você com aquelas imprevistas tarefas.
        Porque eu deveria gastar meu precioso tempo verificando se algo que estou copiando,
        está indentado por ``TAB\s'' ou
        espaços?
        Talvez devêssemos sentar e
        chorar enquanto aguardamos que alguma força maior do Universo venha e
        nos salve.
        Ou talvez você deva para de chorar e
        realmente fazer alguma coisa a respeito além de continuar esperando que sua mamãe venha e
        resgate você da escuridão crescendo pela suas costas levando você a infinitas noites acordado corrigindo seu código simplesmente porque tudo deu errado.
    }
}


\section{Formatadores de código}
\label{section:formatadores_de_codigo}

\lang{%
    A robust Code Beautifier can get a lot more complicated just with the basic definitions of formatting (\fullref{chapter:source_code_beautifiers}) applied over each language own characteristics as for example:
    \begin{enumerate}[nosep,nolistsep]
        \item
            Add spaces before if\s name as in `if(var)' versus `if (var)';
        \item
            Add spaces inside if\s as in `if(var)' versus `if( var )';
        \item
            Add spaces before for\s name as in `for(var)' versus `for (var)';
        \item
            Add spaces inside for\s as in `for(var)' versus `for( var )'.
    \end{enumerate}
}{%
    Conhecido como ``\textit{pretty~=printing}'' ou
    embelezadores\footnote{
    Do inglês,
    \textit{Source Code Beautifiers}.
    }
    \cite{prettyPrintingForSoftware},
    uma ferramenta de formatação pode ser complicada de se utilizar,
    somente com um conjunto básico de definições.
    Por exemplo,
    para permitir um melhor controle do usuário,
    a ferramenta de formatação pode permitir que exista uma configuração específica para cada aspecto da linguagem.

    Uma possível implementação para tal ajuste fino,
    pode ser uma configuração específica como por exemplo a entrada booleana ``\mintinline{text}|use_spaces_after_if|'',
    em um arquivo de configuração para definir caso deva~=se ou
    não adicionar espaços após cada ``\mintinline{text}|if|'' ao fazer a formatação da linguagem,
    i.e.,
    ``\mintinline{text}|if (var)|'' ao contrário de ``\mintinline{text}|if(var)|''.
}

\lang{
    As may be noticed,
    the list may became quite big,
    and if fact such big list of rules has been implemented.
    Looking over the Beautifier called `Uncrustify' \cite{uncrustifySourceCode},
    we can find about 500 settings with specifications like these above.
}{%
    Como pode ser percebido,
    uma lista contendo todas as configurações de formatação para cada aspecto da linguagem,
    ficará muito grande quando todos os aspectos das linguagens mais complexas como C ou
    C++ forem implementados.
    Em softwares como Uncrustify \cite{uncrustifySourceCode},
    encontram~=se mais de 500 configurações\footnote{
    Veja mais sobre configurações na \fullref{section:trabalhosRelacionados}.
    }
    tais como o \typeref{code:uncrustifySettingSample}.
    No \typeref{code:uncrustifySettingSample},
    deve ser observado uma amostra das mais de 500 opções que um formatador de código~=fonte configurável por arquivos de configuração pode ter.
    Também o quão difícil pode ser escrever e
    entender o que cada uma dessas incontáveis opções significam.
}
\begin{lstlisting}[caption={Trecho do Arquivo de Configuração de Uncrustify},label={code:uncrustifySettingSample}]
...

# Add or remove space before ','
sp_before_comma = remove # ignore/add/remove/force

# Add or remove space between an open paren
# and comma: '(,' vs '( ,'
sp_paren_comma = add # ignore/add/remove/force

# Add or remove space after class ':'
sp_after_class_colon = ignore # ignore/add/remove/force

# Add or remove space before class ':'
sp_before_class_colon = ignore # ignore/add/remove/force

...
# Whether the 'extern "C"' body is indented
indent_extern = false       # false/true

# Whether the 'class' body is indented
indent_class = true         # false/true

# Whether to indent the stuff after a
# leading base class colon
indent_class_colon = false  # false/true

# Whether to indent the stuff after a
# leading class initializer colon
indent_constr_colon = false # false/true

...
\end{lstlisting}

\lang{%
    The problem about is,
    even if you go through all these settings,
    which will take you quite some time,
    you still only configuring a few languages closely related.
    On this case,
    C, C++, Java, Pawn,
    etc.
    For all other languages you still need to find out another source code formatter tool,
    which will be certainly limited \cite{eclisePeriodSettings} and
    still need to configure all over again.
}{%
    Mesmo que se passe por todas as configurações do formador de código~=fonte (amostrado no \typeref{code:uncrustifySettingSample}),
    realizando os ajustes de preferência do usuário,
    isso levará um bom tempo.
    Infelizmente com todo esse processo,
    somente será realizado a configuração de uma e
    talvez algumas linguagens fortemente relacionadas,
    dependendo do suporte que a ferramenta de formatação de código~=fonte oferece.

    No caso da ferramenta Uncrustify,
    serão configuradas linguagens como "\mintinline{text}|C|'',
    ``\mintinline{text}|C++|'', ``\mintinline{text}|C|'' e
    ``\mintinline{text}|ObjectiveC|'' (veja mais linguagens na \fullref{section:trabalhosRelacionados}).
    Para todas as outras linguagens,
    ainda será preciso encontrar outra ferramenta de formatação,
    que será certamente mais limitada no que ela pode customizar \cite{eclisePeriodSettings,uncrustifyNotMeetingCodingStandards},
    uma vez que Uncrustify já é uma das mais completas.

    Ao realiza~=se a migração de uma ferramenta de formatação como Uncrustify para outra,
    precisa~=se configurar novamente todas as novas opções já definidas para Uncrustify.
    Outra forte desvantagem do arquivo de configurações do Uncrustify segue na dificuldade de entender e
    visualizar o que está sendo configurado para que se possa realizar a migração.

    \advisor{}{Algumas opções de configuração do formatador de código~=fonte são claras e
    fáceis de se entender.
    Já outras,
    não se consegue ter a mínima ideia do que elas estão fazendo ou
    qual será o seu resultado final.
    Por exemplo,
    é possível claramente entender o que a última configuração do \typeref{code:uncrustifySettingSample} faz?
    }
}

\advisor{}{%
    \lang{%
        Below there are some basic formatting rules for illustration:

        % \begin{bluebox}
        \begin{enumerate}[nosep,nolistsep]
            \item Add new lines after `\{' and before `\}';
            \item Add new lines before `\{';
            \item Remove empty lines;
            \item Add comment lines before function;
            \item Add new lines after `;';
            \item Add new lines after `\}';
            \item Remove new lines;
            \item Reduce whitespace;
            \item Fix bad indentation.
        \end{enumerate}
        % \end{bluebox}
        \vspace{-4mm}\begin{flushright}\textcite{prettyPrinter}\end{flushright}

        Mostly,
        code formatting is resumed into this set of changes.
    }{%
    }
}


\section{\lang{For what is their use?}{Qual a utilidade de Formatadores?}}

\advisor{%
    Pode~=se compreender uma frase sem pontuação,
    mas é mais fácil fazer essa operação utilizando a pontuação.
    Por exemplo:

    \noindent
    umaboapontuacaocomcertezatornaascoisasmaisfaceisdeseler

    Um leitor hábil pode compreender facilmente a oração acima,
    mas a pontuação tornaria a tarefa mais fácil \cite{theTidyverseStyleGuide}.
}{%
    Um bom estilo de formatação é como uma boa pontuação,
    você consegue viver sem \cite{theTidyverseStyleGuide}:

    \noindent
    mascomcertezatornamascoisasmaisfaceisdeseler
}

\lang{%
    For now could not find any strong evidence or
    correlation about code comprehension and
    source code beautifying \cite{improvingCodeReadability},
    except perhaps for team annoyance:
}{%
    Não pôde~=se encontrar nenhuma forte evidência\footnote{
    Com forte evidência refere~=se a afirmações absolutas como:
    ``--Ao utilizar formatadores de código,
    é garantido que seu projeto de desenvolvimento de código~=fonte irá sofre ganhos em tempo de desenvolvimento e
    qualidade de software''.
    }
    ou relação sobre a compreensão de códigos~=fonte e
    formatadores de código.
    Alguns estudos como \citeonline{improvingCodeReadability},
    implementam modelos de Inteligência Artificial utilizados para classificar códigos~=fonte como ``bem legíveis'' ou
    ``mal legíveis''.
    Inicialmente estes estudos começam coletando dados de pessoas classificando códigos~=fonte como legíveis ou
    não,
    para então treinar a Inteligência Artificial para classificar códigos~=fonte.

    Além desse estudo científico para classificar códigos~=fonte,
    encontram~=se em outros lugares como \citeonline{pep8operatorsBlankLine},
    dicas ou
    notas explicando quais características de formatação de código~=fonte ajudam ou
    prejudicam a legibilidade de código.
}%
\begin{citacao}
    % \setlength{\itemindent}{5pt}
    Um dos melhores métodos de destruição de equipes de desenvolvedores de software,
    é engajar~=se em guerras de formatação passiva~=agressiva.
    Elas destroem os relacionamentos entre colegas,
    e dependendo do tipo de formatação feita,
    também podem prejudicar a capacidade de comparar efetivamente as revisões no sistema de controle de versão,
    o que é realmente assustador.
    Não pode~=se nem imaginar o quão ruim seria caso a liderança das equipes fosse a culpada por esse comportamento.
    Isso que é liderar por exemplo.
    Por mau exemplo.
    \cite[tradução nossa\protect\footnotemark]{deathToTheSpaceInfidels}\footnotetext{
    \englishword{%
    One of absolute worst,
    worst methods of teamicide for software developers is to engage in these kinds of passive~=aggressive formatting wars.
    I know because I've been there.
    They destroy peer relationships,
    and depending on the type of formatting,
    can also damage your ability to effectively compare revisions in source control,
    which is really scary.
    I can't even imagine how bad it would get if the lead was guilty of this behavior.
    That's leading by example,
    all right.
    Bad example.
    }}.
\end{citacao}

\lang{%
    On \citeonline{programIndentation},
    was analyzed the level of program comprehension which can be gained by the indentation and
    was comprehended that the indentation levels of 2 and
    4 spaces proved to have the best comprehension levels again other levels.
}{%
    Em \citeonline{programIndentation},
    foi analisado o nível de compreensão do programa que pode ser obtido pela indentação e
    foi constatado que os níveis de indentação de 2 e
    4 espaços provaram ter os melhores níveis de compreensão do que outros níveis.
}%
\begin{citacao}
    % \setlength{\itemindent}{5pt}
    Por mais absurdo que possa parecer,
    lutar sobre espaços em branco e
    outras questões aparentemente triviais de layout de código~=fonte é realmente justificado.
    Desde que feito com moderação,
    abertamente,
    de uma forma justa e
    com construção de consenso,
    sem esfaquear companheiros de equipe ao longo do caminho.
    \cite[tradução nossa\protect\footnotemark]{deathToTheSpaceInfidels}\footnotetext{
    \englishword{%
    So yes,
    absurd as it may sound,
    fighting over whitespace characters and
    other seemingly trivial issues of code layout is actually justified.
    Within reason of course -- when done openly,
    in a fair and
    concensus building way,
    and without stabbing your teammates in the face along the way.
    }}.
\end{citacao}

No fim,
como não se pode dizer certamente que ao utilizar ferramentas de formatação de código~=fonte se irá ter um melhor desempenho,
cabe a cada desenvolvedor ou
time de desenvolvimento decidir por sua experiência,
se existe a necessidade de utilizar uma ferramenta de formatação de código~=fonte.


\section{\lang{Related Works}{Trabalhos Relacionados}}
\label{section:trabalhosRelacionados}

Nesta seção,
são relatados os trabalhos relacionados obtidos através de pesquisa na literatura utilizando a metodologia especificada no \fullref{chapter:firstChapterIntroduction}.
Segundo \citeonline{uncrustifySourceCode},
Uncrustify é capaz de formatar as linguagens:
\begin{inparaenum}[1)]
\item C;
\item C++;
\item C\#;
\item ObjectiveC;
\item D;
\item Java;
\item Pawn e;
\item VALA.
\end{inparaenum}%
De acordo com o site \citetitle{uncrustifyWebSite},
a versão ``\mintinline{text}|0.69.0|'' possui 671 configurações para personalizar a formatação do código~=fonte como mostrado no \typeref{code:uncrustifySettingSample}.

Existem muitas ferramentas e\slash{}ou editores de texto,
e cada uma dessas ferramentas possui suas vantagens e
desvantagens \cite{prettyPrintingOfVisualSentences,anAbstractPrettyPrinter,improvingRefactoringSpeed}.
Por isso,
alguns desenvolvedores de software\advisor{}{
que são mais inquietos ou
entusiastas por novas tecnologias
} podem utilizar simultaneamente duas ou
mais ferramentas dependendo de suas especialidades e
da tarefa que o desenvolvedor está realizando no momento.

Trabalhos como \citeonline{editorConfig},
não são diretamente um formatador de código~=fonte\advisor{.}{,
tema foco desta monografia.
} Mas sua relação com este trabalho é seu propósito de servir como uma ponte de compartilhamento de configurações entre todos os editores de texto.
Com isso,
facilitando a troca de um editor pelo outro durante o desenvolvimento.

\citeonline{universalIndentGUI},
é outra ferramenta que não é um formatador de código~=fonte,
mas sim uma interface comum às várias e
diferentes ferramentas de formatação de código~=fonte.
Na \typeref{figure:UniversalIndentGUIScreenshot4},
pode~=se ver como é a interface com o usuário que esta ferramenta proporciona.

\begin{figure}[!htb]
\caption{Exemplo da tela de configuração de UniversalIndentGUI}
\label{figure:UniversalIndentGUIScreenshot4}
\centering
\includegraphics[width=1.0\textwidth]{UniversalIndentGUIScreenshot4.png}
\fonte{\citeonline{UniversalIndentGUIScreenshot4}}
\nota{O nome da ferramenta é UniversalIndentGUI.}
\end{figure}

A interface da \typeref{figure:UniversalIndentGUIScreenshot4},
permite que se escolha qual será o formatador de código que será utilizado,
e permite que se carregue um arquivo de código~=fonte para ser formatado,
e na medida em que se seleciona as opções pela interface gráfica,
pode~=se visualizar as mudanças no código~=fonte exemplo carregado.
Entretanto,
a ferramenta proposta por \citeonline{universalIndentGUI} enfrenta problemas como as limitações de sua interface gráfica.
Como já mencionado na \fullref{section:trabalhosRelacionados},
Uncrustify na sua versão ``\mintinline{text}|0.69.0|'' possui 671 configurações de formatação de código~=fonte,
mas a interface gráfica de \citeonline{universalIndentGUI},
não possui \advisor{tal número de}{nem próximo de tantas} opções de configuração.

Todas as opções que não aparecem na interface gráfica de \citeonline{universalIndentGUI},
não podem ser utilizadas ao realizar a formatação do código~=fonte porque os arquivos de configuração gerados e
lidos pela ferramenta não conterão estas opções.
Qualquer outra opção adicional inserida manualmente pelo usuário será apagada,
assim não podendo ser utilizadas mais opções além das quais a\advisor{}{
limitada} interface gráfica apresenta.

Outra desvantagem da visualização das mudanças,
como mostrado na \typeref{figure:UniversalIndentGUIScreenshot4},
acontece quando o código~=fonte de amostra carregado não contém partes que são formatadas pela configuração utilizada na interface gráfica.
Nesse caso,
não será apresentada nenhuma alteração no código~=fonte de visualização,
o que pode causar a impressão de que a ferramenta não funciona.

Com o que foi apresentado sobre as ferramentas de formatação de código~=fonte,
já se pode ter uma visão sobre como funcionam e
são as ferramentas de formatação.
Ou elas serão configuradas diretamente pelo usuário,
editando arquivos de configuração \cite{uncrustifySourceCode},
ou elas terão uma interface gráfica que permita ao usuário visualizar as suas alterações diretamente em uma amostra de código~=fonte \cite{universalIndentGUI}.

Quanto ao seu funcionamento interno,
formatadores de código~=fonte seguem o processo de tradução como apresentado na \fullref{section:compiladoresEtradutores}.
Diferentemente do usual para um tradutor,
um formatador de código~=fonte realiza um processo de tradução onde o nível da linguagem de origem e
destino é o mesmo.
Por exemplo,
formatadores de código~=fonte realizam a ``tradução'' de um programa em ``\mintinline{text}|C++|'' para a própria linguagem novamente ``\mintinline{text}|C++|''.


\section{\lang{Obfuscators}{Ofuscadores}}

Ofuscadores\footnote{Do inglês,
\textit{Obfuscator},
\citetitle{obfuscationWikipedia}.
}
são formatadores de código~=fonte que funcionam com objetivo contrário ao dos \textit{Beautifiers},
veja o \typeref{frame:exemploDeOfuscador}.
Em vez de melhorar a leitura do código~=fonte,
sua função é impossibilitar que o código~=fonte seja compreendido ou
eliminar caracteres desnecessários do código~=fonte.
Tais técnicas e
utilidades para estes tipos de software podem ser encontradas com mais detalhes em \citeonline{codeObfuscationTechniques}.
\begin{quadro}[!htb]
\caption[Exemplo de Ofuscador de Código]{Exemplo de Ofuscador de Código \cite{familyOfSourceCodeObfuscators}}
\label{frame:exemploDeOfuscador}
\begin{bluebox}
\begin{code}
\caption{Antes do ofuscamento}
\begin{minted}[xleftmargin=2em]{javascript}
for (i=0; i < M.length; i++)
{
   // Adjust position of clock hands
   var ML = (ns) ? document.layers['nsMinutes' + i]:ieMinutes[i].style;

   ML.top = y[i] + HandY + ( i*HandHeight ) * Math.sin(min) + scroll;
   ML.left = x[i] + HandX + ( i*HandWidth ) * Math.cos(min);
}
\end{minted}
\end{code}

\begin{code}
\caption{Depois do ofuscamento}
\begin{minted}[xleftmargin=2em]{javascript}
for(O79=0;O79<l6x.length;O79++){var O63=(l70)?
document.layers["nsM\151\156u\164\145s"+O79]:
ieMinutes[O79].style;O63.top=l61[O79]+O76+(O79*O75)
*Math.sin(O51)+l73;O63.left=l75[O79]+l77+(O79*l76)
*Math.cos(O51);}
\end{minted}
\end{code}
\end{bluebox}
\end{quadro}

Dentre as utilidades dos Ofuscadores está minimizar a quantidade de dados transmitidos entre um Servidor e
um Cliente Web ao reduzir o tamanho dos arquivos de linguagens como \mintinline{text}|JavaScript|,
quando eles são baixados pelos Navegadores de Internet ao acessar um site que utiliza essas linguagens de script.
Como exemplo,
pode~=se imaginar um arquivo com grande volume de comentários\advisor{.}{
de documentação.} Nesse arquivo,
a transmissão dos comentários pode ser considerada inútil e
consequentemente podem removidos.
Portanto,
fazendo seu ofuscamento pode~=se reduzir seu tamanho em até metade ou
mais.

Eventualmente,
existem linguagens onde o uso de ofuscadores apresenta limitações.
Por exemplo,
diferente da linguagem \mintinline{text}|JavaScript| utilizada no \typeref{frame:exemploDeOfuscador},
a sintaxe da linguagem \mintinline{text}|YAML|\footnote{
Do inglês,
\textit{YAML Ain't Markup Language},
i.e.,
a sigla de YAML é uma definição recursiva.
}
\cite{yamlSpecificModelChecking} obrigatoriamente deve utilizar espaços para indentação e
linhas novas para separar blocos de informação.
Tais características enfraquecem o poder do ofuscamento uma vez que ele possui um maior efeito quando pode~=se introduzir maior caos no documento,
removendo~=se as indentações e
linhas novas. Entretanto,
mesmo sem esses elementos chave,
ainda pode~=se introduzir caos removendo todos os comentários e
renomeando variáveis para nomes \advisor{sem significado de uso}{obtusos\footnote{Sem significado de uso.}} como ``\mintinline{text}|A88|''.


\section{Adição de Cores}
\label{section:sourceCodeHighlighters}

Ao pesquisar sobre formatadores de texto com os recém~=apresentados,
é comum encontrar trabalhos conhecidos como \textit{Pretty~=Printing} ou
\textit{Source Code Highlighters},
que fazem a adição de cores à código~=fonte para serem melhores visualizados:
\begin{inparaenum}[1)]
\item fazer maior destacamento aos elementos mais importes do código~=fonte;
\item fazer menor destacamento aos elementos considerados menos importantes;
\item fazer que elementos relacionados ou
iguais possam ser facilmente encontrados,
fazendo com que eles tenham a mesma cor,
ou uma cor muito similar (além de estilos como negrito,
itálico e
sublinhado).
\end{inparaenum}%

Editores de texto como \citeonline{sublimeTextSyntax},
permitem que seus usuários escrevam as gramáticas das linguagens nas quais se quer editar seu código~=fonte,
dentro do editor com suporte a adição de cores ao elementos do texto.
Este processo é separado por dois ``arquivos de configuração'':
\begin{inparaenum}[1)]
\item o arquivo ``\mintinline{text}|.sublime-syntax|'' que contém propriamente a gramática da linguagem;
\item o arquivo ``\mintinline{text}|.sublime-color-scheme|'' que contém as configurações de estilo para serem aplicados à uma ou
mais gramáticas de diversas linguagens.
\end{inparaenum}%
Seguindo convenções de na escrita dos arquivos ``\mintinline{text}|.sublime-syntax|'' \cite{sublimeTextScopeNaming} e
``\mintinline{text}|.sublime-color-scheme|'' \cite{sublimeTextColorSchemes},
é possível utilizar um único arquivo ``\mintinline{text}|.sublime-color-scheme|'' com diversas gramáticas diferentes (``\mintinline{text}|.sublime-syntax|'').
Também é possível utilizar um único arquivo  de gramática (``\mintinline{text}|.sublime-syntax|'') com diversas configurações de cores ou
estilos diferentes (``\mintinline{text}|.sublime-color-scheme|'').

Como o código~=fonte do editor \citeonline{sublimeTextSyntax} é proprietário,
\citeonline{rustSublimeTextSyntaxSyntec} fez a implementação de uma versão de código~=aberto que reconhece os arquivos de gramática (``\mintinline{text}|.sublime-syntax|'') e
configurações de estilo (``\mintinline{text}|.sublime-color-scheme|'') do editor \citeonline{sublimeTextSyntax}.
A iniciativa de \citeonline{rustSublimeTextSyntaxSyntec} aconteceu porque mesmo o editor de texto \citeonline{sublimeTextSyntax} sendo de código~=fechado,
ele possui um grande número gramáticas e
arquivos de estilo criados pelos seus usuários.
Assim,
esse grande número de especificações poderia ser utilizado por outros editores de texto,
que gostariam de reutilizar a grande base de gramáticas e
estilos já escritas para \citeonline{sublimeTextSyntax}.
\citeonline{rustSublimeTextSyntaxSyntec} diferente de \citeonline{sublimeTextSyntax},
é somente uma biblioteca que pode ser importada por outros editores de texto.

\citeonline{vsCodeSyntaxHighlighthing} diferente de \citeonline{sublimeTextSyntax},
é um editor de texto de código~=aberto que faz uso do mesmo esquema de gramáticas e
arquivos de estilo.
Entretanto,
os arquivos de configuração e
estilo utilizados por \citeonline{vsCodeSyntaxHighlighthing} e
\citeonline{sublimeTextSyntax} não são completamente compatíveis,
eles são similares.
Ambos os trabalhos foram construídos em cima da mesma base,
o editor de texto \citeonline{textMateEditor}.
Cada um desses editores seguiu um rumo diferente do original \citeonline{textMateEditor} conforme eles foram sendo desenvolvidos.

\citeonline{sublimeTextSyntax} continua compatível com os arquivos de gramática e
estilo originais de \citeonline{textMateEditor},
mas também fez a criação de novos operadores para especificação das gramáticas das linguagens (para poder especificar mais tipos linguagens de programação).
Já \citeonline{vsCodeSyntaxHighlighthing},
não fez a adição de novos recursos como \citeonline{sublimeTextSyntax},
contudo,
ele ainda não é completamente compatível com os arquivos de gramáticas originais devido a \textit{bugs} em sua implementação \cite{textMateScopeExclusion}.


\subsection{Gramáticas}
\label{section:sourceCodeHighlightersGrammars}

Apesar das suas diferenças,
tanto \citeonline{sublimeTextSyntax}, quanto \citeonline{vsCodeSyntaxHighlighthing} ou \citeonline{textMateEditor},
fazem uso do mesmo núcleo de funcionamento para especificação das gramáticas e
estilos.
O que muda de um para outro é o suporte a recursos mais avançados (como \citeonline{sublimeTextSyntax} faz) e
o formatado de representação das informações.
Enquanto \citeonline{textMateEditor} e
\citeonline{vsCodeSyntaxHighlighthing} utilizam arquivos no formato XML\footnote{
Do inglês,
\textit{Extensible Markup Language}.
} \cite{complexityOfXMLSchema} para representar as gramáticas e
estilos,
\citeonline{sublimeTextSyntax} faz uso do formato YAML \cite{yamlSpecificModelChecking} para gramáticas e
JSON para estilos (``\mintinline{text}|.sublime-color-scheme|'').

Tanto YAML quanto XML são equivalentes e
podem representar a mesma informação sobre as gramáticas especificadas,
portanto,
tradutores (\fullref{section:compiladoresEtradutores}) como \citeonline{packageDevSublime} podem ser escritos sem dificuldade para converter uma gramática de \citeonline{textMateEditor} para \citeonline{sublimeTextSyntax}.
Mas nem sempre no sentido contrário,
uma vez que \citeonline{sublimeTextSyntax} faz a adição de novos operadores para especificação de suas gramáticas.

Escolheu~=se mostrar um exemplo de gramática e
estilo utilizados por \citeonline{sublimeTextSyntax} porque dos três trabalhos:
\begin{inparaenum}[1)]
\item ele é consegue especificar mais diferentes tipos de gramáticas (pelos novos operadores adicionados,
como ``\mintinline{text}|set|'' e
``\mintinline{text}|branch|'' \cite{branchTemporarilyHighlightsWrong}) e;
\item utiliza YAML para representar suas gramáticas,
tornando a leitura dos arquivos muito mais amigável do que XML,
como utilizado pelos outros trabalhos \cite{textMateEditor,vsCodeSyntaxHighlighthing}.
\end{inparaenum}%
No \typeref{code:exemploDeUmArquivoSublimeSyntax},
pode ser encontrado um exemplo funcional de gramática aceita por \citeonline{sublimeTextSyntax}.
Mesmo não sendo capaz de descrever uma linguagem em todos os seus detalhes,
este arquivo já é suficiente para encontrar as palavras~=chaves:
\begin{inparaenum}[1)]
\item ``\mintinline{text}|if|'';
\item ``\mintinline{text}|else|'';
\item ``\mintinline{text}|for|'';
\item e
``\mintinline{text}|while|'',
\end{inparaenum}%
com o escopo ``\mintinline{text}|keyword.control.c|'' de uma certa linguagem chamada ``\mintinline{text}|C|'',
onde os arquivos dela possuem as extensões ``\mintinline{text}|.c|'' e
``\mintinline{text}|.h|''.
\begin{code}
\caption[Exemplo de um arquivo ``.sublime-syntax'']{Exemplo de um arquivo ``\mintinline{text}|.sublime-syntax|''}
\label{code:exemploDeUmArquivoSublimeSyntax}
\begin{minted}{yaml}
%YAML 1.2
---
name: C
file_extensions: [c, h]
scope: source.c

contexts:
  main:
    - match: \b(if|else|for|while)\b
      scope: keyword.control.c
\end{minted}
\xpretocmd{\ABNTEXfontereduzida}{\setlength{\belowcaptionskip}{-13pt}}{}{}
\fonte{\citeonline{sublimeTextSyntax}}
\vspace{13pt}
\end{code}

Uma vez que o \typeref{code:exemploDeUmArquivoSublimeSyntax} classificou as palavras~=chave com o escopo ``\mintinline{text}|keyword.control.c|'',
um editor de texto precisa somente mais de um arquivo de configuração para determinar como estas palavras~=chave devem ser exibidas.
No \typeref{code:exemploDeUmArquivoSublimeColorScheme},
encontra~=se um exemplo de arquivo JSON de configuração de estilos.
Nele,
há a definição de três tipos de estilo diferentes.
O último deles aplica ao nosso escopo ``\mintinline{text}|keyword.control.c|'',
a cor de texto ``\mintinline{text}|#7F00FF|'' (RGB hexadecimal),
com o estilo de fonte ``\textit{itálico}''.

As demais especializações de escopos do arquivo (\typeref{code:exemploDeUmArquivoSublimeColorScheme}) não foram utilizadas porque a gramática (\typeref{code:exemploDeUmArquivoSublimeSyntax}),
não fez sua utilização.
Como arquivos de estilo podem ser utilizados com muitas gramáticas diferentes,
e uma gramática pode ser utilizada com muitos arquivos de estilo diferentes,
sempre poderão acontecer casos onde nem todas os escopos da gramática serão utilizados e
nem todos os escopos dos arquivos de estilo serão utilizados.
\begin{code}
\caption[Exemplo de um arquivo ``.sublime-color-scheme'']{Exemplo de um arquivo ``\mintinline{text}|.sublime-color-scheme|''}
\label{code:exemploDeUmArquivoSublimeColorScheme}
\begin{minted}{json}
{
    "name": "Example Color Scheme",
    "variables":
    {
        "green": "hsla(153, 80%, 40%, 1)",
        "black": "#111",
        "white": "rgb(242, 242, 242)"
    },
    "globals":
    {
        "background": "var(black)",
        "foreground": "var(white)",
        "caret": "color(var(white) alpha(0.8))"
    },
    "rules":
    [
        {
            "name": "Comment",
            "scope": "comment",
            "foreground": "#888888"
        },
        {
            "name": "String",
            "scope": "string",
            "foreground": "hsla(50, 100%, 50%, 1)",
        },
        {
            "name": "Operators",
            "scope": "keyword.control.c",
            "foreground": "#7F00FF",
            "font_style": "italic",
        }
    ]
}
\end{minted}
\xpretocmd{\ABNTEXfontereduzida}{\setlength{\parskip}{10pt}\setlength{\belowcaptionskip}{-13pt}}{}{}
\fonte{\citeonline{sublimeTextColorSchemes}}
\vspace{13pt}
\end{code}

Em casos de estrema incompatibilidade,
podem acontecer casos onde nenhum estilo pode ser aplicado,
porque a gramática e
o arquivo de estilo não concordam em nenhum nome de escopo.
Por essas e
outras,
foram criados guias de estilo \cite{sublimeTextScopeNaming} onde criam~=se convenções de nomes de escopos para serem utilizados tanto por quem cria gramáticas,
quanto por quem cria arquivos de estilo para editores de texto.

Mas porque exitem arquivos de estilo?
Para que se possam trocar algumas,
senão todas as cores que são exibidas pelo editor de texto.
Por exemplo,
durante o dia pode~=se gostar de utilizar cores de texto mais claras com um fundo branco,
enquanto durante a noite,
um fundo mais escuro com cores de texto mais claras.
Ou ainda,
diferentes programadores possuem diferentes preferências de cores.
Assim,
todos podem utilizar o mesmo editor de texto somente configurando o editor de texto com as suas preferências de cores.


\advisor{}{%
    \section{Lista de curiosidades}

    \lang{%
        On a distributed version control system,
        continuous integration would be continuously running the system tests as long new code is integrated into main system from the distributed clients \cite{continuousIntegration}.
    }{}

    \begin{enumerate}
        % https://tex.stackexchange.com/questions/123104/inline-citations-with-only-author-title-and-year
        \item \citeauthortitleyear{trackingChanges};
        \item \citeauthortitleyear{aspectOriented};
        \item \citeauthortitleyear{annotationAssistant};
        \item \citeauthortitleyear{codePlagiarismDetection};
        \item \citeauthortitleyear{softwarePortfolio};
        \item \citeauthortitleyear{legacyAssets};
        \item \citeauthortitleyear{massMaintenance};
        \item \citeauthortitleyear{prettyPrinting};
        \item \citeauthortitleyear{architectureFormatting};
        \item \citeauthortitleyear{independentFramework};
        \item \citeauthortitleyear{industrialApplication};
        \item \citeauthortitleyear{toolsForProjectManagement};
        \item \citeauthortitleyear{codeClassification};
        \item \citeauthortitleyear{codeScanningPatterns};
        \item \citeauthortitleyear{debuggingIntoExamples};
        \item \citeauthortitleyear{programUnderstanding};
        \item \citeauthortitleyear{documentingAndSharingKnowledge};
        \item \citeauthortitleyear{autofoldingForSourceCode};
        \item \citeauthortitleyear{learningSupportSystem};
        \item \citeauthortitleyear{syntaxHighlightingInfluencing};
        \item \citeauthortitleyear{improvingCodeReadability};
        \item \citeauthortitleyear{howNovicesRead};
        \item \citeauthortitleyear{theRoleOfMethodChains};
        \item \citeauthortitleyear{codeComprehensionComparedToOO};
        \item \citeauthortitleyear{enhancingLegacySoftwareSystemAnalysis};
        \item \citeauthortitleyear{moldableCodeEditor};
        \item \citeauthortitleyear{blindAndSightedProgrammers};
        \item \citeauthortitleyear{pushdownAutomata};
        \item \url{https://github.com/r-lib/styler};
        \item \url{https://github.com/github/linguist};
        \item \url{https://github.com/wbond/package_control_channel/issues/4310} Write a formatter utility;
        \item \url{https://github.com/PyCQA/pydocstyle};
        \item \url{https://github.com/PyCQA/pycodestyle};
        \item \url{https://blog.codinghorror.com/check-in-early-check-in-often/};
        \item \url{https://www.youtube.com/watch?v=2GqpdfIAhz8};
        \item \url{http://langserver.org/};
        \item \url{https://github.com/Microsoft/language-server-protocol};
        \item \url{https://github.com/SublimeCodeIntel/SublimeCodeIntel};
        \item \url{https://code.visualstudio.com/blogs/2016/06/27/common-language-protocol};
        \item \url{https://www.eclipse.org/community/eclipse_newsletter/2017/may/article1.php};
        \item \url{https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations}.
    \end{enumerate}
}

Neste capítulo,
foi apresentado um pouco sobre os formatadores de código~=fonte e
ferramentas de adição de cores.
No próximo capítulo será apresentado um pouco sobre a tentativa de união do estado da arte dos formatadores de código~=fonte,
junto com o estado da arte das ferramentas de adição de cores recém~=apresentadas,
na tentativa da criação de formatadores de código~=fonte com a flexibilidade de extensão das ferramentas de adição de cores.
