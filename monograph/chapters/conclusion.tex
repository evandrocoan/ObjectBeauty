

\chapter{\lang{Conclusion}{Conclusão}}

\lang{%
    The difference from this proposal to remaining formatting tools,
    is the tradeoff between end\hyp{}users and developers responsibilities.
    Most tools rarely expose to end\hyp{}users their language syntax specification,
    in contrast,
    this proposal completely exposes the language to the end\hyp{}user as simple plain\hyp{}text,
    not requiring the tool to know any language syntax neither semantics.
    Moreover,
    with no syntax knowledge required,
    the tool be can used with any languages their user wishes to.

\begin{enumerate}[leftmargin=*]
    \item
        There are many different tools, sometimes paid, and difficult to
        complete. \cite{universalCodeFormatter}
    \item
        Many programming languages exist, so always having Beautifier
        software for each of them is very laborious
        \cite{universalCodeFormatter}. But the approach to a Universal
        Beautifier proposed in this work, would allow easily new languages to be
        added, being completely different from previous ones, or alike. And in
        case of similarities between them, it is enough to reuse their
        configuration structures already implemented.
    \item
        Looking for a Beautifier for each one of them because programmers
        currently work daily with several of these languages, and they are not
        similar. So you need to configure several beautifiers to do the
        formatting. This is a problem because only a few beautifiers are more
        complete, and every time you need to make a change in the formatting
        style, you must manually propagate the same change over several
        different program configuration files, which is bad because it takes the
        user a lot of time to learn how to handle many different types of
        settings. \cite{universalIndentGUI}
    \item
        In the case of ideal Beautifier, a change in your styling is
        propagated to all languages. And if you want to leave some language out
        of it, you just need to remove it from the list on which the
        configuration block applies to, and `a)' leave it out so no change is
        applied to. Or `b)' create a new block including only the block within
        the desired settings.
\end{enumerate}
}{%
    Neste trabalho foi desenvolvidos duas ferramentas que utilizam a mesma metagramática.
    A primeira ferramenta feita foi a de Adição de Cores e
    a segunda foi o Formatador de Código.
    Primeiro foi desenvolvida a ferramenta de Adição de Cores para facilitar os testes da metalinguagem e
    do analisador semântico.
    Como a ferramenta de Adição de Cores foi a primeira desenvolvida,
    ela obteve a criação de mais testes de unidade para assegurar que a implementação do analisador semântico e
    da metagramática estão funcionais.

    Uma vez que se comprovou o funcionamento da metalinguagem,
    foi realizada um implementação mínima de um formatador de código~=fonte.
    Ambas as implementações são somente uma prova de conceito do que pode ser feito com a metalinguagem desenvolvida.
    A diferença desta nova proposta de ferramenta de formatação de código~=fonte para as demais é a troca de responsabilidades entre usuários finais da ferramenta e
    os desenvolvedores desta ferramenta e
    das gramáticas para os usuários finais.
    Formatadores de código~=fonte usualmente somente expõe controladamente quais são as mudanças que podem ocorrer ao formatar o código~=fonte.

    A maior parte das ferramentas raramente permite que usuários finais tenham o controle total das mudanças no código~=fonte.
    Enquanto utilizando a ferramenta desenvolvida neste trabalho,
    é facilmente possível escrever regras de formatação que quebrem a sintaxe e
    semântica da linguagem sendo formatada.
    Por exemplo,
    na linguagem ``Go'' \cite{programmingLanguageGolang},
    diferentemente de todas as demais linguagens,
    é um erro de sintaxe adicionar a chave ``\{'' de abertura de bloco em uma linha nova.

    Utilizando~=se as ferramentas usuais de formatação,
    fica impedido que configurações de formatação do usuário final quebrem o código~=fonte da linguagem sendo formatada,
    a não ser em casos de \textit{bugs} na ferramenta de formatação.
    As ferramentas de formatação em geral,
    tentam reconstruir a árvore de sintaxe da linguagem a ser formatada.
    Neste trabalho,
    o usuário final pode escolher entre simplesmente especificar a gramática da linguagem com o mínimo necessário para atingir somente as suas necessidades de formatação de código~=fonte.
    Mas ao mesmo tempo,
    ele também pode realizar a especificação completa de toda a sintaxe da sua linguagem.

    Mesmo com a especificação completa da sintaxe da linguagem,
    ainda não será o suficiente para impedir quebras nos códigos~=fonte sendo formatados,
    pois a sintaxe da linguagem não cobre os seus aspectos semânticos.
    Neste caso,
    o usuário final precisará conhecer quais são as regras semânticas da linguagem que ele está realizando a formatação,
    e configurar o formatador de modo que ele não quebre nenhuma das regras semânticas desta linguagem.

    A ferramenta desenvolvida neste trabalho não seria recomendada ser utilizada por usuários que não possuem conhecimentos sobre semântica das linguagens que querem realizar a formatação de código~=fonte.
    Neste caso,
    recomenda~=se que seja utilizado as demais ferramentas de formatação que são mais especificas para cada linguagem individualmente e
    possuem inerentemente os conhecimentos específicos da sintaxe e
    semântica da linguagem.
}


\chapter{\lang{Future Works}{Trabalhos Futuros}}

Existem incontáveis pontos que precisam ser reescritos,
melhorados ou completados. Mais especificamente,
sobre a metalinguagem e
gerador de formatadores criados:
\begin{enumerate}
\item Adicionar quaisquer regras semânticas da metalinguagem que não foram adicionadas no analisador semântico.
\item Reduzir o uso de memória e
otimizar a performance em tempo de execução,
uma vez que os algoritmos e
estratégias adotas não levaram estes pontos em consideração.
\item Corrigir erros de interpretação da metalinguagem ou
da especificação da metagramática quando alguns operadores como ``scope'' que tem um uso opcional,
são omitidos.
\item Implementar os operadores ``captures'',
``set'' e
outros mais que forem julgados necessários para tornar o uso da metalinguagem mais fácil ou
melhorar a sua performance para casos específicos de uso.
\item Adicionar suporte especificação de múltiplos escopos a um mesmo trecho de código \cite{vsCodeSyntaxHighlighthing},
definindo alguma estrutura de dados adequada,
capaz de permitir consultas e
aritméticas de escopos \cite{textMateScopeExclusion} com performance constante $\Theta(1)$.
\item Melhorar a legibilidade e
facilitar a escrita das gramáticas,
removendo a necessidade de chaves de abertura ``\{'' e
fechamento ``\}'' de blocos,
fazendo a separação de blocos ser feita de acordo com a indentação como em linguagens como Python e
YAML.
\end{enumerate}%

A atual estrutura de composição dos formatadores de código~=fonte não suporta que diversos formatadores realizem a formatação simultaneamente.
Somente um formatador,
que extende da classe ``AbstractFormatter'' pode estar em funcionamento ao mesmo tempo.
Entretanto,
este formatador recebe como parâmetro de sua função ``format\_text'',
o trecho de código~=fonte a ser formatador e
o escopo dele.
Com essas informações ele poderia em tese,
chamar diferentes formatadores mais especializados de acordo com o seu parâmetro escopo.

Em relação aos formatadores gerados pelo gerador de formatadores,
eles precisaram ser completamente reescritos,
uma vez que as melhorias feitas no gerador de formatadores e
metalinguagem linguagem forem concluídas.
A implementação atual dos formatadores pode ser considerada nula,
uma vez que toda sua lógica de funcionamento é construída como um simples iteração descendente pela Árvore de Sintaxe Abstrata gerada pelo analisador semântico.

Em \citeonline{objectBeautifierFutureWorks},
pode ser encontrada a concepção inicial de implementação da ferramenta de formatação de código~=fonte deste trabalho.
Uma vez que este trabalho for publicado,
seu código~=fonte estará disponível.
Então,
seguindo as referências de \citeonline{objectBeautifierFutureWorks} será possível encontrar a especificação robusta e
completa sobre a melhor implementação de formatadores de código~=fonte com os requerimentos deste trabalho.

