

\chapter{\lang{Conclusion}{Conclusão}}
\label{chapter:conclusion}

\lang{%
    The difference from this proposal to remaining formatting tools,
    is the tradeoff between end~=users and developers responsibilities.
    Most tools rarely expose to end~=users their language syntax specification,
    in contrast,
    this proposal completely exposes the language to the end~=user as simple plain~=text,
    not requiring the tool to know any language syntax neither semantics.
    Moreover,
    with no syntax knowledge required,
    the tool be can used with any languages their user wishes to.

\begin{enumerate}[leftmargin=*]
    \item
        There are many different tools, sometimes paid, and difficult to
        complete. \cite{universalCodeFormatter};
    \item
        Many programming languages exist, so always having Beautifier
        software for each of them is very laborious
        \cite{universalCodeFormatter}. But the approach to a Universal
        Beautifier proposed in this work, would allow easily new languages to be
        added, being completely different from previous ones, or alike. And in
        case of similarities between them, it is enough to reuse their
        configuration structures already implemented;
    \item
        Looking for a Beautifier for each one of them because programmers
        currently work daily with several of these languages, and they are not
        similar. So you need to configure several beautifiers to do the
        formatting. This is a problem because only a few beautifiers are more
        complete, and every time you need to make a change in the formatting
        style, you must manually propagate the same change over several
        different program configuration files, which is bad because it takes the
        user a lot of time to learn how to handle many different types of
        settings \cite{universalIndentGUI};
    \item
        In the case of ideal Beautifier, a change in your styling is
        propagated to all languages. And if you want to leave some language out
        of it, you just need to remove it from the list on which the
        configuration block applies to, and `a)' leave it out so no change is
        applied to. Or `b)' create a new block including only the block within
        the desired settings.
\end{enumerate}
}{%
    Neste trabalho foi proposta uma implementação de um algoritmo que trabalha diretamente com a Árvore Sintática da gramática do programa de entrada (\fullref{software_implementation}).
    Apesar de simples,
    esta implementação é o primeiro passo para criação de novos formatadores de código~=fonte.
    Servindo de base para criação de novos algoritmos voltados a utilizar Árvore de Sintática da gramática da linguagem,
    ao contrário da Árvore Sintática do programa de entrada.

    A maior parte das ferramentas de formatação de código~=fonte raramente permite que usuários finais tenham o controle total das alterações no código~=fonte.
    Em um primeiro momento,
    utilizando a proposta desenvolvida neste trabalho,
    é possível escrever regras de formatação que quebrem a sintaxe e
    semântica da linguagem que está sendo formatada.
    Por exemplo,
    na linguagem ``Go'' \cite{programmingLanguageGolang},
    diferentemente de todas as demais linguagens,
    é um erro de sintaxe adicionar a chave ``\{'' de abertura de bloco em uma linha nova.
    Por isso,
    um formatador de código~=fonte para linguagem ``Golang'',
    não deveria permitir a configuração de colocar a chave de abertura de blocos ``\{'' em uma nova linha.

    Utilizando~=se as ferramentas usuais de formatação,
    fica impedido que configurações do usuário cause erros sintáticos ou
    semânticos código~=fonte da linguagem que está sendo formatada,
    a não ser em casos de \textit{bugs} na ferramenta.
    As ferramentas de formatação de código~=fonte em geral,
    tentam reconstruir toda a Árvore Sintática do programa de entrada a ser formatado.
    Neste trabalho,
    é realizada a construção da Árvore de Sintática da gramática do programa ser formatado,
    e não a Árvore Sintática do programa que está sendo formatado.
    Com essa mudança,
    cresce a necessidade da criação de toda uma nova gama de algoritmos de formatação,
    que possam trabalhar com a Árvore Sintática da gramática dos programa que está sendo formatado,
    ao contrário de trabalhar diretamente com a Árvore Sintática do programa que está sendo formatado.

    A primeira vantagem de se trabalhar com a Árvore Sintática da gramática do programa que está sendo formatado,
    ao contrário da Árvore Sintática do programa que está sendo formatado,
    é a liberdade do usuário final poder escolher especificar exatamente quais são as partes da sintaxe do programa a ser formatado.
    Com isso,
    é possível especificar exatamente quais estruturas do programa devem ser formatados (e quais não),
    além de permitir que facilmente sejam adicionado suporte a novas linguagens de programação recém criadas,
    reutilizando estruturas de sintaxe comuns a linguagens já existentes.

    Em um modelo de trabalho onde se faz a formatação do código~=fonte diretamente com a Árvore Sintática do programa de entrada,
    é possível realizar verificações da semântica do programa que está sendo formatado com maior facilmente,
    pelo acesso direto a Árvore Sintática do programa de entrada,
    (base para Análise Semântica (\fullref{analiseSemantica})).
    Por isso,
    os algoritmos de formatação de código~=fonte desenvolvidos para este trabalho também irão precisar considerar os aspectos semânticos.
    Entretanto,
    estes algoritmos terão uma dificuldade adicional.
    Enquanto os algoritmos de Análise Semântica trabalham com base na Árvore Sintática do programa de entrada,
    os algoritmos de Análise Semântica deste trabalho precisam trabalhar com base na Árvore Sintática da gramática do programa de entrada.
    O que levará a necessidade da criação de novos algoritmos de Análise Semântica capazes de trabalhar com a Árvore Sintática da gramática do programa de entrada.
}


\section{\lang{Future Works}{Trabalhos Futuros}}

O autor desse trabalho sugere alguns trabalhos futuros em \citeonline{objectBeautifierFutureWorks}.
Antes que novos formatadores de código~=fonte sejam implementados,
estes pontos precisam ser revistos.
Ao realizar estas mudanças,
qualquer implementação já realizada para formatação será perdida devido ao número de alterações realizadas\advisor{.}{,
como em um efeito borboleta \cite{standardButterflyEffect}.%
} Mais especificamente,
sobre a metalinguagem e
gerador de formatadores criados,
sugerem~=se as seguintes alterações:
\begin{enumerate}
\item Reduzir o uso de memória e
otimizar a performance em tempo de execução,
uma vez que os algoritmos e
estratégias adotas não levaram estes pontos em consideração;
\item Corrigir erros de interpretação da metalinguagem ou
da especificação da metagramática quando alguns operadores como ``scope'' que tem um uso opcional,
são omitidos;
\item Implementar operadores como ``captures'' e
``set'' para tornar o uso da metalinguagem mais fácil ou
melhorar a sua performance em casos de uso específicos;
\item Adicionar suporte à especificação de múltiplos escopos a um mesmo trecho de código \cite{vsCodeSyntaxHighlighthing},
definindo alguma estrutura de dados adequada,
capaz de permitir consultas e
aritméticas de escopos \cite{textMateScopeExclusion} com performance constante $\Theta(1)$;
\item Melhorar a legibilidade e
facilitar a escrita das gramáticas,
removendo a necessidade de chaves de abertura ``\{'' e
fechamento ``\}'' de blocos (alterando a metagramática),
fazendo a separação de blocos ser feita de acordo com a indentação como em linguagens como Python e
YAML;
\item Realizar a criação de uma nova estrutura de dados para representar o programa de entrada e
avaliar se esta nova estrutura de dados é capaz de substituir utilização do caractere ``§'' em conjunto com a classe padrão de \textit{string} da linguagem Python (aumentado a eficiência dos algoritmos de análise do programa de entrada a ser formatado).
\end{enumerate}%

A atual estrutura de composição dos formatadores de código~=fonte não suporta que diversos formatadores realizem a formatação simultaneamente.
Somente um formatador,
que estende da classe ``AbstractFormatter'' pode estar em funcionamento.
Entretanto,
este formatador recebe como parâmetro de sua função ``format\_text'',
o trecho de código~=fonte a ser formatado e
o escopo dele.
Com essas informações ele poderia em tese,
chamar diferentes formatadores mais especializados de acordo com o seu parâmetro escopo.

\advisor{}{Em relação aos formatadores gerados pelo gerador de formatadores,
eles precisaram ser completamente reescritos,
uma vez que as melhorias feitas no gerador de formatadores e
metalinguagem linguagem forem concluídas.
A implementação atual dos formatadores pode ser considerada nula,
uma vez que toda sua lógica de funcionamento é construída como um simples iteração descendente pela Árvore Sintática Abstrata gerada pelo Analisador Semântico.
}
