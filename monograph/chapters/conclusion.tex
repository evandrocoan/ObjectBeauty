

\chapter{\lang{Conclusion}{Conclusão}}
\label{chapter:conclusion}

\lang{%
    The difference from this proposal to remaining formatting tools,
    is the tradeoff between end~=users and developers responsibilities.
    Most tools rarely expose to end~=users their language syntax specification,
    in contrast,
    this proposal completely exposes the language to the end~=user as simple plain~=text,
    not requiring the tool to know any language syntax neither semantics.
    Moreover,
    with no syntax knowledge required,
    the tool be can used with any languages their user wishes to.

\begin{enumerate}[leftmargin=*]
    \item
        There are many different tools, sometimes paid, and difficult to
        complete. \cite{universalCodeFormatter};
    \item
        Many programming languages exist, so always having Beautifier
        software for each of them is very laborious
        \cite{universalCodeFormatter}. But the approach to a Universal
        Beautifier proposed in this work, would allow easily new languages to be
        added, being completely different from previous ones, or alike. And in
        case of similarities between them, it is enough to reuse their
        configuration structures already implemented;
    \item
        Looking for a Beautifier for each one of them because programmers
        currently work daily with several of these languages, and they are not
        similar. So you need to configure several beautifiers to do the
        formatting. This is a problem because only a few beautifiers are more
        complete, and every time you need to make a change in the formatting
        style, you must manually propagate the same change over several
        different program configuration files, which is bad because it takes the
        user a lot of time to learn how to handle many different types of
        settings \cite{universalIndentGUI};
    \item
        In the case of ideal Beautifier, a change in your styling is
        propagated to all languages. And if you want to leave some language out
        of it, you just need to remove it from the list on which the
        configuration block applies to, and `a)' leave it out so no change is
        applied to. Or `b)' create a new block including only the block within
        the desired settings.
\end{enumerate}
}{}

Neste trabalho foi proposta uma implementação de um algoritmo que trabalha diretamente com a Árvore Sintática da gramática do programa de entrada (\fullref{chapter:software_implementation}).
Apesar de simples,
esta implementação é o primeiro passo para criação de novos formatadores de código~=fonte.
Servindo de base para criação de novos algoritmos voltados a utilizar Árvore Sintática da gramática da linguagem,
ao contrário da Árvore Sintática do programa de entrada.

A maior parte das ferramentas de formatação de código~=fonte raramente permite que usuários finais tenham o controle total das alterações no código~=fonte.
Em um primeiro momento,
utilizando a proposta desenvolvida neste trabalho,
é possível escrever regras de formatação que quebrem a sintaxe e
semântica da linguagem que está sendo formatada.
Por exemplo,
na linguagem ``\mintinline{text}|Go|'' \cite{programmingLanguageGolang},
diferentemente de todas as demais linguagens,
é um erro de sintaxe adicionar a chave ``\mintinline{text}|{|'' de abertura de bloco em uma linha nova.
Por isso,
um formatador de código~=fonte para linguagem ``\mintinline{text}|Golang|'',
não deveria permitir a configuração de colocar a chave de abertura de blocos ``\mintinline{text}|{|'' em uma nova linha.

Utilizando~=se as ferramentas usuais de formatação,
fica impedido que configurações do usuário cause erros sintáticos ou
semânticos código~=fonte da linguagem que está sendo formatada,
a não ser em casos de \textit{bugs} na ferramenta.
As ferramentas de formatação de código~=fonte em geral,
tentam reconstruir toda a Árvore Sintática do programa de entrada a ser formatado (\fullref{section:trabalhosRelacionados}).
Neste trabalho,
é realizada a construção da Árvore Sintática da gramática do programa ser formatado,
e não a Árvore Sintática do programa que está sendo formatado.
Com essa mudança,
cresce a necessidade da criação de toda uma nova gama de algoritmos de formatação,
que possam trabalhar com a Árvore Sintática da gramática dos programa que está sendo formatado,
ao contrário de trabalhar diretamente com a Árvore Sintática do programa que está sendo formatado.

A primeira vantagem de se trabalhar com a Árvore Sintática da gramática do programa que está sendo formatado,
ao contrário da Árvore Sintática do programa que está sendo formatado,
é a liberdade do usuário final poder escolher especificar exatamente quais são as partes da sintaxe do programa a ser formatado (como já é feito em editores de texto para adição de cores (\fullref{section:sourceCodeHighlighters}).
Com isso,
é possível especificar exatamente quais estruturas do programa devem ser formatados (e quais não),
além de permitir que facilmente sejam adicionado suporte a novas linguagens de programação recém criadas,
reutilizando estruturas de sintaxe comuns a linguagens já existentes.

Em um modelo de trabalho onde se faz a formatação do código~=fonte diretamente com a Árvore Sintática do programa de entrada,
é possível realizar verificações da semântica do programa que está sendo formatado com maior facilmente,
pelo acesso direto a Árvore Sintática do programa de entrada,
(base para Análise Semântica (\fullref{section:analiseSemantica}).
Por isso,
os algoritmos de formatação de código~=fonte desenvolvidos para este trabalho também irão precisar considerar os aspectos semânticos.
Entretanto,
estes algoritmos terão uma dificuldade adicional.
Enquanto os algoritmos de Análise Semântica trabalham com base na Árvore Sintática do programa de entrada,
os algoritmos de Análise Semântica deste trabalho precisam trabalhar com base na Árvore Sintática da gramática do programa de entrada.
O que levará a necessidade da criação de novos algoritmos de Análise Semântica capazes de trabalhar com a Árvore Sintática da gramática do programa de entrada.


\section{Comparação com outros trabalhos}

Dos três tipos trabalhos relacionados apresentados no \fullref{chapter:source_code_beautifiers},
este trabalho é mais similar a dois deles.
Os formatadores de código~=fonte configurado por arquivos de texto e
as ferramentas de adição de cores.
Pela lógica de funcionamento deste trabalho,
não seria muito interessante que existisse uma interface gráfica como a da ferramenta \cite{universalIndentGUI},
porque o objetivo deste trabalho é que resolva os problemas apresentados pelas ferramentas de formatação de código~=fonte hoje existentes.
Enquanto que a criação de uma ferramenta de formatação com uma interface gráfica como a de \cite{universalIndentGUI} apresenta problemas (\fullref{section:trabalhosRelacionados}).

A relação deste trabalho com os formatadores configurados por arquivos de texto,
é que ambos são inteiramente configurados por arquivos de texto.
Dependendo da complexidade das gramáticas escritas,
ambos os trabalhos podem apresentar o problema de compreensão,
i.e.,
entender como determina configuração irá formatar o código~=fonte.
Ambas as ferramentas possuem arquivos de configuração que são simples de alterar.
No exemplo apresentado (\typeref{section:softwareImplementationVisaoGeral}),
o resultado da formatação inteiramente controlado pelo valor de um número inteiro.

A atual estrutura de composição dos formatadores de código~=fonte não suporta que diversos formatadores realizem a formatação simultaneamente.
Somente um formatador,
que estende da classe ``\mintinline{text}|AbstractFormatter|'' pode estar em funcionamento (\fullref{section:AnalisadorSemantico}).
Entretanto,
este formatador recebe como parâmetro de sua função ``\mintinline{text}|format_text|'',
o trecho de código~=fonte a ser formatado e
o escopo dele.
Com essas informações ele poderia em tese,
chamar diferentes formatadores mais especializados de acordo com o seu parâmetro escopo.

Assim em evoluções deste trabalho,
diferente dos outros formatadores de código~=fonte (\fullref{section:trabalhosRelacionados}),
espera~=se que existam diversos formatadores de código~=fonte (ou algoritmos de formatação),
capazes de lidar com os diferentes aspectos das linguagens de programação que se deseja formatar seu código~=fonte.
A simplicidade de configurações (como somente um número inteiro) poderia ser alterada e
propor~=se configurações que sejam mais elaboradas (complexas).
Permitindo que o usuário tenha maior controle sobre o processo de formatação de código~=fonte,
em conjunto com as gramáticas escritas para esta ferramenta.

Após estas breves comparações,
na próxima seção sugere~=se algumas ideias e
melhorias sobre o trabalho proposto.


\section{\lang{Future Works}{Trabalhos Futuros}}
\label{section:trabalhosFuturos}

\advisor{}{O autor desse trabalho sugere alguns trabalhos futuros em \citeonline{objectBeautifierFutureWorks,objectBeautifierChecklist}.
Antes que novos formatadores de código~=fonte sejam implementados,
estes pontos precisam ser revistos.
Ao realizar estas mudanças,
qualquer implementação já realizada para formatação será perdida devido ao número de alterações realizadas,
como em um efeito borboleta \cite{standardButterflyEffect}.
}

Caso exista,
o melhor trabalho futuro que pode ser feito é uma reinvenção do algoritmo de formação proposto (\fullref{section:softwareImplementationVisaoGeral}),
que permita que as gramáticas fornecidas pelos usuários possam ser melhor utilizadas nos algoritmos de formatação de código~=fonte.
Ou ainda,
uma nova proposta de metagramática que por algum motivo seja mais robusta e
simples de utilizar.
Enquanto nenhum nova proposta de algoritmo surge,
sugere~=se algumas melhorias sobre a implementação proposta neste trabalho.
\begin{enumerate}
\item Reduzir o uso de memória e
otimizar o desempenho em tempo de execução,
uma vez que os algoritmos e
estratégias adotas não levaram estes pontos em consideração;
\item Corrigir erros de interpretação da metalinguagem ou
da especificação da metagramática quando alguns operadores como ``\mintinline{text}|scope|'' que tem um uso opcional,
são omitidos (\fullref{section:AnalisadorSemantico});
\item Implementar operadores como ``\mintinline{text}|captures|'' e
``\mintinline{text}|set|'' para tornar o uso da metalinguagem mais fácil ou
melhorar o seu desempenho em casos de uso específicos \cite{sublimeTextSyntax};
\item Adicionar suporte à especificação de múltiplos escopos a um mesmo trecho de código \cite{vsCodeSyntaxHighlighthing},
definindo alguma estrutura de dados adequada,
capaz de permitir consultas e
aritméticas de escopos \cite{textMateScopeExclusion} com desempenho constante $\Theta(1)$.
Permitindo que estas operações possam ser utilizadas nos arquivos de configuração,
melhorando o controle do usuário sobre a formatação de código~=fonte em conjunto com a gramática especificada;
\item Melhorar a legibilidade e
facilitar a escrita das gramáticas,
removendo a necessidade de chaves de abertura ``\mintinline{text}|{|'' e
fechamento ``\mintinline{text}|}|'' de blocos (alterando a metagramática (\fullref{section:metalinguagemGrammar}),
fazendo a separação de blocos ser feita de acordo com a indentação como em linguagens como Python e
YAML;
\item Realizar a criação de uma nova estrutura de dados para representar o programa de entrada e
avaliar se esta nova estrutura de dados é capaz de substituir utilização do caractere ``\mintinline{text}|§|'' em conjunto com a classe padrão de \textit{string} da linguagem Python (aumentado a eficiência dos algoritmos de análise do programa de entrada a ser formatado (\fullref{section:desempenhoDoFormator}).
\item Implementar uma interface de linha de comando (CLI, \typeref{section:softwareImplementationVisaoGeral}) que:
\begin{inparaenum}[1)]
\item automaticamente faça o carregamento de todas as gramáticas definidas em um diretório especificado;
\item automaticamente faça o carregamento de todas as configurações definidas em outro diretório e
associe estas configurações com as gramáticas correspondentes;
\item automaticamente associe os conjuntos de gramáticas e
configurações com um programa de entrada passado pela linha de comando.
A separação dos diretórios de gramáticas e
configurações é necessário para que se possa aplicar diferentes coleções de configurações de acordo com a vontade do usuário.
\end{inparaenum}%
\item Implementar o carregamento automático de diferentes formatadores ou
algoritmos de formatação como \typeref{code:exemploMinimoDeFormatadorDeCodigo},
permitindo que eles trabalhem em conjunto.
Combinando diferentes formatadores e
suas configurações com as gramáticas implementadas pelos usuários.
\item Implementar plugins de integração com editores de texto mais utilizados como \citeonline{sublimeTextSyntax} e
\citeonline{vsCodeSyntaxHighlighthing}.
Esta integração seria equivalente a implementação de uma linha de comando (CLI),
mas com a diferença de que as funcionalidades da CLI estariam acessíveis de dentro dos editores de texto.
\item Implementar algoritmos que permitam a formatação dinâmica de código~=fonte,
i.e.,
enquanto o usuário está escrevendo o código~=fonte em um editor de texto,
o texto é automaticamente formatado na medida que ele é escrito.
\item Implementar algoritmos que permitam editores de texto editar o código~=fonte de acordo com as configurações de formatação do usuário,
enquanto estes mesmos arquivos são salvos no sistema de arquivos utilizando outras configurações,
diferentes das configurações de visualização do código~=fonte.
Tal característica seria útil para permitir que times de desenvolvimento possam trabalhar com diferentes configurações de formatação,
e ao mesmo tempo manter o histórico do código~=fonte em um padrão fixo de formatação (\fullref{chapter:firstChapterIntroduction}).
\item Um pouco fora do escopo deste trabalho,
mas ainda relacionado com os últimos itens seria permitir a tradução dinâmica de código~=fonte.
Nela,
o usuário seria capaz de editar um arquivo de uma linguagem como XML,
visualizado ele com um arquivo YAML.
Ou seja,
ao abrir um arquivo XML,
ele é dinamicamente convertido para XML ao ser visualizado no editor de texto.
Por fim,
ao salvar o arquivo,
ele é escrito novamente no sistema de arquivos com o seu formato original,
XML.
Tal característica seria útil porque algumas linguagem como XML podem ser difíceis de se entender,
enquanto ao trabalhar com um formato equivalente como YAML pode ser de mais fácil entendimento (\typeref{section:sourceCodeHighlighters,chapter:firstChapterIntroduction}).
\end{enumerate}%

Com certeza estas não são todas as melhorias ou
trabalhos futuros que podem ser feitos.
Mas espera~=se que elas já sejam o suficiente para despertar a curiosidade e
motivar a criação de novos trabalhos sobre formatadores de código~=fonte.

\advisor{}{Em relação aos formatadores gerados pelo gerador de formatadores,
eles precisaram ser completamente reescritos,
uma vez que as melhorias feitas no gerador de formatadores e
metalinguagem linguagem forem concluídas.
A implementação atual dos formatadores pode ser considerada nula,
uma vez que toda sua lógica de funcionamento é construída como um simples iteração descendente pela Árvore Sintática Abstrata gerada pelo Analisador Semântico.
}
