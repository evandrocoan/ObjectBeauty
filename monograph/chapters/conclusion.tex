

\chapter{\lang{Conclusion}{Conclusão}}
\label{chapter:conclusion}

\lang{%
    The difference from this proposal to remaining formatting tools,
    is the tradeoff between end\hyp{}users and developers responsibilities.
    Most tools rarely expose to end\hyp{}users their language syntax specification,
    in contrast,
    this proposal completely exposes the language to the end\hyp{}user as simple plain\hyp{}text,
    not requiring the tool to know any language syntax neither semantics.
    Moreover,
    with no syntax knowledge required,
    the tool be can used with any languages their user wishes to.

\begin{enumerate}[leftmargin=*]
    \item
        There are many different tools, sometimes paid, and difficult to
        complete. \cite{universalCodeFormatter};
    \item
        Many programming languages exist, so always having Beautifier
        software for each of them is very laborious
        \cite{universalCodeFormatter}. But the approach to a Universal
        Beautifier proposed in this work, would allow easily new languages to be
        added, being completely different from previous ones, or alike. And in
        case of similarities between them, it is enough to reuse their
        configuration structures already implemented;
    \item
        Looking for a Beautifier for each one of them because programmers
        currently work daily with several of these languages, and they are not
        similar. So you need to configure several beautifiers to do the
        formatting. This is a problem because only a few beautifiers are more
        complete, and every time you need to make a change in the formatting
        style, you must manually propagate the same change over several
        different program configuration files, which is bad because it takes the
        user a lot of time to learn how to handle many different types of
        settings \cite{universalIndentGUI};
    \item
        In the case of ideal Beautifier, a change in your styling is
        propagated to all languages. And if you want to leave some language out
        of it, you just need to remove it from the list on which the
        configuration block applies to, and `a)' leave it out so no change is
        applied to. Or `b)' create a new block including only the block within
        the desired settings.
\end{enumerate}
}{%
    Como esta ferramenta difere das demais já existentes?
    A diferença desta nova proposta de ferramenta de formatação de código~=fonte para as demais é a troca de responsabilidades entre usuários finais da ferramenta e
    os desenvolvedores desta ferramenta e
    das gramáticas para esses usuários.
    Formatadores de código~=fonte usualmente expõem as mudanças que podem ocorrer ao formatar o código~=fonte sem quebrar a suas regras sintáticas ou
    semânticas.

    A maior parte das ferramentas raramente permite que usuários finais tenham o controle total das mudanças no código~=fonte.
    \advisor{Utilizando}{Enquanto utilizando} a ferramenta desenvolvida neste trabalho,
    é possível escrever regras de formatação que quebrem a sintaxe e
    semântica da linguagem sendo formatada.
    Por exemplo,
    na linguagem ``Go'' \cite{programmingLanguageGolang},
    diferentemente de todas as demais linguagens,
    é um erro de sintaxe adicionar a chave ``\{'' de abertura de bloco em uma linha nova.

    Utilizando~=se as ferramentas usuais de formatação,
    fica impedido que configurações do usuário cause erros sintáticos ou semânticos código~=fonte da linguagem sendo formatada,
    a não ser em casos de \textit{bugs} na ferramenta.
    As ferramentas em geral tentam reconstruir a árvore de sintaxe da linguagem a ser formatada.
    Neste trabalho,
    o usuário final pode escolher entre simplesmente especificar a gramática da linguagem com o mínimo necessário para atingir somente as suas necessidades.
    Mas ao mesmo tempo,
    ele também pode realizar a especificação completa de toda a sintaxe da sua linguagem.

    Mesmo com a especificação completa da sintaxe da linguagem,
    ainda não será o suficiente para impedir quebras nos códigos~=fonte sendo formatados,
    pois a sintaxe da linguagem não cobre os seus aspectos semânticos.
    Neste caso,
    o usuário final precisará conhecer quais são as regras semânticas da linguagem na qual ele está realizando a formatação,
    e configurar o formatador de código~fonte de modo que ele não quebre nenhuma das regras semânticas da linguagem.
}

Em \citeonline{objectBeautifierFutureWorks},
pode ser encontrada a concepção inicial de implementação da ferramenta de formatação de código~=fonte deste trabalho.
Uma vez que este trabalho for publicado,
seu código~=fonte estará disponível.
Então,
seguindo as referências de \citeonline{objectBeautifierFutureWorks} será possível encontrar a especificação completa sobre última versão implementação de formatadores de código~=fonte com os requerimentos deste trabalho.


\section{\lang{Future Works}{Trabalhos Futuros}}

O autor desse trabalho sugere alguns trabalhos futuros \citeonline{objectBeautifierFutureWorks}.
Antes de novos formatadores de código~=fonte sejam implementados,
estes pontos precisam ser revistos.
Ao realizar estas mudanças,
qualquer implementação já realizada para formatação será perdida devido ao número de mudanças realizadas\advisor{.}{,
como em um efeito borboleta \cite{standardButterflyEffect}.%
} Mais especificamente,
sobre a metalinguagem e
gerador de formatadores criados,
sugerem~=se as seguintes alterações:
\begin{enumerate}
\item Adicionar quaisquer regras semânticas da metalinguagem que não foram adicionadas no analisador semântico;
\item Reduzir o uso de memória e
otimizar a performance em tempo de execução,
uma vez que os algoritmos e
estratégias adotas não levaram estes pontos em consideração;
\item Corrigir erros de interpretação da metalinguagem ou
da especificação da metagramática quando alguns operadores como ``scope'' que tem um uso opcional,
são omitidos;
\item Implementar operadores como ``captures'' e
``set'' para tornar o uso da metalinguagem mais fácil ou
melhorar a sua performance em casos de uso específicos;
\item Adicionar suporte à especificação de múltiplos escopos a um mesmo trecho de código \cite{vsCodeSyntaxHighlighthing},
definindo alguma estrutura de dados adequada,
capaz de permitir consultas e
aritméticas de escopos \cite{textMateScopeExclusion} com performance constante $\Theta(1)$;
\item Melhorar a legibilidade e
facilitar a escrita das gramáticas,
removendo a necessidade de chaves de abertura ``\{'' e
fechamento ``\}'' de blocos,
fazendo a separação de blocos ser feita de acordo com a indentação como em linguagens como Python e
YAML.
\end{enumerate}%

A atual estrutura de composição dos formatadores de código~=fonte não suporta que diversos formatadores realizem a formatação simultaneamente.
Somente um formatador,
que estende da classe ``AbstractFormatter'' pode estar em funcionamento ao mesmo tempo.
Entretanto,
este formatador recebe como parâmetro de sua função ``format\_text'',
o trecho de código~=fonte a ser formatado e
o escopo dele.
Com essas informações ele poderia em tese,
chamar diferentes formatadores mais especializados de acordo com o seu parâmetro escopo.

Em relação aos formatadores gerados pelo gerador de formatadores,
eles precisaram ser completamente reescritos,
uma vez que as melhorias feitas no gerador de formatadores e
metalinguagem linguagem forem concluídas.
A implementação atual dos formatadores pode ser considerada nula,
uma vez que toda sua lógica de funcionamento é construída como um simples iteração descendente pela Árvore de Sintaxe Abstrata gerada pelo analisador semântico.

