

\chapter{\lang{Introduction}{Introdução}}
\label{firstChapterIntroduction}

\advisor{}{%
    \lang{%
        The work first part will be based on research in articles,
        books, theses, dissertations, trusted authors websites,
        and through new demonstrated evidences based on arguments in the monograph evolution.
        Also,
        present results after building a new tool which proposes a solution for the problems presented and
        detailed.
    }{%
        A \hyperref[primeira_parte]{primeira parte} deste trabalho será baseado em artigos,
        livros, outras dissertações, sites confiáveis e
        por novas evidências demonstradas no desenvolvimento deste trabalho.
    }%
    \lang{%
        In this proposal last chapter which lies on the part called `\nameref{segunda_parte}',
        which holds the implementation of a tool for code `Beautifying'.
    }{%
        E finalmente,
        na \hyperref[segunda_parte]{segunda parte} deste trabalho,
        será apresentada a sugestão e
        implementação de uma ferramenta.
    }
}


\advisor{}{\section{\lang{Context}{Contextualização}}}

\lang{%
    Within this work\s area,
    we need to also think long and
    hard about how to share the programming code of the programmers among you.
    Now,
    the problem of human diversity,
    like all big scientific questions -- how do you explain something like that -- It can be broken down into sub~=questions.
    It happens many times,
    which is a good practice for a `Programmer A',
    is not the same to another `Programmer B'.
    For example,
    imagine some code where a programmer decided to put before each `if' statement,
    a blank line.
    It is therefore expected that whenever we see a blank line we can potentially find a matching `if',
    which can be considered a quite useful pattern matching as empty line may call better your attention \cite{aPrettyGoodFormatting}.
}{%
    \advisor{}{
    Programação de computadores usualmente não é uma tarefa solitária.
    Muitos projetos podem sempre ser escritos pela mesma pessoa durante toda a vida desse projeto mas,
    o quão grande pode ser um projeto que uma pessoa pode fazer sozinha?
    Poderia uma pessoa escrever sozinha todo o sistema de controle de tráfego aéreo dos Estados Unidos?
    Uma vez que precisa~=se escrever sistemas computacionais maiores,
    % TODO: cite reference to `escrever sistemas computacionais maiores`
    tende~=se a colocar vários programadores,
    engenheiros de software, gerentes de projeto, etc,
    para que se possa escrever o sistema computacional requerido dentro do prazo que dado projeto computacional possui.
    }

    Com a criação de sistemas computacionais cada vez mais complexos,
    torna~=se um desafio ter,
    em um único projeto,
    diversos programadores,
    pois cada um possui características pessoais distintas,
    e entende melhor o código~=fonte escrito de acordo com seu costume,
    já que previamente sabe como localizar~=se e
    entender melhor os seus elementos \cite{howProgrammersRead}.

    \lang{%
        Questions like ``What are good programming practices?'' Or ``Why are these practices are good?''Are not easy to answer.
        But each programmer learns to write their codes in a certain way,
        with certain features like using 4 or
        8 spaces to indent lines,
        always leave a blank line before each control structure as if or
        for statements,
        and alike rules \cite{naturalCodingConventions}.
    }{%
        \advisor{}{%
            Perguntas como ``O quê são boas práticas de programação'' não são fáceis de responder.
        }%
        \advisor{%
            Por exemplo,
            quanto a indentação,
            há programadores que preferem usar 2,
            4, ou 8 espaços; quanto legibilidade,
            há programadores que preferem o uso de linhas em branco antes de estruturas de controle%
        }{%
            Cada programador aprende a escrever seus códigos~=fonte de uma determinada maneira,
            seja utilizando 2, 4,
            ou 8 espaços para criar blocos de indentação,
            ou sempre deixar uma linha em branco antes de estruturas de controle como if\s,
            while\s, etc%
        } \cite{naturalCodingConventions}.%
    }
    Quando diferentes programadores cooperam em grandes projetos,
    \advisor{como unir pessoas com experiências e
        preferências diferentes?%
    }{%
    como essas pessoas todas poderiam trabalhar juntas,
    mesmo elas não tendo as mesmas experiências?} Uma barreira adicional \advisor{ao}{para cada um desses programadores no} desenvolvimento do projeto será concluir um trabalho com diferentes colegas de equipe,
    dado que a tarefa de codificação é complexa e
    as etapas de projeto podem ser realizadas de diferentes formas.

    Uma dessas diferenças é a maneira na qual cada programador organiza a estrutura do código~=fonte de acordo com seu estilo de formatação \cite{transformationForDomainSpecificOptimisation}.
    Por exemplo,
    imagine que um certo ``Programador A'' tem o costume de deixar uma linha em branco antes de cada estrutura de controle\advisor{.}{
    do tipo ``if'', ``for'',
    etc.
    } Já um outro ``Programador B'',
    possui o costume oposto,
    ele jamais deixa uma linha em branco antes dessas estruturas de controle.
    Então,
    o quê pode acontecer de errado quando ambos os programadores ``A'' e
    ``B'' trabalham num mesmo projeto?

    \advisor{%
    O problema mais provável é que o código~=fonte esteja escrito em dois estilos:
    do Programador A e
    B.%
    }{%
    Existem algumas possibilidades,
    uma delas poderia ser que a metade do código~=fonte escrita pelo ``Programador A'' estará de um jeito.
    Já a outra metade escrita pelo ``Programador B'' estará de outro.%
    } Então,
    que tipos de problema isso poderia causar?
    Uma vez que o código~=fonte não está mais todo escrito sobre um mesmo padrão,
    \advisor{%
    pode haver uma dificuldade na leitura do código~=fonte como algo homogêneo.
    Os próprios Programadores A e
    B, autores do código~=fonte, teriam dificuldades,
    pois o código~=fonte segue um estilo diferente ao que A e
    B estão habituados.
    }{%
    certas heurísticas tem sua taxa de acerto reduzida ao fazer o reconhecimento dos padrões.
    }%
    Um exemplo de padrão que estaria prejudicado seria o de rapidamente identificar onde pode estar uma estrutura de controle,\advisor{}{
    como ``if'' ou
    ``for''} de acordo com a presença ou
    não de uma linha em branco antes dela,
    já que a presença de uma linha em branco faz um destacamento maior\advisor{.}{
    sendo facilmente reconhecida como um separador de blocos de código~=fonte \cite{aPrettyGoodFormatting}.}
}

\lang{%
    But again this is something heavily dependent of what each one learning through their life time.
    Imagine another programmer do not liked this rule,
    and when he was writing your code involving an ``if'',
    he did not put such blank line another programmer is expecting.
    So when the first programmer start reading its the code and
    look for ``if'',
    he will be expecting for blank lines before its if\s.
    But will lose some time searching until realize another programmer does not put them,
    or perhaps he forgot to insert them \cite{quantifyingProgramComprehension}.
}{%
    \advisor{}{E por mais uma vez,
        estas heurísticas são fortemente dependentes do aprendizado de cada programador durante sua vida.
        Imagine um segundo programador que não esta habituado com a heurística de outro,
        e toda vez que ele for ler o código~=fonte deste terceiro programador,
        ela estará perdido para poder se localizar rapidamente dentro do código~=fonte.
        E portanto,
        o que isso significa?
        Que ele terá que atentamente ler o código~=fonte escrito por este terceiro programador,
        uma vez que a sua organização difere dos padrões no qual ele sabe como rapidamente se localizar \cite{quantifyingProgramComprehension}.
    }
}

\advisor{}{%
    \lang{%
        These differences are due to the diversity of ways we learn programming,
        i.e.,
        to the ways we are used to doing coding,
        as much as the abilities and
        objectives of every programmer developed.
        Hence,
        nowadays it becomes a big problem because we increasingly need more and
        more programmers working together developing several and
        diverse computing systems.
        Where the latter is due to the fact of the complexity of computer systems growing increasingly,
        therefore over requiring programmers working and
        sharing their codes and
        ideas \cite{howProgrammersRead}.
    }{%
        As diferenças entres os diversos estilos de programação entre os programadores deve~=se à diversos fatores:
        \begin{enumerate}
            \item Alguns programadores simplesmente fazem de um determinado jeito porque foi assim que eles aprenderam de seus tutores ou
            possuem determinado estilo devido as suas experiências iniciais e
            nunca preocuparam~=se em questionar se poderia ser feito de outra maneira.
            Um caso onde isso pode acontecer é devido ao cansaço que algumas linguagens de programação como \latex causam por sua sintaxe incomum e
            extraordinária.
            Uma vez que você já está cansado de ver tantos erros,
            você simplesmente para de questionar como o texto poderia ser formado e
            aceita o que você encontra escrito e
            funcionando como parte da sintaxe da linguagem;

            \item Outros podem ter determinadas características na formatação da escrita
            de seus códigos~=fonte devido a algum aspecto emocional ou físico.
            Emocionalmente o programador pode ``não gostar'' de alguma característica porque
            \advisor{}{sofreu algum trauma ou} simplesmente pode estar muito acostumado a ter ter visualmente todos os elementos muito próximos um dos outros na tela.
            Assim,
            mesmo tal característica não sendo nada fácil para que outras pessoas entendam o código~=fonte,
            ela pode ser muito fácil de ser compreendida pelo próprio programador que a escreveu,
            já que o mesmo vem a muitos anos habituado a realizar a escrita de seus códigos~=fonte desta determinada forma,
            portanto é muito hábil com a mesma e
            rapidamente consegue entender o que escreve;

            \item Uma característica física que pode determinar a
            formatação de código~=fonte de alguém pode ser um teclado defeituoso.
            Caso determinada tecla não funcione adequadamente e
            a pessoa não se dê ao trabalho de comprar um teclado novo,
            a pessoa pode então adquirir um novo hábito,
            e uma vez que ela aprenda este habito,
            ela provavelmente continuará com ele mesmo depois de comprar um teclado novo.
            Por exemplo,
            suponha que a sua tecla ``TAB'' não funcione.
            Assim,
            ao invés de somente pressionar ``TAB'' uma vez para indentar seu código~=fonte,
            você ganha habito de pressionar a tecla de espaços 4 vezes.
            Portanto,
            nasce um motivo para alguém utilizar espaços ao invés ``TAB\s'' para realizar a indentação de seu código~=fonte.
        \end{enumerate}
    }
}

\lang{%
    Moreover besides only worrying about how the code is displayed on their computer screen,
    we need to worry about on how it will be saved in the file system on its `plain~=text' mode.
    Since for code sharing,
    it is vital for you to use a versioning control system \cite{whyVersionControlIsCritical} which enable project manager\s and
    programmers themselves,
    take control of their code changes \cite{redesignOfGit}.
    It does allow to easily perform the tracking of code changes \cite{gettingProductive} and
    allow you to better understand what each programmer is doing every time he formalizes a change in the code through a `commit',
    as in `git' systems for example \cite{usingSourceControl}.
}{%
    Indo além de como programadores leem código~=fonte enquanto estão escrevendo o código~=fonte,
    também tem que se preocupar como o código~=fonte será salvo no sistema de arquivos,
    em seu formato de texto simples.
    Já que para compartilhar código~=fonte e
    trabalhar em times de forma eficiente,
    é essencial utilizar um sistema de versionamento \cite{whyVersionControlIsCritical}.
    \advisor{%
    Tal ferramenta deve permitir rastrear mudanças \cite{gettingProductive},
    habilitando que se entenda melhor as atividades de cada programador \cite{usingSourceControl}.
    }{%
    Tal ferramenta deve permitir facilmente realizar o rastreamento das mudanças \cite{gettingProductive} e
    assim,
    permitir que entenda~=se melhor o que cada programador está fazendo,
    todas as vezes que eles formalizam uma nova alteração no código~=fonte,
    por exemplo,
    através de uma ``commit'' como conhecidas em sistemas \textit{git} \cite{usingSourceControl}.
    }%
    Permitindo que gerentes de projetos e
    os próprios programadores,
    tenham o controle das (e de suas) mudanças no código~=fonte \cite{redesignOfGit}.
}

\begin{citacao}
    Há duas razões principais para impor um formato de código~=fonte único em um projeto.
    A primeira razão tem a ver com o controle de versão:
    quando todo mundo formata o código~=fonte de forma idêntica,
    todas as alterações nos arquivos têm a garantia de terem algum significado.
    Nada mais de coisas como adicionar ou
    remover um espaço aleatoriamente,
    muito menos formatar um arquivo inteiro como um ``efeito colateral'' de alterar apenas uma linha ou
    duas \cite[tradução nossa]{Geukens}\footnote{
    \englishword{%
    I'd say there are two main reasons to enforce a single code format in a project.
    First has to do with version control:
    with everybody formatting the code identically,
    all changes in the files are guaranteed to be meaningful.
    No more just adding or
    removing a space here or
    there,
    let alone reformatting an entire file as a ``side effect'' of actually changing just a line or
    two.
    }}.
\end{citacao}

\lang{%
    That is because while working with a versioning system like `git',
    we need to keep the code among a single style or
    which we may call a `good practice' set as standard for everybody,
    due the fact of letting each programmer to write as he pleases,
    there will be plenty of noise on the code review and
    we are figuring out what actually each programmer did \cite{quitDiffCalculating}.
    Hence,
    if every programmer re~=writes the history making changes like inserting new lines before each if,
    we end up with too much noise and
    focus of a versioning system is to look at only those changes that are significant to the code,
    such as the creation of new functions and
    not the addition of new blank lines \cite{findingRegressionsInProjects}.
}{%
    \advisor{
        Ao trabalhar com um sistema de versionamento como \textit{git},
        recomenda~=se manter todo o código~=fonte sobre um único estilo,
        devido a problemas que podem ser gerados ao permitir que cada programador escreva códigos~=fonte livremente em seu estilo.
        Ao permitir que cada programador escreva códigos~=fonte livremente em seu estilo,
        isso pode gerar problemas como ruídos de formatação,
        dificultando a revisão do código~=fonte,
        uma vez que cada programador precisa entender diferentes estilos de formatação aplicados em um único arquivo ou
        projeto \cite{quitDiffCalculating}.

        Caso todos os programadores decidam re~=escrever o histórico,
        fazendo mudanças insignificantes como inserindo novas linhas antes de cada ``if'',
        os programadores precisam dedicar tempo de projeto para formatar o código,
        o que poderia ser evitado e
        utilizado para escrever código~=fonte.
        No fim,
        o histórico \textit{git} irá conter ruídos desnecessários.
        Um bom uso de um sistema de versionamento é somente conter mudanças se sejam significativas,
        como criações de novas funções,
        correção de \textit{bugs},
        etc \cite{findingRegressionsInProjects}.
        Ferramentas de versionamento auxiliam na manutenção,
        rastreabilidade de responsabilidades e
        alterações,
        mas não apóiam na manutenção de um estilo de formatação único para uma equipe de programadores.
    }{
        Segue~=se estas conclusões devido aos problemas gerados ao permitir que cada programador escreva como lhe agrada melhor.
        Caso cada um escreva como bem entende,
        irá existir ruídos de formatação em abundância espalhados por tudo o código~=fonte,
        o quê complicará a revisão de código~=fonte,
        dificultando entender o que cada programador fez \cite{quitDiffCalculating}.

        Portando,
        caso todos os programadores decidam re~=escrever o histórico,
        fazendo mudanças insignificantes como inserindo novas linhas antes de cada ``if'':
    \begin{enumerate}
        \item Eles irão desperdiçar um tempo que eles poderiam estar utilizando para escrever código~=fonte;
        \item O histórico \textit{git} irá conter ruídos desnecessários,
        pois o foco de um sistema de versionamento são conter mudanças se sejam significantes,
        como criações de novas funções,
        correção de \textit{bugs},
        etc \cite{findingRegressionsInProjects}.
    \end{enumerate}
    }%
}

\advisor{}{%
    \lang{%
        Talking about the last ideia pointed out,
        we could also think about an approach to creating a new version control system which focuses only on significant changes to the code,
        while reviewing code changes.
        However,
        this approach could not be ideal,
        as for example,
        it would allow programmers to start tedious wars of unproductive code adjustments.
        For example,
        imagine how it would be for your every day and
        have to go through your code re~=adding new lines before each one of your beloved if\s,
        just because some night shift programmer had just removed them \cite{whoWroteThisCrap}?
    }{%
        Poderia~=se também pensar em uma abordagem para criar um novo sistema de controle de versão,
        que foca apenas mudanças significativas no código~=fonte enquanto faz~=se a revisão das mudanças no código~=fonte.
        No entanto,
        essa abordagem poderia não ser ideal,
        pois, por exemplo,
        permitiria que os programadores iniciassem guerras tediosas de ajustes de código~=fonte improdutivos.
        Por exemplo,
        imagine como seria se todo os dias você tivesse que passar pelo código~=fonte re~=adicionando novas linhas antes de cada um dos seus amados if\s,
        só porque algum programador do turno da noite tinha acabado de removê~=los \cite{whoWroteThisCrap}?
    }
}

\lang{%
    But entering the universe of good practices,
    there are many things for discoursing.
    Nonetheless,
    in this work is presented the implementation of tool called `Object Beautifier',
    which specifically dedicates on how to perform the best layout/display of programming code on the computer screen,
    so that maximize and
    facilitate the understanding of same \cite{automaticSynthesis}.
    Therefore,
    allowing the programmer to disperse more time and
    efforts thinking about its coding algorithms problem,
    other than trying to decipher the information that is presented to it on the screen through infinit different code layouts \cite{usingVersionControlData}.
}{%
    Assim,
    este trabalho tem por objetivo estudar e
    desenvolver uma ferramenta de reorganização do código~=fonte nos aspectos estruturais\slash{}sintáticos.
    Estas ferramentas também são conhecidas como ``\textit{Source Code Beautifiers}'' ou
    ``Formatadores de Código''.
    Com isso,
    espera~=se que o desenvolvimento de códigos~=fonte demande menos trabalho,
    pois o desenvolvedor pode focar mais seus esforços pensando sobre o problema que está sendo resolvido,
    ao contrário de tentar decifrar o que está escrito \advisor{em estilo incomum a sua experiência%
        }{em sua frente por meio de layouts extravagantes ou incomuns%
        } \cite{usingVersionControlData}.
}


\section{Motivação}

Ter que aprender e
configurar muitas ferramentas de formatação de código~=fonte é um tarefa cansativa (\fullref{formatadores_de_codigo}).
Mais ainda,
é escrever uma nova ferramenta de formatação de código~=fonte para cada nova linguagem de programação que surgir.
Um programador da linguagem C++,
pode utilizar formatador de código~=fonte que oferece até 600 opções de configuração.
Mas este programador,
ao migrar para uma linguagem como Python,
pode somente encontrar um formatador que suporta no máximo 20 opções de configuração.
O que pode tornar frustrante migrar de uma linguagem de programação para outra,
pela perda de controle da ferramenta de formatação de código~=fonte.


\section{\lang{Goals}{Objetivos}}

\advisor{%
    Esta seção apresenta sucintamente os objetivos desse trabalho,
    divididos em Objetivo Geral e
    Objetivos Específicos.
}{%
    \lang{%
        Beforehand due the scope limitation for a Graduation Thesis,
        we should only think about a basic, simple,
        and yet reusable core of features.
    }{%
        Devido ao trabalho tratar~=se de uma tese de graduação,
        limita~=se seu escopo de trabalho a criação de um núcleo básico de recursos.
    }%
    \lang{%
    \begin{enumerate}
        \item
            A Software Product with a great Object Orientation and
            possibilities of extension of features,
            decent research on the state of the art;
        \item
            Ranking all code formatting classes (beautifying) applicable.
            Including a study on what does is source beautifying,
            how to do such and
            why;
        \item
            Establish relationships between good programming practices and
            efficiency in programming,
            in addition to a new tool to support programmers in order to automate the long and
            diverse programming process in teams of developers with different programming `best practices';
        \item
            Define,
            determine and
            classify which one are good programming practices and
            perform an in~=depth study on the good practices on visual layout area,
            also known as code `Beautifying';
        \item
            The definition of a flow pattern of development allowing teams of developers with different programming best practices,
            to work without intervene with each other up to start wars of `best good practices';
        \item
            Discourse on the variety of existing tools for the support of good programming practices,
            with a comparative analysis between them,
            determining their weaknesses and
            strengths.
    \end{enumerate}
    }{%
        Enumerar e
        explicar as ferramentas de formatação de código~=fonte e
        realizar o desenvolvimento de uma nova ferramenta de formatação de código~=fonte que seja extensível por gramáticas fornecidas pelos usuários.
    }
}%

\subsection{Objetivo Geral}

Desenvolver um formatador de código~=fonte,
extensível a diversas linguagem de programação por meio de gramáticas.


\subsection{Objetivos Específicos}

\begin{enumerate}
    \item Analisar a fundamentação teórica de linguagens formais e
    compiladores;
    \item Analisar o estado da arte das ferramentas que fazem formatação de código~=fonte;
    \lang{%
        \item Propose a unique tool that allowing several and distinct
        programming `best practices' being implemented in several programming languages,
        which can be configured and
        set accordingly to their wishes,
        from a single software working well behaved across all programming languages;
    }{%
        \item A partir dos pontos fracos e
        fortes do estado da arte de formatadores,
        propor uma nova ferramenta de formatação de código~=fonte.
    }
    \lang{%
        \item Moreover,
        explain the differences for other softwares and
        the benefits of a unique tool,
        instead of several heavily different ones.
        From this point,
        a sketch is presented on the problem,
        solutions,
        information as for why to want make such software,
        or even why do we want to beautifying things:
    }{%
        \item Avaliar como esta nova ferramenta difere das demais já existentes.
    }
\end{enumerate}


\section{Método de Pesquisa}

Foram realizados pesquisas em artigos científicos,
livros e
sites para obter~=se referências e
resolver dúvidas pendentes sobre quaisquer conteúdos.
Foi utilizado como guia as notas de aula retiradas das disciplinas relacionadas a construção deste trabalho.
Como palavras chave de pesquisa para encontrar trabalhos relacionados,
foi utilizado termos como:
\begin{inparaenum}[1)]
\item \textit{pretty~=printing};
\item \textit{beautifying} e;
\item \textit{source code formatting}.
\end{inparaenum}%
Estes termos foram utilizados em sites como:
\begin{inparaenum}[1)]
\item \url{https://dl.acm.org};
\item \url{https://ieeexplore.ieee.org} e;
\item \url{https://arxiv.org/}.
\end{inparaenum}%

Foi escolhido explicar sobre um formatador de código~=fonte configurável por arquivos de texto e
outro configurável por uma interface gráfica com o usuário porque estes dois tipos de exemplo definem bem toda a classe de formatadores.
Isto é,
não existem grandes diferenças de uso e
implementação entres estes dois formatadores e
os demais.

Por fim,
é proposto um novo formatador de código~=fonte configurável por arquivos de texto e
extensível para novas linguagem de programação através da especificação de suas gramáticas,
utilizando o Analisador Lark (\typeref{software_implementation}).
Para que as gramáticas de novas linguagens de programação possam ser interpretadas,
também foi proposto uma nova metagramática \cite{theUseOfMetaRules}.
Esta nova metalinguagem \cite{compilersCompilerMetaLanguage} é então utilizada pela nova ferramenta de formatação para realizar as alterações nos códigos~=fonte escolhidos pelo usuário.
Para construção desta ferramenta,
foi utilizado a linguagem Python e
testes de unidade e
integração \cite{continuousIntegration}.


\section{Estruturação do Texto}

A criação deste trabalho dividi~=se em três áreas distintas.
No \typeref{fundamentacaoTeorica},
é realizado uma fundamentação teórica sobre os conceitos necessários para desenvolvimento de compiladores e
especificação de gramáticas.
No \typeref{source_code_beautifiers},
é explicado sobre dois tipos distintos de formatadores de código~=fonte.
Um formatador de código~=fonte configurável por arquivos de texto e
outro configurável por uma interface gráfica com o usuário.
No \typeref{software_implementation},
é apresentado a proposta e
implementação de uma nova ferramenta de formatação de código~=fonte.
Por fim,
no \typeref{chapter:conclusion},
é apresentado quais serão os desafios e
trabalhos futuros que podem ser feitos sobre esta nova ferramenta,
e como ela difere das demais ferramentas de formatação de código~=fonte.
No \typeref{manualDoFormatadorDeCodigo},
é apresentado como utilizar a implementação realizado neste trabalho,
seja para adicionar cores ou
formatar código~=fonte.
