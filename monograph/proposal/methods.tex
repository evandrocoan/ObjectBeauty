


\section{Método de pesquisa}

    A vantagem nesta abordagem é não ter a necessidade de ter-se conhecimento da sintaxe das linguagens
    de programação que se irão fazer o parsing. Isso porque trataremos elas como texto comum, e será
    o usuário final que fará a configuração das transformações que serão aplicados no texto, dando
    liberdade de facilmente se configurar várias linguagens de programação, aproveitando o fato de que
    muitas deles compartilham estruturas semelhantes senão idênticas.

    A literatura/programas atuais são dependentes de linguagem de programação. Minha proposta é fazer este
    processo independente de linguagem, mas de dialetos como este exemplo tirado do PDF em anexo a este e-mail
    `Initial check list tasks to do.pdf':

    \begin{lstlisting}[style=yaml_style]
    ---
    key: value
    map:
        key1: "foo:bar"
        key2: value2
    list:
      - element1
      - element2
    # This is a ção vaca comment
    listOfMaps:
      - key1: value1a
        key2: value1b
      - key1: value2a
        key2: value2b
    ---

    \end{lstlisting}
    // This is the name used to reference this scope around the settings files.
    Scope Name:
    %c++_like_block_comment

    // This set on which languages this block should be included. Setting it to empty will allow
    // it to be parsed for any languages.
    Language Inclusion:
    Java, C++, Pawn

    // Defines a expression which will map the beginning of a exclusion block. Example, `/\*\*`
    Scope Start:
    /**

    // Defines a expression which will map the ending of a exclusion block. Example, `\*/`
    Scope End:
    \*


    \vspace*{-4mm}
    A abordagem acima é uma abordagem ingênua, portanto somente brevemente ilustrativa. O real motor
    para o software é baseado em expressões regulares e um pilha de contextos. Esta ideia foi
    inicialmente desenvolvida pelo editor de texto `Sublime Text' \cite{Skinner}. Este editor
    utiliza essa estrutura de blocos para fazer a sintaxe highlighting do códigos das linguagens
    através de expressões regulares alocação de contextos/escopos. Essa mesma abordagem pode ser
    utilizada pelo usuário para definir em quais regiões uma Máquina de Turing (linguagens C++/Rust)
    devem fazer/propor as alterações no código.

    Os pontos positivos dessa abordagem para um formatador de código são a reusabilidade de
    componentes entre as linguagens pelo usuário final da aplicação ao invés do programador, o que
    torna este software muito mais genérico e abre a possibilidades de maior sucesso para a criação
    definitiva de um formatador Universal de códigos das linguagens de programação, quaisquer sejam
    elas. Por exemplo, `if/for/while''s em linguagens de programação como C++ e Java são da mesma
    estrutura. Assim temos que escrever somente uma vez a especificação para um componente da
    linguagem sem recorrer a programação de do código do programa. Isso tem a vantagem de por der
    ser configurado pelo usuário final ao invés do programador, assim fica mais simples de
    configurar e expandir o conjunto de linguagens disponíveis ao processamento/beautifying.






