

% The \phantomsection command is needed to create a link to a place in the document that is not a
% figure, equation, table, section, subsection, chapter, etc.
%
% When do I need to invoke \phantomsection?
% https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection
\phantomsection


% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{\lang{References' Abstracts}{Resumos das Referências}}


\begin{englishtext}
\begin{enumerate}

    \item \textbf{Study and Creation of a Structured Code Editor}: Virtually all
    of the code editors for business use in general\hyp{}purpose languages are
    oriented to lines and characters. The alternative, editors working directly
    with the syntactic tree, has received most attention in this area, aiming to
    have important advantages, such as automatic control of the structure and
    greater efficiency in the script. The purpose of this paper is to study
    these alternating active editors, called structured editors or syntax-driven
    editors, comparing them with traditional editors. Once the advantages and
    disadvantages have been raised, a structured editor will be developed that
    best fits in with this medium. This work first provides for an in-depth
    study of these structured editors, in the context of programming in general
    or non-general purpose languages. Previous efforts in this area will be
    sought, assessing their impact, lessons learned and limitations encountered.
    In a second moment these lessons will be used for the development of a
    proprietary, fully structured or hybrid editor, in order to increase the
    efficiency of the programmer. Preferably this editor will be prepared for a
    standard general purpose language and will be able to edit actual programs.
    This work aimed to better understand the principles behind structured
    editors, seeking information on their effectiveness, advantages,
    disadvantages and factors involved in their lack of adoption. It is also
    envisaged the construction of a functional structured editor, capable of
    being used on a daily basis, that makes better use of these advantages
    \cite{structuredEditorStudy}.

    \item \textbf{The Guide KOMA - Script}: KOMA-Script  is very complex. This
    is evidenced by the fact that it consists of not only a single class or a
    single package, but a bundle of many classes and packages. Although the
    classes are designed as a counterpart to the standard classes, that does not
    necessarily mean that they only have the commands, environments, and setting
    of the standard classes or imitate their appearance. The capabilities of
    KOMA-Script surpass the capabilities of the standard classes considerably.
    Some of them are to be regarded as a supplement to the basic skills of the
    LATEX kernel \cite{komaScrguien}.

    \item \textbf{Death to the Space Infidels!}: Ah, spring. What a wonderful time of
    year. A time when young programmers' minds turn to thoughts of ... never
    ending last-man-standing filibuster arguments about code formatting.
    Naturally. And there is no argument more evergreen than the timeless debate
    between tabs and spaces \cite{Atwood}.

    \item \textbf{Is imposing the same code format for all developers a good
    idea?}: We are considering to impose a single standard code format in our
    project (auto format with save actions in Eclipse). The reason is that
    currently there is a big difference in the code formats used by several
    (>10) developers which makes it harder for one developer to work on the code
    of another developer. The same Java file sometimes uses 3 different formats
    \cite{Geukens}.

    \item \textbf{Powerful code indenter front-end, UniversalIndentGUI}: Ever
    concerned about how your code looks like? Ever heard of different indenting
    styles, for example K\&R? Ever received code from someone else who didn't
    care about code formatting? Ever tried to configure a code indenter to
    convert such code to your coding style? Ever got bored by that tedious
    "changing a parameter"-"call the indeter"-"try and error" procedure? Help is
    close to you. UniversalIndentGUI offers a live preview for setting the
    parameters of nearly any indenter. You change the value of a parameter and
    directly see how your reformatted code will look like. Save your beauty
    looking code or create an anywhere usable batch/shell script to reformat
    whole directories or just one file even out of the editor of your choice
    that supports external tool calls.

    \item \textbf{SUBLIME TEXT 3 DOCUMENTATION, Syntax Definitions}: Sublime
    Text can use both .sublime-syntax and .tmLanguage files for syntax
    highlighting. This document describes .sublime-syntax files. Sublime Syntax
    files are YAML files with a small header, followed by a list of contexts.
    Each context has a list of patterns that describe how to highlight text in
    that context, and how to change the current text \cite{Skinner}.

    \item \textbf{Towards a Universal Code Formatter through Machine Learning}:
    There are many declarative frameworks that allow us to implement code
    formatters relatively easily for any specific language, but constructing
    them is cumbersome. The first problem is that “everybody” wants to format
    their code differently, leading to either many formatter variants or a
    ridiculous number of configuration options. Second, the size of each
    implementation scales with a language’s grammar size, leading to hundreds of
    rules. In this paper, we solve the formatter construction problem using a
    novel approach, one that automatically derives formatters for any given
    language without intervention from a language expert. We introduce a code
    formatter called CODEB UFF that uses machine learning to abstract formatting
    rules from a representative corpus, using a carefully designed feature set.
    Our experiments on Java, SQL, and ANTLR grammars show that CODEB UFF is
    efficient, has excellent accuracy, and is grammar invariant for a given
    language. It also generalizes to a 4th language tested during manuscript
    preparation \cite{universalCodeFormatter}.

    \item \textbf{An industrial application of context-sensitive formatting}:
    Automated formatting is an important technique for the software maintainer.
    It is either applied separately to improve the readability of source code,
    or as part of a source code transformation tool chain. In this paper we
    report on the application of generic tools for constructing formatters. In
    an industrial setting automated formatters need to be tailored to the
    requirements of the customer. The (legacy) programming language or dialect
    and the corporate formatting conventions are specific and non-negotiable.
    Can generic formatting tools deal with such unexpected requirements? Driven
    by an industrial case of 78 thousand lines of Cobol code, several
    limitations in existing formatting technology have been addressed. We
    improved its flexibility by replacing a generative phase by a generic tool,
    and we added a little expressiveness to the formatting backend. Most
    importantly, we employed a multi-stage formatting architecture that can cope
    with any kind of formatting convention using more computational power
    \cite{industrialApplication}.

    \item \textbf{Program indentation and comprehensibility}: The consensus in the
    programming community is that indentation aids program comprehension,
    although many studies do not back this up. We tested program comprehension
    on a Pascal program. Two styles of indentation were used -- blocked and
    non-blocked -- in addition to four passible levels of indentation
    (0, 2, 4, 6 spaces). Both experienced and novice subjects were used.
    Although the blocking style made no difference, the level of indentation had
    a significant effect on program comprehension. (2--4 spaces had the highest
    mean score for program comprehension.) We recommend that a moderate level
    of indentation be used to increase program comprehension and user
    satisfaction \cite{programIndentation}.

    \item \textbf{A Language Independent Framework for Context-sensitive
    Formatting}: Automated formatting is an important technique for the software
    maintainer. It is either applied separately to improve the readability of
    source code, or as part of a source code transformation tool chain. In this
    paper we report on the application of generic tools for constructing
    formatters. In an industrial setting automated formatters need to be
    tailored to the requirements of the customer. The (legacy) programming
    language or dialect and the corporate formatting conventions are specific
    and non-negotiable. Can generic formatting tools deal with such unexpected
    requirements? Driven by an industrial case of nearly 80 thousand lines of
    Cobol code, several limitations in existing formatting technology have been
    addressed. We improved its flexibility by replacing a generative phase by a
    generic tool, and we added a little expressiveness to the formatting back
    end. Most importantly, we employed a multi-stage formatting framework that
    can cope with any kind of formatting convention using more computational
    power \cite{independentFramework}.

    \item \textbf{An architecture for context-sensitive formatting}: We
    developed an architecture for context-sensitive formatting of source code.
    The architecture was implemented and applied in an industrial formatting
    case \cite{architectureFormatting}.

    \item \textbf{Pretty-printing for software reengineering}: Automatic
    software reengineerings change or repair existing software systems. They are
    usually tailor-made for a specific customer and language dependent.
    Maintaining similar reengineerings for multiple customers and different
    language dialects might therefore soon become problematic unless advanced
    language technology is being used. Generic pretty-printing is part of such
    technology and is the subject of this paper. We discuss specific
    pretty-print aspects of software reengineering such as fulfilling
    customer-specific format conventions, preserving existing layout, and
    producing multiple output formats. In addition, we describe pretty-print
    techniques that help to reduce maintenance effort of tailor-made
    reengineerings supporting multiple language dialects. Applications, such as
    COBOL reengineering and SDL documentation generation show that our
    techniques, implemented in the generic pretty-printer GPP, are feasible
    \cite{prettyPrinting}.

    \item \textbf{Automated Mass Maintenance of Software Assets}: This is a
    research summary of a PhD project in the area of massive software
    maintenance automation. We explain the context, approach, and contributions
    \cite{massMaintenance}.

    \item \textbf{Towards automated modification of legacy assets}: In this
    paper we argue that there is a necessity for automating modifications to
    legacy assets. We propose a five layered process for the introduction and
    employment of tool support that enables automated modification to entire
    legacy systems. Furthermore, we elaborately discuss each layer on a
    conceptual level, and we make appropriate references to sources where
    technical contributions supporting that particular layer can be found. We
    sketch the perspective that more and more people working in the software
    engineering area will be contributing to working on existing systems and/or
    tools to support such work. \cite{legacyAssets}

    \item \textbf{Automated maintenance of a software portfolio}: This is an
    experience report on automated mass maintenance of a large Cobol software
    portfolio. A company in the financial services and insurance industry
    upgraded their database system to a new version, affecting their entire
    software portfolio. The database system was accessed by the portfolio of 45
    systems, totalling nearly 3000 programs and covering over 4 million lines of
    Cobol code. We upgraded the programs to the new database version using
    several automatic tools, and we performed an automated analysis supporting
    further manual modifications by the system experts. The automatic tools were
    built using a combination of lexical and syntactic technology, and they were
    deployed in a mass update factory to allow large-scale application to the
    software portfolio. The updated portfolio has been accepted and taken into
    production by the company, serving over 600 employees with the new database
    version. In this paper, we discuss the automated upgrade from problem
    statement to project costs \cite{softwarePortfolio}.

    \item \textbf{2-Head Pushdown Automata}: Finite state automata recognize
    regular languages which can be used in text processing, compilers, and
    hardware design. Two head finite automata accept linear context free
    languages. In addition, pushdown automata are able to recognize context free
    languages which can be used in programming languages and artificial
    intelligence. The finite automaton has deterministic and non-deterministic
    version likewise the two head finite automata and the pushdown automata. The
    deterministic version of these machines is such that there is no choice of
    move in any situation while the non-deterministic version has a choice of
    move. In this research the 2-head pushdown automata are described which is
    more powerful than the pushdown automata and it is able to recognize some
    non-context free languages as well. During this work, the main task is to
    characterize these machines \cite{pushdownAutomata}.

    \item \textbf{Aspect-oriented model-driven code generation: A systematic
    mapping study}: Context: Model-driven code generation is being increasingly
    applied to enhance software development from perspectives of
    maintainability, extensibility and reusability. However, aspect-oriented
    code generation from models is an area that is currently underdeveloped.
    Objective: In this study we provide a survey of existing research on
    aspect-oriented modeling and code generation to discover current work and
    identify needs for future research. Method: A systematic mapping study was
    performed to find relevant studies. Classification schemes have been defined
    and the 65 selected primary studies have been classified on the basis of
    research focus, contribution type and research type. Results: The papers of
    solution proposal research type are in a majority. All together
    aspect-oriented modeling appears being the most focused area divided into
    modeling notations and process (36\%) and model composition and interaction
    management (26\%). The majority of contributions are methods. Conclusion:
    Aspect-oriented modeling and composition mechanisms have been significantly
    discussed in existing literature while more research is needed in the area
    of model-driven code generation. Furthermore, we have observed that previous
    research has frequently focused on proposing solutions and thus there is
    need for research that validates and evaluates the existing proposals in
    order to provide firm foundations for aspect-oriented model-driven code
    generation \cite{aspectOriented}.

    \item \textbf{A Review: Analysis of Aspect Orientation and Model Driven
    Engineering for Code Generation}: In the development of large and complex
    software application software engineers has to focuses on many requirements
    other than desired application’s requirement at the coding and design level.
    Code Generation is a technique which is use to automatically generates lower
    level executable code from higher level design artifact. Code generation
    provides design of the code at higher abstract level so that software
    developers can focuses on higher level design problem simultaneously meeting
    goals of desired application. Aspect Orientation (AO) is characterizing by
    identification and separation of different concerns and encapsulates them in
    modules. Concern is an interest which pertains to system operation,
    function, development or any other things which is important to one of the
    stakeholder. Model Driven Engineering (MDE) is a development paradigm which
    is characterize by model transformation and uses models to support various
    stages of the development life cycle. Model is primary artifact in MDE. In
    this paper we analyze both techniques i.e. AO and MDE, and how they can be
    used for code generation \cite{aspectOrientationReview}.

    \item \textbf{The Command Line Interface}: This is a very exciting chapter.
    While command line interfaces (CLIs) may not have the cachet of modern
    graphical user interfaces (GUIs), especially those of phones or tablets, the
    CLI is still a remarkably useful and effective user interface. This chapter
    details the design and implementation of the command line interface for
    pdCalc. By the end of this chapter, we will, for the first time, have a
    functioning (albeit feature incomplete) calculator, which is a significant
    milestone in our development \cite{commandLineInterface}.

    \item \textbf{Quantification of interface visual complexity}: Designers
    strive for enjoyable user experience (UX) and put a significant effort into
    making graphical user interfaces (GUI) both usable and beautiful. Our goal
    is to minimize their effort: with this purpose in mind, we have been
    studying automatic metrics of GUI qualities. These metrics could enable
    designers to iterate their designs more quickly. We started from the
    psychological findings that people tend to prefer simpler things. We then
    assumed visual complexity determinants also determine visual aesthetics and
    outlined eight of them as belonging to three dimensions: information amount
    (visual clutter and color variability), information organization (symmetry,
    grid, ease-of-grouping and prototypicality), and information
    discriminability (contour density and figure-ground contrast). We
    investigated five determinants (visual clutter, symmetry, contour density,
    figure-ground contrast and color variability) and proposed six associated
    automatic metrics. These metrics take screenshots of GUI as input and can
    thus be applied to any type of GUI. We validated the metrics through a user
    study: we gathered the ratings of immediate impressions of GUI visual
    complexity and aesthetics, and correlated them with the output of the
    metrics. The output explained up to 51\% of aesthetics ratings and 50\% of
    complexity ratings. This promising result could be further extended towards
    the creation of tLight, our automatic GUI evaluation tool
    \cite{quantificationOfInterface}.

    \item \textbf{Synchronizing folders with rsync}: In this post I cover the
    basics of rsync, in preparation for a subsequent post that will cover
    backups and it's use in conjunction with cronjobs to automatize the backup
    process. From the copying and synchronization of local files and folders, to
    it's use for transfer information among computers. Its use as a daemon when
    SSH is unavailable was moved to it's own section
    \cite{synchronizingFolders}.


\end{enumerate}
\end{englishtext}


