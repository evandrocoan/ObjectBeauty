
%
% Graphical Java application for managing BibTeX and BibLaTeX (.bib) databases (Windows/Linux/MAC)
% https://github.com/JabRef/jabref
%
% BibDesk-like software for Windows
% https://tex.stackexchange.com/questions/9454/bibdesk-like-software-for-windows
%
% LaTeX Bibliography Management
% https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management#BibTeX
%
%
% $ date "+%Y-%m-%d %H:%M:%S"
% 2017-08-28 09:18:02
%
% YYYY-MM-DD format date in shell script
% https://stackoverflow.com/questions/1401482/yyyy-mm-dd-format-date-in-shell-script
%


@thesis{structuredEditorStudy,
    title         = {Estudo e Criação de um Editor de Código Estruturado},
    author        = {Lucas Boppre Niehues},
    year          = {2013},
    publisher     = {University Library},
    address       = {Florianópolis, Santa Catarina, Brazil},
    abstract      = {Virtually all of the code editors for business use in general\hyp{}purpose
                    languages are oriented to lines and characters. The alternative, editors working
                    directly with the syntactic tree, has received most attention in this area,
                    aiming to have important advantages, such as automatic control of the structure
                    and greater efficiency in the script. The purpose of this paper is to study these
                    alternating active editors, called structured editors or syntax-driven editors,
                    comparing them with traditional editors. Once the advantages and disadvantages
                    have been raised, a structured editor will be developed that best fits in with
                    this medium. This work first provides for an in-depth study of these structured
                    editors, in the context of programming in general or non-general purpose
                    languages. Previous efforts in this area will be sought, assessing their impact,
                    lessons learned and limitations encountered. In a second moment these lessons
                    will be used for the development of a proprietary, fully structured or hybrid
                    editor, in order to increase the efficiency of the programmer. Preferably this
                    editor will be prepared for a standard general purpose language and will be able
                    to edit actual programs. This work aimed to better understand the principles
                    behind structured editors, seeking information on their effectiveness,
                    advantages, disadvantages and factors involved in their lack of adoption. It is
                    also envisaged the construction of a functional structured editor, capable of
                    being used on a daily basis, that makes better use of these advantages.},
    type          = {Graduation Thesis submitted to the Computer Science Department},
    institution   = {Federal University of Santa Catarina},
    location      = {Florianópolis, Santa Catarina, Brazil},
    note          = {[Departamento de Informática e Estatística]},
    url           = {https://tcc.inf.ufsc.br},
    urlaccessdate = {2017-03-01},
}


@book{commandLineInterface,
    title         = {The Command Line Interface. In: Practical C++ Design},
    author        = {Adam B. Singer},
    year          = {2017},
    abstract      = {This is a very exciting chapter. While command line interfaces (CLIs) may not
                    have the cachet of modern graphical user interfaces (GUIs), especially those of
                    phones or tablets, the CLI is still a remarkably useful and effective user
                    interface. This chapter details the design and implementation of the command
                    line interface for pdCalc. By the end of this chapter, we will, for the first
                    time, have a functioning (albeit feature incomplete) calculator, which is a
                    significant milestone in our development.},
    pages         = {97-113},
    edition       = {1},
    publisher     = {Apress},
    address       = {Berkeley, CA},
    isbn          = {978-1-4842-3056-5},
    doi           = {10.1007/978-1-4842-3057-2\_5},
    location      = {Online},
    url           = {https://www.researchgate.net/publication/320120365_The_Command_Line_Interface},
    urlaccessdate = {2017-10-10},
}


@online{Atwood,
    title         = {Death to the Space Infidels!},
    author        = {Jeff Atwood},
    abstract      = {Ah, spring. What a wonderful time of year. A time when young programmers' minds
                    turn to thoughts of ... never ending last-man-standing filibuster arguments
                    about code formatting. Naturally. And there is no argument more evergreen than
                    the timeless debate between tabs and spaces.},
    year          = {2009},
    location      = {Online},
    url           = {http://www.codinghorror.com/blog/2009/04/death-to-the-space-infidels.html},
    urlaccessdate = {2017-03-01},
}


@online{Geukens,
    title         = {Is imposing the same code format for all developers a good idea?},
    author        = {Stijn Geukens},
    abstract      = {We are considering to impose a single standard code format in our project (auto
                    format with save actions in Eclipse). The reason is that currently there is a
                    big difference in the code formats used by several (>10) developers which makes
                    it harder for one developer to work on the code of another developer. The same
                    Java file sometimes uses 3 different formats.},
    year          = {2013},
    location      = {Online},
    url           = {https://softwareengineering.stackexchange.com/questions/189274/is-imposing-the-same-code-format-for-all-developers-a-good-idea},
    urlaccessdate = {2017-03-01},
}


@online{Schweitzer,
    title         = {Powerful code indenter front-end, UniversalIndentGUI},
    author        = {Thomas Schweitzer},
    publisher     = {Online Material; \url{http://universalindent.sourceforge.net/index.php}},
    year          = {2012},
    abstract      = {Ever concerned about how your code looks like? Ever heard of different
                    indenting styles, for example K\&R? Ever received code from someone else who
                    didn't care about code formatting? Ever tried to configure a code indenter to
                    convert such code to your coding style? Ever got bored by that tedious "changing
                    a parameter"-"call the indeter"-"try and error" procedure? Help is close to you.
                    UniversalIndentGUI offers a live preview for setting the parameters of nearly
                    any indenter. You change the value of a parameter and directly see how your
                    reformatted code will look like. Save your beauty looking code or create an
                    anywhere usable batch/shell script to reformat whole directories or just one
                    file even out of the editor of your choice that supports external tool calls.},
    location      = {Online},
    url           = {https://github.com/danblakemore/universal-indent-gui},
    urlaccessdate = {2017-03-01},
}


@online{Skinner,
    title         = {SUBLIME TEXT 3 DOCUMENTATION, Syntax Definitions},
    author        = {Jon Skinner},
    year          = {2016},
    abstract      = {Sublime Text can use both .sublime-syntax and .tmLanguage files for syntax
                    highlighting. This document describes .sublime-syntax files. Sublime Syntax
                    files are YAML files with a small header, followed by a list of contexts. Each
                    context has a list of patterns that describe how to highlight text in that
                    context, and how to change the current text.},
    location      = {Online},
    url           = {https://www.sublimetext.com/docs/3/syntax.html},
    urlaccessdate = {2017-03-01},
}


@online{prettyPrinter,
    title         = {prettyprinter.de},
    author        = {J.M.},
    year          = {2017},
    abstract      = {This is a source code beautifier (source code formatter), similiar to indent.
                    Please make a backup before you replace your code!},
    location      = {Online},
    url           = {http://prettyprinter.de/},
    urlaccessdate = {2017-03-01},
}


@online{tabsAndSpacesConversion,
    title         = {How to replace spaces with tabs when pasting on a view},
    author        = {Evandro Coan},
    year          = {2017},
    abstract      = {The problem is that I will certainly not notice when I paste something indented
                    with spaces instead of tabs. This is problem because for some file types as
                    .sublime-settings files (or a Makefile), which has the setting
                    translate\_tabs\_to\_spaces set to false, so I would expect to all
                    .sublime-settings files to be indented with tabs, not spaces.},
    location      = {Online},
    url           = {https://forum.sublimetext.com/t/how-to-replace-spaces-with-tabs-when-pasting-on-a-view-with-translate-tabs-to-spaces-set-to-false/32193},
    urlaccessdate = {2017-09-29},
}


@online{synchronizingFolders,
    title         = {Synchronizing folders with rsync},
    author        = {Juan Valencia Escalante},
    year          = {2017},
    abstract      = {In this post I cover the basics of rsync, in preparation for a subsequent post
                    that will cover backups and it's use in conjunction with cronjobs to automatize
                    the backup process. From the copying and synchronization of local files and
                    folders, to it's use for transfer information among computers. Its use as a
                    daemon when SSH is unavailable was moved to it's own section.},
    location      = {Online},
    url           = {http://www.jveweb.net/en/archives/2010/11/synchronizing-folders-with-rsync.html},
    urlaccessdate = {2017-10-10},
}


@article{universalCodeFormatter,
    title         = {Towards a Universal Code Formatter through Machine Learning},
    author        = {Terence Parr and J.J. Vinju},
    month         = {10},
    year          = {2016},
    journal       = {SLE 2016 Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    abstract      = {There are many declarative frameworks that allow us to implement code
                    formatters relatively easily for any specific language, but constructing them is
                    cumbersome. The first problem is that “everybody” wants to format their code
                    differently, leading to either many formatter variants or a ridiculous number of
                    configuration options. Second, the size of each implementation scales with a
                    language’s grammar size, leading to hundreds of rules. In this paper, we solve
                    the formatter construction problem using a novel approach, one that
                    automatically derives formatters for any given language without intervention
                    from a language expert. We introduce a code formatter called CODEB UFF that uses
                    machine learning to abstract formatting rules from a representative corpus,
                    using a carefully designed feature set. Our experiments on Java, SQL, and ANTLR
                    grammars show that CODEB UFF is efficient, has excellent accuracy, and is
                    grammar invariant for a given language. It also generalizes to a 4th language
                    tested during manuscript preparation.},
    pages         = {137-151},
    doi           = {10.1145/2997364.2997383},
    isbn          = {978-1-4503-4447-0},
    location      = {Amsterdam, The Netherlands},
    url           = {https://www.researchgate.net/publication/309363024_Towards_a_universal_code_formatter_through_machine_learning},
    urlaccessdate = {2017-03-01},
}


@article{industrialApplication,
    title         = {An industrial application of context-sensitive formatting},
    author        = {M.G.J. van den Brand and A.T. Kooiker and N.P. Veerman and J.J. Vinju},
    year          = {2005},
    abstract      = {Automated formatting is an important technique for the software maintainer. It
                    is either applied separately to improve the readability of source code, or as
                    part of a source code transformation tool chain. In this paper we report on the
                    application of generic tools for constructing formatters. In an industrial
                    setting automated formatters need to be tailored to the requirements of the
                    customer. The (legacy) programming language or dialect and the corporate
                    formatting conventions are specific and non-negotiable. Can generic formatting
                    tools deal with such unexpected requirements? Driven by an industrial case of 78
                    thousand lines of Cobol code, several limitations in existing formatting
                    technology have been addressed. We improved its flexibility by replacing a
                    generative phase by a generic tool, and we added a little expressiveness to the
                    formatting backend. Most importantly, we employed a multi-stage formatting
                    architecture that can cope with any kind of formatting convention using more
                    computational power.},
    publisher     = {Online},
    url           = {https://www.researchgate.net/publication/228540036_An_industrial_application_of_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{programIndentation,
    title         = {Program indentation and comprehensibility},
    author        = {Richard J. Miara and Joyce A. Musselman and Juan A. Navarro and Ben Shneiderman},
    month         = {11},
    year          = {1983},
    journal       = {Communications of the ACM},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    volume        = {26},
    issue         = {11},
    abstract      = {The consensus in the programming community is that indentation aids program
                    comprehension, although many studies do not back this up. We tested program
                    comprehension on a Pascal program. Two styles of indentation were used --
                    blocked and non-blocked -- in addition to four passible levels of indentation
                    (0, 2, 4, 6 spaces). Both experienced and novice subjects were used. Although
                    the blocking style made no difference, the level of indentation had a
                    significant effect on program comprehension. (2--4 spaces had the highest mean
                    score for program comprehension.) We recommend that a moderate level of
                    indentation be used to increase program comprehension and user satisfaction.},
    pages         = {861-867},
    location      = {Online},
    doi           = {10.1145/182.358437},
    url           = {https://www.researchgate.net/publication/234809222_Program_indentation_and_comprehensibility},
    urlaccessdate = {2017-09-07},
}


@article{independentFramework,
    title         = {A Language Independent Framework for Context-sensitive Formatting},
    author        = {M.G.J. Van den Brand and A.T. Kooiker and J.J. Vinju},
    month         = {03},
    year          = {2006},
    journal       = {CSMR '06 Proceedings of the Conference on Software Maintenance and Reengineering},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    volume        = {26},
    issue         = {1},
    abstract      = {Automated formatting is an important technique for the software maintainer. It
                    is either applied separately to improve the readability of source code, or as
                    part of a source code transformation tool chain. In this paper we report on the
                    application of generic tools for constructing formatters. In an industrial
                    setting automated formatters need to be tailored to the requirements of the
                    customer. The (legacy) programming language or dialect and the corporate
                    formatting conventions are specific and non-negotiable. Can generic formatting
                    tools deal with such unexpected requirements? Driven by an industrial case of
                    nearly 80 thousand lines of Cobol code, several limitations in existing
                    formatting technology have been addressed. We improved its flexibility by
                    replacing a generative phase by a generic tool, and we added a little
                    expressiveness to the formatting back end. Most importantly, we employed a
                    multi-stage formatting framework that can cope with any kind of formatting
                    convention using more computational power.},
    pages         = {103-112},
    doi           = {10.1109/CSMR.2006.4},
    isbn          = {0-7695-2536-9},
    location      = {Bari, Italy},
    url           = {https://www.researchgate.net/publication/4226896_A_language_independent_framework_for_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{architectureFormatting,
    title         = {An architecture for context-sensitive formatting},
    author        = {M.G.J. van den Brand and A.T. Kooiker and J.J. Vinju and N.P. Veerman},
    month         = {09},
    year          = {2005},
    abstract      = {We developed an architecture for context-sensitive formatting of source code.
                    The architecture was implemented and applied in an industrial formatting case.},
    journal       = {21st IEEE International Conference on Software Maintenance (ICSM'05)},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    doi           = {10.1109/ICSM.2005.17},
    isbn          = {0-7695-2368-4},
    location      = {Budapest, Hungary, Hungary},
    url           = {https://www.researchgate.net/publication/4175894_An_architecture_for_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{prettyPrinting,
    title         = {Pretty-printing for software reengineering},
    author        = {Merijn De Jonge},
    month         = {10},
    year          = {2002},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {Automatic software reengineerings change or repair existing software systems.
                    They are usually tailor-made for a specific customer and language dependent.
                    Maintaining similar reengineerings for multiple customers and different language
                    dialects might therefore soon become problematic unless advanced language
                    technology is being used. Generic pretty-printing is part of such technology and
                    is the subject of this paper. We discuss specific pretty-print aspects of
                    software reengineering such as fulfilling customer-specific format conventions,
                    preserving existing layout, and producing multiple output formats. In addition,
                    we describe pretty-print techniques that help to reduce maintenance effort of
                    tailor-made reengineerings supporting multiple language dialects. Applications,
                    such as COBOL reengineering and SDL documentation generation show that our
                    techniques, implemented in the generic pretty-printer GPP, are feasible.},
    journal       = {International Conference on Software Maintenance, 2002. Proceedings},
    doi           = {10.1109/ICSM.2002.1167816},
    isbn          = {0-7695-1819-2},
    location      = {Montreal, Quebec, Canada},
    url           = {https://www.researchgate.net/publication/3998748_Pretty-Printing_for_Software_Reengineering},
    urlaccessdate = {2017-09-07},
}


@article{massMaintenance,
    title         = {Automated Mass Maintenance of Software Assets},
    author        = {Niels Veerman},
    month         = {03},
    year          = {2007},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {This is a research summary of a PhD project in the area of massive software
                    maintenance automation. We explain the context, approach, and contributions.},
    journal       = {11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
    doi           = {10.1109/CSMR.2007.15},
    isbn          = {0-7695-2802-3},
    location      = {Amsterdam, The Netherlands},
    url           = {https://www.researchgate.net/publication/221569579_Automated_Mass_Maintenance_of_Software_Assets},
    urlaccessdate = {2017-09-11},
}


@article{legacyAssets,
    title         = {Towards automated modification of legacy assets},
    author        = {Alex Sellink and Chris Verhoef},
    month         = {01},
    year          = {2000},
    journal       = {Annals of Software Engineering},
    publisher     = {Kluwer Academic Publishers},
    address       = {Dordrecht, The Netherlands},
    volume        = {9},
    issue         = {1-4},
    pages         = {315-336},
    abstract      = {In this paper we argue that there is a necessity for automating modifications
                    to legacy assets. We propose a five layered process for the introduction and
                    employment of tool support that enables automated modification to entire legacy
                    systems. Furthermore, we elaborately discuss each layer on a conceptual level,
                    and we make appropriate references to sources where technical contributions
                    supporting that particular layer can be found. We sketch the perspective that
                    more and more people working in the software engineering area will be
                    contributing to working on existing systems and/or tools to support such work.},
    location      = {Red Bank, NJ, USA},
    doi           = {10.1023/A:1018941228255},
    url           = {https://www.researchgate.net/publication/2825635_Towards_Automated_Modification_of_Legacy_Assets},
    urlaccessdate = {2017-09-11},
}


@article{softwarePortfolio,
    title         = {Automated maintenance of a software portfolio},
    author        = {Niels Veerman},
    month         = {10},
    year          = {2006},
    journal       = {Science of Computer Programming - Special issue on source code analysis and manipulation (SCAM 2005)},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, The Netherlands},
    volume        = {62},
    issue         = {3},
    pages         = {287-317},
    abstract      = {This is an experience report on automated mass maintenance of a large Cobol
                    software portfolio. A company in the financial services and insurance industry
                    upgraded their database system to a new version, affecting their entire software
                    portfolio. The database system was accessed by the portfolio of 45 systems,
                    totalling nearly 3000 programs and covering over 4 million lines of Cobol code.
                    We upgraded the programs to the new database version using several automatic
                    tools, and we performed an automated analysis supporting further manual
                    modifications by the system experts. The automatic tools were built using a
                    combination of lexical and syntactic technology, and they were deployed in a
                    mass update factory to allow large-scale application to the software portfolio.
                    The updated portfolio has been accepted and taken into production by the
                    company, serving over 600 employees with the new database version. In this
                    paper, we discuss the automated upgrade from problem statement to project
                    costs.},
    doi           = {10.1016/j.scico.2006.04.006},
    location      = {Amsterdam, The Netherlands},
    url           = {https://www.researchgate.net/publication/222831264_Automated_maintenance_of_a_software_portfolio},
    urlaccessdate = {2017-09-12},
}


@article{pushdownAutomata,
    title         = {2-Head Pushdown Automata},
    author        = {Awe Ayodeji Samson},
    month         = {06},
    year          = {2015},
    journal       = {Procedia - Social and Behavioral Sciences},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, The Netherlands},
    volume        = {195},
    issue         = {1},
    pages         = {2037-2046},
    abstract      = {Finite state automata recognize regular languages which can be used in text
                    processing, compilers, and hardware design. Two head finite automata accept
                    linear context free languages. In addition, pushdown automata are able to
                    recognize context free languages which can be used in programming languages and
                    artificial intelligence. The finite automaton has deterministic and
                    non-deterministic version likewise the two head finite automata and the pushdown
                    automata. The deterministic version of these machines is such that there is no
                    choice of move in any situation while the non-deterministic version has a choice
                    of move. In this research the 2-head pushdown automata are described which is
                    more powerful than the pushdown automata and it is able to recognize some
                    non-context free languages as well. During this work, the main task is to
                    characterize these machines.},
    doi           = {10.1016/j.sbspro.2015.06.225},
    location      = {Department of Mathematics, Eastern Mediterranean University, Mersin 10 Turkey, Famagusta, North Cyprus},
    url           = {https://www.researchgate.net/publication/282556609_2-Head_Pushdown_Automata},
    urlaccessdate = {2017-09-12},
}


@article{aspectOriented,
    title         = {Aspect-oriented model-driven code generation: A systematic mapping study},
    author        = {Abid Mehmood and Dayang Norhayati Abang Jawawi},
    month         = {09},
    year          = {2012},
    journal       = {Information and Software Technology},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, The Netherlands},
    volume        = {55},
    issue         = {2},
    pages         = {395-411},
    abstract      = {Context: Model-driven code generation is being increasingly applied to enhance
                    software development from perspectives of maintainability, extensibility and
                    reusability. However, aspect-oriented code generation from models is an area
                    that is currently underdeveloped. Objective: In this study we provide a survey
                    of existing research on aspect-oriented modeling and code generation to discover
                    current work and identify needs for future research. Method: A systematic
                    mapping study was performed to find relevant studies. Classification schemes
                    have been defined and the 65 selected primary studies have been classified on
                    the basis of research focus, contribution type and research type. Results: The
                    papers of solution proposal research type are in a majority. All together
                    aspect-oriented modeling appears being the most focused area divided into
                    modeling notations and process (36\%) and model composition and interaction
                    management (26\%). The majority of contributions are methods. Conclusion:
                    Aspect-oriented modeling and composition mechanisms have been significantly
                    discussed in existing literature while more research is needed in the area of
                    model-driven code generation. Furthermore, we have observed that previous
                    research has frequently focused on proposing solutions and thus there is need
                    for research that validates and evaluates the existing proposals in order to
                    provide firm foundations for aspect-oriented model-driven code generation.},
    location      = {Department of Software Engineering, Faculty of Computer Science and Information Systems, Universiti Teknologi Malaysia, 81310 Skudai, Johor, Malaysia},
    doi           = {10.1016/j.infsof.2012.09.003},
    url           = {https://www.researchgate.net/publication/257391227_Aspect-oriented_model-driven_code_generation_A_systematic_mapping_study},
    urlaccessdate = {2017-09-12},
}


@article{aspectOrientationReview,
    title         = {A Review: Analysis of Aspect Orientation and Model Driven Engineering for Code Generation},
    author        = {Dhiraj Gurunule and Madhu Nashipudimath},
    month         = {03},
    year          = {2015},
    journal       = {Procedia Computer Science},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, The Netherlands},
    volume        = {45},
    issue         = {1},
    pages         = {852-861},
    abstract      = {In the development of large and complex software application software engineers
                    has to focuses on many requirements other than desired application’s requirement
                    at the coding and design level. Code Generation is a technique which is use to
                    automatically generates lower level executable code from higher level design
                    artifact. Code generation provides design of the code at higher abstract level
                    so that software developers can focuses on higher level design problem
                    simultaneously meeting goals of desired application. Aspect Orientation (AO) is
                    characterizing by identification and separation of different concerns and
                    encapsulates them in modules. Concern is an interest which pertains to system
                    operation, function, development or any other things which is important to one
                    of the stakeholder. Model Driven Engineering (MDE) is a development paradigm
                    which is characterize by model transformation and uses models to support various
                    stages of the development life cycle. Model is primary artifact in MDE. In this
                    paper we analyze both techniques i.e. AO and MDE, and how they can be used for
                    code generation.},
    location      = {Information Technology Department and Computer Department PIIT, New Panvel, India},
    doi           = {10.1016/j.procs.2015.03.171},
    url           = {https://www.researchgate.net/publication/276899518_A_Review_Analysis_of_Aspect_Orientation_and_Model_Driven_Engineering_for_Code_Generation},
    urlaccessdate = {2017-09-12},
}


@article{quantificationOfInterface,
    title         = {Quantification of interface visual complexity},
    author        = {Aliaksei Miniukovich and Antonella De Angeli},
    month         = {03},
    year          = {2014},
    journal       = {Proceedings of the 2014 International Working Conference on Advanced Visual Interfaces},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    pages         = {153-160},
    abstract      = {Designers strive for enjoyable user experience (UX) and put a significant
                    effort into making graphical user interfaces (GUI) both usable and beautiful.
                    Our goal is to minimize their effort: with this purpose in mind, we have been
                    studying automatic metrics of GUI qualities. These metrics could enable
                    designers to iterate their designs more quickly. We started from the
                    psychological findings that people tend to prefer simpler things. We then
                    assumed visual complexity determinants also determine visual aesthetics and
                    outlined eight of them as belonging to three dimensions: information amount
                    (visual clutter and color variability), information organization (symmetry,
                    grid, ease-of-grouping and prototypicality), and information discriminability
                    (contour density and figure-ground contrast). We investigated five determinants
                    (visual clutter, symmetry, contour density, figure-ground contrast and color
                    variability) and proposed six associated automatic metrics. These metrics take
                    screenshots of GUI as input and can thus be applied to any type of GUI. We
                    validated the metrics through a user study: we gathered the ratings of immediate
                    impressions of GUI visual complexity and aesthetics, and correlated them with
                    the output of the metrics. The output explained up to 51\% of aesthetics ratings
                    and 50\% of complexity ratings. This promising result could be further extended
                    towards the creation of tLight, our automatic GUI evaluation tool.},
    location      = {University of Trento, Como, Italy},
    doi           = {10.1145/2598153.2598173},
    isbn          = {978-1-4503-2775-6},
    url           = {https://www.researchgate.net/publication/266657991_Quantification_of_interface_visual_complexity},
    urlaccessdate = {2017-10-10},
}


@article{toolsForProjectManagement,
    title         = {Comparison of open source tools for project management},
    author        = {André Marques Pereira and Rafael Queiroz Gonçalves and Christiane Gresse von Wangenheim and Luigi Buglione},
    month         = {03},
    year          = {2013},
    journal       = {International Journal of Software Engineering and Knowledge Engineering},
    publisher     = {World Scientific Publishing, },
    address       = {Singapore},
    volume        = {23},
    issue         = {02},
    pages         = {189-209},
    abstract      = {Software projects often fail, because they are not adequately managed. The
                    establishment of effective and efficient project management practices still
                    remains a key challenge to software organizations. Striving to address these
                    needs, "best practice" models, such as, the Capability Maturity Model
                    Integration (CMMI) or the Project Management Body of Knowledge (PMBOK), are
                    being developed to assist organizations in improving project management.
                    Although not required, software tools can help implement the project management
                    process in practice. In order to provide comprehensive, low-cost tool support
                    for project management, specifically, for small and medium enterprises (SMEs),
                    in this paper we compare the most popular free/open-source web-based project
                    management tools with respect to their compliance to PMBOK and CMMI for
                    Development (CMMI-DEV). The results of this research can be used by
                    organizations to make decisions on tool adoptions as well as a basis for
                    evolving software tools in alignment with best practices models.},
    location      = {Federal University of Santa Catarina (UFSC), Florianópolis, Santa Catarina, Brazil},
    doi           = {10.1142/S0218194013500046},
    url           = {https://www.researchgate.net/publication/273569026_Comparison_of_open_source_tools_for_project_management},
    urlaccessdate = {2017-10-27},
}


@article{naturalCodingConventions,
    title         = {Learning Natural Coding Conventions},
    author        = {Miltiadis Allamanis and Earl T. Barr and Charles Sutton},
    month         = {11},
    year          = {2014},
    journal       = {Proceeding FSE 2014 Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    volume        = {23},
    issue         = {02},
    pages         = {281-293},
    abstract      = {Every programmer has a characteristic style, ranging from preferences about
                    identifier naming to preferences about object relationships and design patterns.
                    Coding conventions define a consistent syntactic style, fostering readability
                    and hence maintainability. When collaborating, programmers strive to obey a
                    project’s coding conventions. However, one third of reviews of changes contain
                    feedback about coding conventions, indicating that programmers do not always
                    follow them and that project members care deeply about adherence. Unfortunately,
                    programmers are often unaware of coding conventions because inferring them
                    requires a global view, one that aggregates the many local decisions programmers
                    make and identifies emergent consensus on style. We present NATURALIZE, a
                    framework that learns the style of a codebase, and suggests revisions to improve
                    stylistic consistency. NATURALIZE builds on recent work in applying statistical
                    natural language processing to source code. We apply NATURALIZE to suggest
                    natural identifier names and formatting conventions. We present four tools
                    focused on ensuring natural code during development and release management,
                    including code review. NATURALIZE achieves 94\% accuracy in its top suggestions
                    for identifier names. We used NATURALIZE to generate 18 patches for 5 open
                    source projects: 14 were accepted.},
    location      = {Hong Kong, China},
    doi           = {10.1145/2635868.2635883},
    url           = {https://www.researchgate.net/publication/260250447_Learning_Natural_Coding_Conventions},
    urlaccessdate = {2017-10-27},
}


@article{codePlagiarismDetection,
    title         = {Style Analysis for Source Code Plagiarism Detection},
    author        = {Olfat Mirza and Mike Joy},
    month         = {06},
    year          = {2015},
    journal       = {International Conference Plagiarism across Europe and Beyond 2015},
    publisher     = {Online},
    address       = {\url{https://plagiarism.pefka.mendelu.cz/?sec=cf15#proc}},
    pages         = {53–61},
    abstract      = {Plagiarism has become an increasing problem in higher education in recent
                    years. A number of research papers have discussed the problem of plagiarism in
                    terms of text and source code and the techniques to detect it in various
                    contexts. There is a variety of easy ways of copying others’ work because the
                    source code can be obtained from online source code banks and textbooks, which
                    makes plagiarism easy for students. Source code plagiarism has a very specific
                    definition, and Parker and Hamblen define plagiarism on software as “A program
                    that has been produced from another program with a small number of routine
                    transformations”. The transformations can range from very simple changes to very
                    difficult ones, which can be one of the six levels of program modifications that
                    are given by Faidhi and Robinson. Coding style is a way to detect source code
                    plagiarism because it relates to programmer personality without affecting the
                    logic of a program, and can be used to differentiate between different code
                    authors. This paper reviews a number of publications which report style
                    comparison to detect source code plagiarism in order to determine research gaps
                    and explore areas where this approach can be improved. A summary of the
                    plagiarism techniques in which style analysis can help identify plagiarism is
                    presented.},
    location      = {Brno, Czech Republic},
    url           = {https://www.researchgate.net/publication/303932091_Style_Analysis_for_Source_Code_Plagiarism_Detection},
    urlaccessdate = {2017-10-27},
}


@article{annotationAssistant,
    title         = {An Annotation Assistant for Interactive Debugging of Programs with Common Synchronization Idioms},
    author        = {Elmas, Tayfun and Sezgin, Ali and Tasiran, Serdar and Qadeer, Shaz},
    booktitle     = {Proceedings of the 7th Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging},
    series        = {PADTAD '09},
    year          = {2009},
    pages         = {10:1--10:11},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    abstract      = {This paper explores an approach to improving the practical usability of static
                    verification tools for debugging synchronization idioms. Synchronization idioms such
                    as mutual exclusion and readers/writer locks are widely-used to ensure atomicity of
                    critical regions. We present an annotation assistant that automatically generates
                    program annotations. These annotations express noninterference between program
                    statements, ensured by the synchronization idioms, and are used to identify atomic
                    code regions. This allows the programmer to debug the use of the idioms in the
                    program. We start by formalizing several well-known idioms by providing an abstract
                    semantics for each idiom. For programs that use these idioms, we require the
                    programmer to provide a few predicates linking the idiom with its realization in
                    terms of program variables. From these, we automatically generate a proof script
                    that is mechanically checked. These scripts include steps such as automatically
                    generating assertions and annotating program actions with them, introducing
                    auxiliary variables and invariants. We have successfully shown the applicability of
                    this approach to several concurrent programs from the literature.},
    articleno     = {10},
    numpages      = {11},
    location      = {Chicago, Illinois},
    doi           = {10.1145/1639622.1639632},
    isbn          = {978-1-60558-655-7},
    acmid         = {1639632},
    url           = {http://doi.acm.org/10.1145/1639622.1639632},
    keywords      = {atomicity, concurrent programs, synchronization idioms},
    urlaccessdate = {2017-10-30},
}


@Inbook{automaticSynthesis,
    title         = {Towards Automatic Synthesis of Software Verification Tools},
    author        = {Rybalchenko, Andrey},
    editor        = {Donaldson, Alastair and Parker, David},
    bookTitle     = {Model Checking Software: 19th International Workshop, SPIN 2012, Oxford, UK, July 23-24, 2012. Proceedings},
    year          = {2012},
    volume        = {7385},
    publisher     = {Springer},
    address       = {Berlin, Germany},
    pages         = {22--22},
    abstract      = {Software complexity is growing, so is the demand for software verification. Soon,
                    perhaps within a decade, wide deployment of software verification tools will be
                    indispensable or even mandatory to ensure software reliability in a large number of
                    application domains, including but not restricted to safety and security critical
                    systems. To adequately respond to the demand we need to eliminate tedious aspects of
                    software verifier development, while providing support for the accomplishment of
                    creative aspects.},
    location      = {Technische Universität München, Germany},
    doi           = {10.1007/978-3-642-31759-0\_3},
    isbn          = {978-3-642-31759-0},
    url           = {https://link.springer.com/chapter/10.1007/978-3-642-31759-0_3},
    urlaccessdate = {2017-10-30},
}


@article{redesignOfGit,
    title         = {Purposes, Concepts, Misfits, and a Redesign of Git},
    author        = {Santiago Perez De Rosso and Daniel Jackson},
    journal       = {SIGPLAN Not.},
    volume        = {51},
    number        = {10},
    month         = {10},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    year          = {2016},
    issn          = {0362-1340},
    pages         = {292--310},
    abstract      = {Git is a widely used version control system that is powerful but complicated.
                    Its complexity may not be an inevitable consequence of its power but rather
                    evidence of flaws in its design. To explore this hypothesis, we analyzed the
                    design of Git using a theory that identifies concepts, purposes, and misfits.
                    Some well-known difficulties with Git are described, and explained as misfits in
                    which underlying concepts fail to meet their intended purpose. Based on this
                    analysis, we designed a reworking of Git (called Gitless) that attempts to
                    remedy these flaws. To correlate misfits with issues reported by users, we
                    conducted a study of Stack Overflow questions. And to determine whether users
                    experienced fewer complications using Gitless in place of Git, we conducted a
                    small user study. Results suggest our approach can be profitable in identifying,
                    analyzing, and fixing design problems.},
    keywords      = {Git, concept design, concepts, design, software design, usability, version control},
    numpages      = {19},
    location      = {Massachusetts Institute of Technology, USA},
    doi           = {10.1145/3022671.2984018},
    acmid         = {2984018},
    url           = {https://www.researchgate.net/publication/311477527_Purposes_concepts_misfits_and_a_redesign_of_git},
    urlaccessdate = {2017-10-30},
}


@article{codeClassification,
    title         = {Code Classification as a Learning and Assessment Exercise for Novice Programmers},
    author        = {Errol Thompson and Jacqueline L. Whalley and Raymond Lister and Beth Simon},
    journal       = {Proceedings of the 19th Annual Conference of the National Advisory Committee on Computing Qualifications},
    month         = {07},
    year          = {2006},
    pages         = {291--298},
    publisher     = {Online},
    address       = {Aston University, Computer Science Department},
    abstract      = {When students are given code that is very similar in structure or purpose, how
                    well do they actually recognise the similarities and differences? As part of the
                    BRACElet project, a multi-institutional investigation into reading and
                    comprehension skills of novice programmers, students were asked to classify four
                    code segments that found the minimum or maximum in an array of numbers. This
                    paper reports on the analysis of responses to this question and draws
                    conclusions about the students' ability to recognise the similarities and
                    differences in example code. It then raises questions with respect to an
                    approach to teaching that uses variations in code examples. Received Citrus
                    Award for Collaborative Research and highly recommended in the Best Paper awards
                    },
    location      = {NACCQ, Wellington, New Zealand},
    url           = {https://www.researchgate.net/publication/255948009_Code_Classification_as_a_Learning_and_Assessment_Exercise_for_Novice_Programmers},
    urlaccessdate = {2017-10-31},
}


@article{codeScanningPatterns,
    title         = {Code Scanning Patterns in Program Comprehension},
    author        = {Christoph Aschwanden and Martha Crosby},
    journal       = {Proceedings of the 39th Annual Hawaii International Conference on System Sciences},
    month         = {01},
    year          = {2006},
    publisher     = {Online},
    address       = {Department of Information and Computer Sciences},
    abstract      = {Various publications have identified Beacons to play a key role in program
                    comprehension. Beacons are code fragments that help developers comprehend
                    programs. It has been shown that expert programmers pay more attention to
                    Beacons than novices. Beacons are described as the link between source code and
                    hypothesis verification. Beacons are sets of key features that typically
                    indicate the presence of a particular data structure or operation in source
                    code. However, only little research has been done trying to identify and explain
                    them in greater detail. It has been demonstrated that good variable and
                    procedure names help in program comprehension. Documentation is beneficial as
                    well. The so-called swap operation for variables is a strong indicator for a
                    sorting algorithm. We conducted an eye tracking study using the EventStream
                    software framework as the instrument to investigate programmers' behavior during
                    a code reading exercise. Preliminary results suggest Beacons to be present when
                    the longest fixation duration is thousand milliseconds or higher. Comparing
                    participants with correct understanding versus participants with wrong
                    understanding showed differences in focus of attention. Based on the study
                    conducted, we suggest to consider "int k=(a+b)/2" as Beacons during program
                    comprehension as well as lines of code which exhibit very long fixations above
                    1000 milliseconds.},
    location      = {University of Hawaii at Manoa},
    url           = {https://www.researchgate.net/publication/250718584_Code_Scanning_Patterns_in_Program_Comprehension},
    urlaccessdate = {2017-10-31},
}


@Inbook{debuggingIntoExamples,
    title         = {Debugging into Examples},
    author        = {Steinert, Bastian and Perscheid, Michael and Beck, Martin and Lincke, Jens and Hirschfeld, Robert},
    bookTitle     = {Testing of Software and Communication Systems: 21st IFIP WG 6.1 International Conference , November 2-4, 2009. Proceedings},
    year          = {2009},
    pages         = {235--240},
    publisher     = {Springer},
    address       = {Berlin, Heidelberg},
    abstract      = {Enhancing and maintaining a complex software system requires detailed
                    understanding of the underlying source code. Gaining this understanding by
                    reading source code is difficult. Since software systems are inherently dynamic,
                    it is complex and time consuming to imagine, for example, the effects of a
                    method's source code at run-time. The inspection of software systems during
                    execution, as encouraged by debugging tools, contributes to source code
                    comprehension. Leveraged by test cases as entry points, we want to make it easy
                    for developers to experience selected execution paths in their code by debugging
                    into examples. We show how links between test cases and application code can be
                    established by means of dynamic analysis while executing regular tests.},
    location      = {Eindhoven, The Netherlands},
    isbn          = {978-3-642-05031-2},
    doi           = {10.1007/978-3-642-05031-2_18},
    url           = {https://www.researchgate.net/publication/221047094_Debugging_into_Examples},
    urlaccessdate = {2017-10-31},
}


@article{programUnderstanding,
    title         = {The Use of Reading Technique and Visualization for Program Understanding},
    author        = {Daniel Porto and Manoel G. Mendonça and Sandra Camargo Pinto Ferraz Fabbri},
    year          = {2009},
    month         = {07},
    pages         = {386--391},
    publisher     = {Online},
    address       = {\url{https://www.researchgate.net/profile/Sarah_Printy/publication/221391313_Enhancing_Property_Specification_Tools_With_Validation_Techniques/links/0deec52af54ccf046e000000.pdf#page=411}},
    abstract      = {Code comprehension is the basis for many other activities in software
                    engineering. It is also time consuming and can greatly profit from tools that decrease the time
                    that it usually consumes. This paper presents a tool named CRISTA that supports code
                    comprehension through the application of Stepwise Abstraction. It uses a visual metaphor to
                    represent the code and supports essential tasks for code reading, inspection and documentation.
                    Three case studies were carried out to evaluate the tool with respect to usability and
                    usefulness. In all of them the experiment participants considered that the tool facilitates code
                    comprehension, inspection and documentation.},
    location      = {Boston, Massachusetts},
    isbn          = {1-891706-24-1},
    url           = {https://www.researchgate.net/publication/221390090_The_Use_of_Reading_Technique_and_Visualization_for_Program_Understanding},
    urlaccessdate = {2017-10-31},
}


@inproceedings{documentingAndSharingKnowledge,
    author        = {Guzzi, Anja},
    title         = {Documenting and Sharing Knowledge About Code},
    booktitle     = {Proceedings of the 34th International Conference on Software Engineering},
    series        = {ICSE '12},
    year          = {2012},
    isbn          = {978-1-4673-1067-3},
    pages         = {1535--1538},
    numpages      = {4},
    publisher     = {IEEE Press},
    address       = {Piscataway, NJ, USA},
    abstract      = {Software engineers spend a considerable amount of time on program
                    comprehension. Current research has primarily focused on assisting the developer
                    trying to build up his understanding of the code. This knowledge remains only in
                    the mind of the developer and, as time elapses, often “disappears”. In this
                    research, we shift the focus to the developer who is using her Integrated
                    Development Environment (IDE) for writing, modifying, or reading the code, and
                    who actually understands the code she is working with. The objective of this PhD
                    research is to seek ways to support this developer to document and share her
                    knowledge with the rest of the team. In particular, we investigate the full
                    potential of micro-blogging integrated into the IDE for addressing the program
                    comprehension problem.},
    url           = {http://dl.acm.org/citation.cfm?id=2337223.2337476},
    location      = {Zurich, Switzerland},
    acmid         = {2337476},
    urlaccessdate = {2017-10-31},
}


@inproceedings{analysisOfCodeReading,
    title         = {Analysis of Code Reading to Gain More Insight in Program Comprehension},
    author        = {Busjahn, Teresa and Schulte, Carsten and Busjahn, Andreas},
    booktitle     = {Proceedings of the 11th Koli Calling International Conference on Computing Education Research},
    series        = {Koli Calling '11},
    year          = {2011},
    isbn          = {978-1-4503-1052-9},
    location      = {Koli, Finland},
    pages         = {1--9},
    numpages      = {9},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    abstract      = {Code reading, although an integral part of program comprehension, is rarely
                    reflected. In this paper, we want to argue for a research approach and direction
                    exploiting the potential that lies in the analysis of reading processes. Based
                    on the vast experience compiled in psychology and some studies in computing, eye
                    tracking and think aloud were elaborated as a viable research instrument for
                    code reading studies. We conducted a feasibility study, designed to examine the
                    actual process of code reading as the sensory starting point of comprehension.
                    Computational and statistical tools were developed to facilitate data capture
                    and analysis for eye tracking experiments. Results do not just provide proof of
                    concept but already emphasize differences between reading natural language text
                    and source code, as well as a distinct attention allocation within different
                    code elements like keywords and operators. In conclusion we suggest a
                    combination of theory-driven selected stimuli material, a carefully designed
                    procedure of eye tracking, complemented with suitable post-tests on
                    comprehension as well as retrospective think aloud in order to obtain additional
                    information on the linking process between perception and comprehension. As an
                    addition to other research approaches this should most certainly help us to
                    improve our knowledge of comprehension within an educational research
                    framework.},
    keywords      = {CS Ed research, code comprehension, code reading, educational research, eye tracking, program comprehension},
    doi           = {10.1145/2094131.2094133},
    acmid         = {2094133},
    location      = {Freie Universität Berlin, Germany},
    url           = {https://www.researchgate.net/publication/254004382_Analysis_of_code_reading_to_gain_more_insight_in_program_comprehension},
    urlaccessdate = {2017-10-31},
}


@article{theImpactOfIdentifierStyle,
    title         = {The impact of identifier style on effort and comprehension},
    author        = {Binkley, Dave and Davis, Marcia and Lawrie, Dawn and Maletic, Jonathan I. and Morrell, Christopher and Sharif, Bonita},
    journal       = {Empirical Software Engineering},
    year          = {2013},
    month         = {Apr},
    volume        = {18},
    number        = {2},
    publisher     = {Springer},
    address       = {Berlin, Germany},
    pages         = {219--276},
    abstract      = {A family of studies investigating the impact of program identifier style on
                    human comprehension is presented. Two popular identifier styles are examined,
                    namely camel case and underscore. The underlying hypothesis is that identifier
                    style affects the speed and accuracy of comprehending source code. To
                    investigate this hypothesis, five studies were designed and conducted. The first
                    study, which investigates how well humans read identifiers in the two different
                    styles, focuses on low-level readability issues. The remaining four studies
                    build on the first to focus on the semantic implications of identifier style.
                    The studies involve 150 participants with varied demographics from two different
                    universities. A range of experimental methods is used in the studies including
                    timed testing, read aloud, and eye tracking. These methods produce a broad set
                    of measurements and appropriate statistical methods, such as regression models
                    and Generalized Linear Mixed Models (GLMMs), are applied to analyze the results.
                    While unexpected, the results demonstrate that the tasks of reading and
                    comprehending source code is fundamentally different from those of reading and
                    comprehending natural language. Furthermore, as the task becomes similar to
                    reading prose, the results become similar to work on reading natural language
                    text. For more ``source focused'' tasks, experienced software developers appear
                    to be less affected by identifier style; however, beginners benefit from the use
                    of camel casing with respect to accuracy and effort.},
    location      = {Department of Computer Science, Loyola University Maryland, Baltimore, USA},
    issn          = {1573-7616},
    doi           = {10.1007/s10664-012-9201-4},
    url           = {https://www.researchgate.net/publication/257560017_The_impact_of_identifier_style_on_effort_and_comprehension},
    urlaccessdate = {2017-10-31},
}


@article{womenAndMen,
    title         = {Women and men -- Different but equal: On the impact of identifier style on source code reading},
    author        = {Zohreh Sharafi and Zéphyrin Soh and Yann-Gaël Guéhéneuc},
    year          = {2012},
    month         = {06},
    journal       = {20th IEEE International Conference on Program Comprehension},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {Program comprehension is preliminary to any program evolution task. Researchers
                    agree that identifiers play an important role in code reading and program understanding
                    activities. Yet, to the best of our knowledge, only one work investigated the impact of gender
                    on the memorability of identifiers and thus, ultimately, on program comprehension. This paper
                    reports the results of an experiment involving 15 male subjects and nine female subjects to
                    study the impact of gender on the subjects' visual effort, required time, as well as accuracy to
                    recall Camel Case versus Underscore identifiers in source code reading. We observe no
                    statistically-significant difference in term of accuracy, required time, and effort. However,
                    our data supports the conjecture that male and female subjects follow different comprehension
                    strategies: female subjects seem to carefully weight all options and spend more time to rule out
                    wrong answers while male subjects seem to quickly set their minds on some answers, possibly the
                    wrong ones. Indeed, we found that the effort spent on wrong answers is significantly higher for
                    female subjects and that there is an interaction between the effort that female subjects
                    invested on wrong answers and their higher percentages of correct answers when compared to male
                    subjects.},
    location      = {Passau, Germany},
    issn          = {1092-8138},
    doi           = {10.1109/ICPC.2012.6240505},
    url           = {https://www.researchgate.net/publication/261095133_Women_and_men_-_Different_but_equal_On_the_impact_of_identifier_style_on_source_code_reading},
    urlaccessdate = {2017-10-31},
}


@Inbook{aPrettyGoodFormatting,
    title         = {A Pretty Good Formatting Pipeline},
    author        = {Bagge, Anya Helee and Hasu, Tero},
    editor        = {Erwig, Martn and Paige, Richard F. and Van Wyk, Eric},
    bookTitle     = {Software Language Engineering: 6th International Conference, SLE 2013, Indianapolis, IN, USA, October 26-28, 2013. Proceedings},
    year          = {2013},
    month         = {10},
    publisher     = {Springer},
    address       = {Berlin, Germany},
    pages         = {177--196},
    abstract      = {Proper formatting makes the structure of a program apparent and aids program
                    comprehension. The need to format code arises in code generation and
                    transformation, as well as in normal reading and editing situations. Commonly
                    used pretty-printing tools in transformation frameworks provide an easy way to
                    produce indented code that is fairly readable for humans, without reaching the
                    level of purpose-built reformatting tools, such as those built into IDEs. This
                    paper presents a library of pluggable components, built to support style-based
                    formatting and reformatting of code, and to enable further experimentation with
                    code formatting.},
    location      = {Bergen Language Design Laboratory, Dept. of Informatics, University of Bergen, Norway},
    isbn          = {978-3-319-02654-1},
    doi           = {10.1007/978-3-319-02654-1_10},
    url           = {https://www.researchgate.net/publication/300351526_A_Pretty_Good_Formatting_Pipeline},
    urlaccessdate = {2017-10-31},
}


@article{autofoldingForSourceCode,
    title         = {Autofolding for Source Code Summarization},
    author        = {Jaroslav Fowkes and Pankajan Chanthirasegaran and Razvan Ranca},
    journal       = {IEEE Transactions on Software Engineering},
    year          = {2017},
    month         = {02},
    volume        = {PP},
    issue         = {99},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {Developers spend much of their time reading and browsing source code, raising
                    new opportunities for summarization methods. Indeed, modern code editors provide
                    code folding, which allows one to selectively hide blocks of code. However this
                    is impractical to use as folding decisions must be made manually or based on
                    simple rules. We introduce the autofolding problem, which is to automatically
                    create a code summary by folding less informative code regions. We present a
                    novel solution by formulating the problem as a sequence of AST folding
                    decisions, leveraging a scoped topic model for code tokens. On an annotated set
                    of popular open source projects, we show that our summarizer outperforms simpler
                    baselines, yielding a 28\% error reduction. Furthermore, we find through a case
                    study that our summarizer is strongly preferred by experienced developers. More
                    broadly, we hope this work will aid program comprehension by turning code
                    folding into a usable and valuable tool.},
    location      = {School of Informatics, University of Edinburgh, Edinburgh, UK},
    issn          = {0098-5589},
    doi           = {10.1109/TSE.2017.2664836},
    url           = {https://www.researchgate.net/publication/260911164_Autofolding_for_Source_Code_Summarization},
    urlaccessdate = {2017-10-31},
}

