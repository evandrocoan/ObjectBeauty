
%
% Graphical Java application for managing BibTeX and BibLaTeX (.bib) databases (Windows/Linux/MAC)
% https://github.com/JabRef/jabref
%
% BibDesk-like software for Windows
% https://tex.stackexchange.com/questions/9454/bibdesk-like-software-for-windows
%
% LaTeX Bibliography Management
% https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management#BibTeX
%
%
% $ date "+%Y-%m-%d %H:%M:%S"
% 2017-08-28 09:18:02
%
% YYYY-MM-DD format date in shell script
% https://stackoverflow.com/questions/1401482/yyyy-mm-dd-format-date-in-shell-script
%


@thesis{structuredEditorStudy,
    title         = {Estudo e Criação de um Editor de Código Estruturado},
    author        = {Lucas Boppre Niehues},
    year          = {2013},
    publisher     = {University Library},
    address       = {Florianópolis, Santa Catarina, Brazil},
    abstract      = {Virtually all of the code editors for business use in general\hyp{}purpose
                    languages are oriented to lines and characters. The alternative, editors working
                    directly with the syntactic tree, has received most attention in this area,
                    aiming to have important advantages, such as automatic control of the structure
                    and greater efficiency in the script. The purpose of this paper is to study these
                    alternating active editors, called structured editors or syntax-driven editors,
                    comparing them with traditional editors. Once the advantages and disadvantages
                    have been raised, a structured editor will be developed that best fits in with
                    this medium. This work first provides for an in-depth study of these structured
                    editors, in the context of programming in general or non-general purpose
                    languages. Previous efforts in this area will be sought, assessing their impact,
                    lessons learned and limitations encountered. In a second moment these lessons
                    will be used for the development of a proprietary, fully structured or hybrid
                    editor, in order to increase the efficiency of the programmer. Preferably this
                    editor will be prepared for a standard general purpose language and will be able
                    to edit actual programs. This work aimed to better understand the principles
                    behind structured editors, seeking information on their effectiveness,
                    advantages, disadvantages and factors involved in their lack of adoption. It is
                    also envisaged the construction of a functional structured editor, capable of
                    being used on a daily basis, that makes better use of these advantages.},
    type          = {Graduation Thesis submitted to the Computer Science Department},
    institution   = {Federal University of Santa Catarina},
    location      = {Florianópolis, Santa Catarina, Brazil},
    note          = {[Departamento de Informática e Estatística]},
    url           = {https://tcc.inf.ufsc.br},
    urlaccessdate = {2017-03-01},
}


@book{commandLineInterface,
    title         = {The Command Line Interface. In: Practical C++ Design},
    author        = {Adam B. Singer},
    year          = {2017},
    abstract      = {This is a very exciting chapter. While command line interfaces (CLIs) may not
                    have the cachet of modern graphical user interfaces (GUIs), especially those of
                    phones or tablets, the CLI is still a remarkably useful and effective user
                    interface. This chapter details the design and implementation of the command
                    line interface for pdCalc. By the end of this chapter, we will, for the first
                    time, have a functioning (albeit feature incomplete) calculator, which is a
                    significant milestone in our development.},
    pages         = {97-113},
    edition       = {1},
    publisher     = {Apress},
    address       = {Berkeley, CA},
    isbn          = {978-1-4842-3056-5},
    doi           = {10.1007/978-1-4842-3057-2\_5},
    location      = {Online},
    url           = {https://www.researchgate.net/publication/320120365_The_Command_Line_Interface},
    urlaccessdate = {2017-10-10},
}


@online{Atwood,
    title         = {Death to the Space Infidels!},
    author        = {Jeff Atwood},
    abstract      = {Ah, spring. What a wonderful time of year. A time when young programmers' minds
                    turn to thoughts of ... never ending last-man-standing filibuster arguments
                    about code formatting. Naturally. And there is no argument more evergreen than
                    the timeless debate between tabs and spaces.},
    year          = {2009},
    location      = {Online},
    url           = {http://www.codinghorror.com/blog/2009/04/death-to-the-space-infidels.html},
    urlaccessdate = {2017-03-01},
}


@online{Geukens,
    title         = {Is imposing the same code format for all developers a good idea?},
    author        = {Stijn Geukens},
    abstract      = {We are considering to impose a single standard code format in our project (auto
                    format with save actions in Eclipse). The reason is that currently there is a
                    big difference in the code formats used by several (>10) developers which makes
                    it harder for one developer to work on the code of another developer. The same
                    Java file sometimes uses 3 different formats.},
    year          = {2013},
    location      = {Online},
    url           = {https://softwareengineering.stackexchange.com/questions/189274/is-imposing-the-same-code-format-for-all-developers-a-good-idea},
    urlaccessdate = {2017-03-01},
}


@online{Schweitzer,
    title         = {Powerful code indenter front-end, UniversalIndentGUI},
    author        = {Thomas Schweitzer},
    publisher     = {Online Material; \url{http://universalindent.sourceforge.net/index.php}},
    year          = {2012},
    abstract      = {Ever concerned about how your code looks like? Ever heard of different
                    indenting styles, for example K\&R? Ever received code from someone else who
                    didn't care about code formatting? Ever tried to configure a code indenter to
                    convert such code to your coding style? Ever got bored by that tedious "changing
                    a parameter"-"call the indeter"-"try and error" procedure? Help is close to you.
                    UniversalIndentGUI offers a live preview for setting the parameters of nearly
                    any indenter. You change the value of a parameter and directly see how your
                    reformatted code will look like. Save your beauty looking code or create an
                    anywhere usable batch/shell script to reformat whole directories or just one
                    file even out of the editor of your choice that supports external tool calls.},
    location      = {Online},
    url           = {https://github.com/danblakemore/universal-indent-gui},
    urlaccessdate = {2017-03-01},
}


@online{Skinner,
    title         = {SUBLIME TEXT 3 DOCUMENTATION, Syntax Definitions},
    author        = {Jon Skinner},
    year          = {2016},
    abstract      = {Sublime Text can use both .sublime-syntax and .tmLanguage files for syntax
                    highlighting. This document describes .sublime-syntax files. Sublime Syntax
                    files are YAML files with a small header, followed by a list of contexts. Each
                    context has a list of patterns that describe how to highlight text in that
                    context, and how to change the current text.},
    location      = {Online},
    url           = {https://www.sublimetext.com/docs/3/syntax.html},
    urlaccessdate = {2017-03-01},
}


@online{prettyPrinter,
    title         = {prettyprinter.de},
    author        = {J.M.},
    year          = {2017},
    abstract      = {This is a source code beautifier (source code formatter), similiar to indent.
                    Please make a backup before you replace your code!},
    location      = {Online},
    url           = {http://prettyprinter.de/},
    urlaccessdate = {2017-03-01},
}


@online{tabsAndSpacesConversion,
    title         = {How to replace spaces with tabs when pasting on a view},
    author        = {Evandro Coan},
    year          = {2017},
    abstract      = {The problem is that I will certainly not notice when I paste something indented
                    with spaces instead of tabs. This is problem because for some file types as
                    .sublime-settings files (or a Makefile), which has the setting
                    translate\_tabs\_to\_spaces set to false, so I would expect to all
                    .sublime-settings files to be indented with tabs, not spaces.},
    location      = {Online},
    url           = {https://forum.sublimetext.com/t/how-to-replace-spaces-with-tabs-when-pasting-on-a-view-with-translate-tabs-to-spaces-set-to-false/32193},
    urlaccessdate = {2017-09-29},
}


@online{synchronizingFolders,
    title         = {Synchronizing folders with rsync},
    author        = {Juan Valencia Escalante},
    year          = {2017},
    abstract      = {In this post I cover the basics of rsync, in preparation for a subsequent post
                    that will cover backups and it's use in conjunction with cronjobs to automatize
                    the backup process. From the copying and synchronization of local files and
                    folders, to it's use for transfer information among computers. Its use as a
                    daemon when SSH is unavailable was moved to it's own section.},
    location      = {Online},
    url           = {http://www.jveweb.net/en/archives/2010/11/synchronizing-folders-with-rsync.html},
    urlaccessdate = {2017-10-10},
}


@article{universalCodeFormatter,
    title         = {Towards a Universal Code Formatter through Machine Learning},
    author        = {Terence Parr and J.J. Vinju},
    month         = {10},
    year          = {2016},
    journal       = {SLE 2016 Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    abstract      = {There are many declarative frameworks that allow us to implement code
                    formatters relatively easily for any specific language, but constructing them is
                    cumbersome. The first problem is that “everybody” wants to format their code
                    differently, leading to either many formatter variants or a ridiculous number of
                    configuration options. Second, the size of each implementation scales with a
                    language’s grammar size, leading to hundreds of rules. In this paper, we solve
                    the formatter construction problem using a novel approach, one that
                    automatically derives formatters for any given language without intervention
                    from a language expert. We introduce a code formatter called CODEB UFF that uses
                    machine learning to abstract formatting rules from a representative corpus,
                    using a carefully designed feature set. Our experiments on Java, SQL, and ANTLR
                    grammars show that CODEB UFF is efficient, has excellent accuracy, and is
                    grammar invariant for a given language. It also generalizes to a 4th language
                    tested during manuscript preparation.},
    pages         = {137-151},
    doi           = {10.1145/2997364.2997383},
    isbn          = {978-1-4503-4447-0},
    location      = {Amsterdam, Netherlands},
    url           = {https://www.researchgate.net/publication/309363024_Towards_a_universal_code_formatter_through_machine_learning},
    urlaccessdate = {2017-03-01},
}


@article{industrialApplication,
    title         = {An industrial application of context-sensitive formatting},
    author        = {M.G.J. van den Brand and A.T. Kooiker and N.P. Veerman and J.J. Vinju},
    year          = {2005},
    abstract      = {Automated formatting is an important technique for the software maintainer. It
                    is either applied separately to improve the readability of source code, or as
                    part of a source code transformation tool chain. In this paper we report on the
                    application of generic tools for constructing formatters. In an industrial
                    setting automated formatters need to be tailored to the requirements of the
                    customer. The (legacy) programming language or dialect and the corporate
                    formatting conventions are specific and non-negotiable. Can generic formatting
                    tools deal with such unexpected requirements? Driven by an industrial case of 78
                    thousand lines of Cobol code, several limitations in existing formatting
                    technology have been addressed. We improved its flexibility by replacing a
                    generative phase by a generic tool, and we added a little expressiveness to the
                    formatting backend. Most importantly, we employed a multi-stage formatting
                    architecture that can cope with any kind of formatting convention using more
                    computational power.},
    publisher     = {Online},
    url           = {https://www.researchgate.net/publication/228540036_An_industrial_application_of_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{programIndentation,
    title         = {Program indentation and comprehensibility},
    author        = {Richard J. Miara and Joyce A. Musselman and Juan A. Navarro and Ben Shneiderman},
    month         = {11},
    year          = {1983},
    journal       = {Communications of the ACM},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    volume        = {26},
    issue         = {11},
    abstract      = {The consensus in the programming community is that indentation aids program
                    comprehension, although many studies do not back this up. We tested program
                    comprehension on a Pascal program. Two styles of indentation were used --
                    blocked and non-blocked -- in addition to four passible levels of indentation
                    (0, 2, 4, 6 spaces). Both experienced and novice subjects were used. Although
                    the blocking style made no difference, the level of indentation had a
                    significant effect on program comprehension. (2--4 spaces had the highest mean
                    score for program comprehension.) We recommend that a moderate level of
                    indentation be used to increase program comprehension and user satisfaction.},
    pages         = {861-867},
    location      = {Online},
    doi           = {10.1145/182.358437},
    url           = {https://www.researchgate.net/publication/234809222_Program_indentation_and_comprehensibility},
    urlaccessdate = {2017-09-07},
}


@article{independentFramework,
    title         = {A Language Independent Framework for Context-sensitive Formatting},
    author        = {M.G.J. Van den Brand and A.T. Kooiker and J.J. Vinju},
    month         = {03},
    year          = {2006},
    journal       = {CSMR '06 Proceedings of the Conference on Software Maintenance and Reengineering},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    volume        = {26},
    issue         = {1},
    abstract      = {Automated formatting is an important technique for the software maintainer. It
                    is either applied separately to improve the readability of source code, or as
                    part of a source code transformation tool chain. In this paper we report on the
                    application of generic tools for constructing formatters. In an industrial
                    setting automated formatters need to be tailored to the requirements of the
                    customer. The (legacy) programming language or dialect and the corporate
                    formatting conventions are specific and non-negotiable. Can generic formatting
                    tools deal with such unexpected requirements? Driven by an industrial case of
                    nearly 80 thousand lines of Cobol code, several limitations in existing
                    formatting technology have been addressed. We improved its flexibility by
                    replacing a generative phase by a generic tool, and we added a little
                    expressiveness to the formatting back end. Most importantly, we employed a
                    multi-stage formatting framework that can cope with any kind of formatting
                    convention using more computational power.},
    pages         = {103-112},
    doi           = {10.1109/CSMR.2006.4},
    isbn          = {0-7695-2536-9},
    location      = {Bari, Italy},
    url           = {https://www.researchgate.net/publication/4226896_A_language_independent_framework_for_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{architectureFormatting,
    title         = {An architecture for context-sensitive formatting},
    author        = {M.G.J. van den Brand and A.T. Kooiker and J.J. Vinju and N.P. Veerman},
    month         = {09},
    year          = {2005},
    abstract      = {We developed an architecture for context-sensitive formatting of source code.
                    The architecture was implemented and applied in an industrial formatting case.},
    journal       = {21st IEEE International Conference on Software Maintenance (ICSM'05)},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    doi           = {10.1109/ICSM.2005.17},
    isbn          = {0-7695-2368-4},
    location      = {Budapest, Hungary, Hungary},
    url           = {https://www.researchgate.net/publication/4175894_An_architecture_for_context-sensitive_formatting},
    urlaccessdate = {2017-09-07},
}


@article{prettyPrinting,
    title         = {Pretty-printing for software reengineering},
    author        = {Merijn De Jonge},
    month         = {10},
    year          = {2002},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {Automatic software reengineerings change or repair existing software systems.
                    They are usually tailor-made for a specific customer and language dependent.
                    Maintaining similar reengineerings for multiple customers and different language
                    dialects might therefore soon become problematic unless advanced language
                    technology is being used. Generic pretty-printing is part of such technology and
                    is the subject of this paper. We discuss specific pretty-print aspects of
                    software reengineering such as fulfilling customer-specific format conventions,
                    preserving existing layout, and producing multiple output formats. In addition,
                    we describe pretty-print techniques that help to reduce maintenance effort of
                    tailor-made reengineerings supporting multiple language dialects. Applications,
                    such as COBOL reengineering and SDL documentation generation show that our
                    techniques, implemented in the generic pretty-printer GPP, are feasible.},
    journal       = {International Conference on Software Maintenance, 2002. Proceedings},
    doi           = {10.1109/ICSM.2002.1167816},
    isbn          = {0-7695-1819-2},
    location      = {Montreal, Quebec, Canada},
    url           = {https://www.researchgate.net/publication/3998748_Pretty-Printing_for_Software_Reengineering},
    urlaccessdate = {2017-09-07},
}


@article{massMaintenance,
    title         = {Automated Mass Maintenance of Software Assets},
    author        = {Niels Veerman},
    month         = {03},
    year          = {2007},
    publisher     = {IEEE Computer Society},
    address       = {New York, NY, USA},
    abstract      = {This is a research summary of a PhD project in the area of massive software
                    maintenance automation. We explain the context, approach, and contributions.},
    journal       = {11th European Conference on Software Maintenance and Reengineering (CSMR'07)},
    doi           = {10.1109/CSMR.2007.15},
    isbn          = {0-7695-2802-3},
    location      = {Amsterdam, Netherlands},
    url           = {https://www.researchgate.net/publication/221569579_Automated_Mass_Maintenance_of_Software_Assets},
    urlaccessdate = {2017-09-11},
}


@article{legacyAssets,
    title         = {Towards automated modification of legacy assets},
    author        = {Alex Sellink and Chris Verhoef},
    month         = {01},
    year          = {2000},
    journal       = {Annals of Software Engineering},
    publisher     = {Kluwer Academic Publishers},
    address       = {Dordrecht, the Netherlands},
    volume        = {9},
    issue         = {1-4},
    pages         = {315-336},
    abstract      = {In this paper we argue that there is a necessity for automating modifications
                    to legacy assets. We propose a five layered process for the introduction and
                    employment of tool support that enables automated modification to entire legacy
                    systems. Furthermore, we elaborately discuss each layer on a conceptual level,
                    and we make appropriate references to sources where technical contributions
                    supporting that particular layer can be found. We sketch the perspective that
                    more and more people working in the software engineering area will be
                    contributing to working on existing systems and/or tools to support such work.},
    location      = {Red Bank, NJ, USA},
    doi           = {10.1023/A:1018941228255},
    url           = {https://www.researchgate.net/publication/2825635_Towards_Automated_Modification_of_Legacy_Assets},
    urlaccessdate = {2017-09-11},
}


@article{softwarePortfolio,
    title         = {Automated maintenance of a software portfolio},
    author        = {Niels Veerman},
    month         = {10},
    year          = {2006},
    journal       = {Science of Computer Programming - Special issue on source code analysis and manipulation (SCAM 2005)},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, Netherlands},
    volume        = {62},
    issue         = {3},
    pages         = {287-317},
    abstract      = {This is an experience report on automated mass maintenance of a large Cobol
                    software portfolio. A company in the financial services and insurance industry
                    upgraded their database system to a new version, affecting their entire software
                    portfolio. The database system was accessed by the portfolio of 45 systems,
                    totalling nearly 3000 programs and covering over 4 million lines of Cobol code.
                    We upgraded the programs to the new database version using several automatic
                    tools, and we performed an automated analysis supporting further manual
                    modifications by the system experts. The automatic tools were built using a
                    combination of lexical and syntactic technology, and they were deployed in a
                    mass update factory to allow large-scale application to the software portfolio.
                    The updated portfolio has been accepted and taken into production by the
                    company, serving over 600 employees with the new database version. In this
                    paper, we discuss the automated upgrade from problem statement to project
                    costs.},
    doi           = {10.1016/j.scico.2006.04.006},
    location      = {Amsterdam, The Netherlands, The Netherlands},
    url           = {https://www.researchgate.net/publication/222831264_Automated_maintenance_of_a_software_portfolio},
    urlaccessdate = {2017-09-12},
}


@article{pushdownAutomata,
    title         = {2-Head Pushdown Automata},
    author        = {Awe Ayodeji Samson},
    month         = {06},
    year          = {2015},
    journal       = {Procedia - Social and Behavioral Sciences},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, Netherlands},
    volume        = {195},
    issue         = {1},
    pages         = {2037-2046},
    abstract      = {Finite state automata recognize regular languages which can be used in text
                    processing, compilers, and hardware design. Two head finite automata accept
                    linear context free languages. In addition, pushdown automata are able to
                    recognize context free languages which can be used in programming languages and
                    artificial intelligence. The finite automaton has deterministic and
                    non-deterministic version likewise the two head finite automata and the pushdown
                    automata. The deterministic version of these machines is such that there is no
                    choice of move in any situation while the non-deterministic version has a choice
                    of move. In this research the 2-head pushdown automata are described which is
                    more powerful than the pushdown automata and it is able to recognize some
                    non-context free languages as well. During this work, the main task is to
                    characterize these machines.},
    doi           = {10.1016/j.sbspro.2015.06.225},
    location      = {Department of Mathematics, Eastern Mediterranean University, Mersin 10 Turkey, Famagusta, North Cyprus},
    url           = {https://www.researchgate.net/publication/282556609_2-Head_Pushdown_Automata},
    urlaccessdate = {2017-09-12},
}


@article{aspectOriented,
    title         = {Aspect-oriented model-driven code generation: A systematic mapping study},
    author        = {Abid Mehmood and Dayang Norhayati Abang Jawawi},
    month         = {09},
    year          = {2012},
    journal       = {Information and Software Technology},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, Netherlands},
    volume        = {55},
    issue         = {2},
    pages         = {395-411},
    abstract      = {Context: Model-driven code generation is being increasingly applied to enhance
                    software development from perspectives of maintainability, extensibility and
                    reusability. However, aspect-oriented code generation from models is an area
                    that is currently underdeveloped. Objective: In this study we provide a survey
                    of existing research on aspect-oriented modeling and code generation to discover
                    current work and identify needs for future research. Method: A systematic
                    mapping study was performed to find relevant studies. Classification schemes
                    have been defined and the 65 selected primary studies have been classified on
                    the basis of research focus, contribution type and research type. Results: The
                    papers of solution proposal research type are in a majority. All together
                    aspect-oriented modeling appears being the most focused area divided into
                    modeling notations and process (36\%) and model composition and interaction
                    management (26\%). The majority of contributions are methods. Conclusion:
                    Aspect-oriented modeling and composition mechanisms have been significantly
                    discussed in existing literature while more research is needed in the area of
                    model-driven code generation. Furthermore, we have observed that previous
                    research has frequently focused on proposing solutions and thus there is need
                    for research that validates and evaluates the existing proposals in order to
                    provide firm foundations for aspect-oriented model-driven code generation.},
    location      = {Department of Software Engineering, Faculty of Computer Science and Information Systems, Universiti Teknologi Malaysia, 81310 Skudai, Johor, Malaysia},
    doi           = {10.1016/j.infsof.2012.09.003},
    url           = {https://www.researchgate.net/publication/257391227_Aspect-oriented_model-driven_code_generation_A_systematic_mapping_study},
    urlaccessdate = {2017-09-12},
}


@article{aspectOrientationReview,
    title         = {A Review: Analysis of Aspect Orientation and Model Driven Engineering for Code Generation},
    author        = {Dhiraj Gurunule and Madhu Nashipudimath},
    month         = {03},
    year          = {2015},
    journal       = {Procedia Computer Science},
    publisher     = {Elsevier North-Holland, Inc.},
    address       = {Amsterdam, Netherlands},
    volume        = {45},
    issue         = {1},
    pages         = {852-861},
    abstract      = {In the development of large and complex software application software engineers
                    has to focuses on many requirements other than desired application’s requirement
                    at the coding and design level. Code Generation is a technique which is use to
                    automatically generates lower level executable code from higher level design
                    artifact. Code generation provides design of the code at higher abstract level
                    so that software developers can focuses on higher level design problem
                    simultaneously meeting goals of desired application. Aspect Orientation (AO) is
                    characterizing by identification and separation of different concerns and
                    encapsulates them in modules. Concern is an interest which pertains to system
                    operation, function, development or any other things which is important to one
                    of the stakeholder. Model Driven Engineering (MDE) is a development paradigm
                    which is characterize by model transformation and uses models to support various
                    stages of the development life cycle. Model is primary artifact in MDE. In this
                    paper we analyze both techniques i.e. AO and MDE, and how they can be used for
                    code generation.},
    location      = {Information Technology Department and Computer Department PIIT, New Panvel, India},
    doi           = {10.1016/j.procs.2015.03.171},
    url           = {https://www.researchgate.net/publication/276899518_A_Review_Analysis_of_Aspect_Orientation_and_Model_Driven_Engineering_for_Code_Generation},
    urlaccessdate = {2017-09-12},
}


@article{quantificationOfInterface,
    title         = {Quantification of interface visual complexity},
    author        = {Aliaksei Miniukovich and Antonella De Angeli},
    month         = {03},
    year          = {2014},
    journal       = {Proceedings of the 2014 International Working Conference on Advanced Visual Interfaces},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    pages         = {153-160},
    abstract      = {Designers strive for enjoyable user experience (UX) and put a significant
                    effort into making graphical user interfaces (GUI) both usable and beautiful.
                    Our goal is to minimize their effort: with this purpose in mind, we have been
                    studying automatic metrics of GUI qualities. These metrics could enable
                    designers to iterate their designs more quickly. We started from the
                    psychological findings that people tend to prefer simpler things. We then
                    assumed visual complexity determinants also determine visual aesthetics and
                    outlined eight of them as belonging to three dimensions: information amount
                    (visual clutter and color variability), information organization (symmetry,
                    grid, ease-of-grouping and prototypicality), and information discriminability
                    (contour density and figure-ground contrast). We investigated five determinants
                    (visual clutter, symmetry, contour density, figure-ground contrast and color
                    variability) and proposed six associated automatic metrics. These metrics take
                    screenshots of GUI as input and can thus be applied to any type of GUI. We
                    validated the metrics through a user study: we gathered the ratings of immediate
                    impressions of GUI visual complexity and aesthetics, and correlated them with
                    the output of the metrics. The output explained up to 51\% of aesthetics ratings
                    and 50\% of complexity ratings. This promising result could be further extended
                    towards the creation of tLight, our automatic GUI evaluation tool.},
    location      = {University of Trento, Como, Italy},
    doi           = {10.1145/2598153.2598173},
    isbn          = {978-1-4503-2775-6},
    url           = {https://www.researchgate.net/publication/266657991_Quantification_of_interface_visual_complexity},
    urlaccessdate = {2017-10-10},
}


@article{toolsForProjectManagement,
    title         = {Comparison of open source tools for project management},
    author        = {André Marques Pereira and Rafael Queiroz Gonçalves and Christiane Gresse von Wangenheim and Luigi Buglione},
    month         = {03},
    year          = {2013},
    journal       = {International Journal of Software Engineering and Knowledge Engineering},
    publisher     = {World Scientific Publishing, },
    address       = {Singapore},
    volume        = {23},
    issue         = {02},
    pages         = {189-209},
    abstract      = {Software projects often fail, because they are not adequately managed. The
                    establishment of effective and efficient project management practices still
                    remains a key challenge to software organizations. Striving to address these
                    needs, "best practice" models, such as, the Capability Maturity Model
                    Integration (CMMI) or the Project Management Body of Knowledge (PMBOK), are
                    being developed to assist organizations in improving project management.
                    Although not required, software tools can help implement the project management
                    process in practice. In order to provide comprehensive, low-cost tool support
                    for project management, specifically, for small and medium enterprises (SMEs),
                    in this paper we compare the most popular free/open-source web-based project
                    management tools with respect to their compliance to PMBOK and CMMI for
                    Development (CMMI-DEV). The results of this research can be used by
                    organizations to make decisions on tool adoptions as well as a basis for
                    evolving software tools in alignment with best practices models.},
    location      = {Federal University of Santa Catarina (UFSC), Florianópolis, Santa Catarina, Brazil},
    doi           = {10.1142/S0218194013500046},
    url           = {https://www.researchgate.net/publication/273569026_Comparison_of_open_source_tools_for_project_management},
    urlaccessdate = {2017-10-27},
}


@article{naturalCodingConventions,
    title         = {Learning Natural Coding Conventions},
    author        = {Miltiadis Allamanis and Earl T. Barr and Charles Sutton},
    month         = {11},
    year          = {2014},
    journal       = {Proceeding FSE 2014 Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
    publisher     = {ACM},
    address       = {New York, NY, USA},
    volume        = {23},
    issue         = {02},
    pages         = {281-293},
    abstract      = {Every programmer has a characteristic style, ranging from preferences about
                    identifier naming to preferences about object relationships and design patterns.
                    Coding conventions define a consistent syntactic style, fostering readability
                    and hence maintainability. When collaborating, programmers strive to obey a
                    project’s coding conventions. However, one third of reviews of changes contain
                    feedback about coding conventions, indicating that programmers do not always
                    follow them and that project members care deeply about adherence. Unfortunately,
                    programmers are often unaware of coding conventions because inferring them
                    requires a global view, one that aggregates the many local decisions programmers
                    make and identifies emergent consensus on style. We present NATURALIZE, a
                    framework that learns the style of a codebase, and suggests revisions to improve
                    stylistic consistency. NATURALIZE builds on recent work in applying statistical
                    natural language processing to source code. We apply NATURALIZE to suggest
                    natural identifier names and formatting conventions. We present four tools
                    focused on ensuring natural code during development and release management,
                    including code review. NATURALIZE achieves 94\% accuracy in its top suggestions
                    for identifier names. We used NATURALIZE to generate 18 patches for 5 open
                    source projects: 14 were accepted.},
    location      = {Hong Kong, China},
    doi           = {10.1145/2635868.2635883},
    url           = {https://www.researchgate.net/publication/260250447_Learning_Natural_Coding_Conventions},
    urlaccessdate = {2017-10-27},
}


@article{codePlagiarismDetection,
    title         = {Style Analysis for Source Code Plagiarism Detection},
    author        = {Olfat Mirza and Mike Joy},
    month         = {06},
    year          = {2015},
    journal       = {International Conference Plagiarism across Europe and Beyond 2015},
    publisher     = {Online},
    address       = {\url{https://plagiarism.pefka.mendelu.cz/?sec=cf15#proc}},
    pages         = {53–61},
    abstract      = {Plagiarism has become an increasing problem in higher education in recent
                    years. A number of research papers have discussed the problem of plagiarism in
                    terms of text and source code and the techniques to detect it in various
                    contexts. There is a variety of easy ways of copying others’ work because the
                    source code can be obtained from online source code banks and textbooks, which
                    makes plagiarism easy for students. Source code plagiarism has a very specific
                    definition, and Parker and Hamblen define plagiarism on software as “A program
                    that has been produced from another program with a small number of routine
                    transformations”. The transformations can range from very simple changes to very
                    difficult ones, which can be one of the six levels of program modifications that
                    are given by Faidhi and Robinson. Coding style is a way to detect source code
                    plagiarism because it relates to programmer personality without affecting the
                    logic of a program, and can be used to differentiate between different code
                    authors. This paper reviews a number of publications which report style
                    comparison to detect source code plagiarism in order to determine research gaps
                    and explore areas where this approach can be improved. A summary of the
                    plagiarism techniques in which style analysis can help identify plagiarism is
                    presented.},
    location      = {Brno, Czech Republic},
    url           = {https://www.researchgate.net/publication/303932091_Style_Analysis_for_Source_Code_Plagiarism_Detection},
    urlaccessdate = {2017-10-27},
}


@inproceedings{annotationAssistant,
    title     = {An Annotation Assistant for Interactive Debugging of Programs with Common Synchronization Idioms},
    author    = {Elmas, Tayfun and Sezgin, Ali and Tasiran, Serdar and Qadeer, Shaz},
    booktitle = {Proceedings of the 7th Workshop on Parallel and Distributed Systems: Testing, Analysis, and Debugging},
    series    = {PADTAD '09},
    year      = {2009},
    pages     = {10:1--10:11},
    publisher = {ACM},
    address   = {New York, NY, USA},
    abstract  = {This paper explores an approach to improving the practical usability of static
                verification tools for debugging synchronization idioms. Synchronization idioms such
                as mutual exclusion and readers/writer locks are widely-used to ensure atomicity of
                critical regions. We present an annotation assistant that automatically generates
                program annotations. These annotations express noninterference between program
                statements, ensured by the synchronization idioms, and are used to identify atomic
                code regions. This allows the programmer to debug the use of the idioms in the
                program. We start by formalizing several well-known idioms by providing an abstract
                semantics for each idiom. For programs that use these idioms, we require the
                programmer to provide a few predicates linking the idiom with its realization in
                terms of program variables. From these, we automatically generate a proof script
                that is mechanically checked. These scripts include steps such as automatically
                generating assertions and annotating program actions with them, introducing
                auxiliary variables and invariants. We have successfully shown the applicability of
                this approach to several concurrent programs from the literature.},
    articleno = {10},
    numpages  = {11},
    doi       = {10.1145/1639622.1639632},
    isbn      = {978-1-60558-655-7},
    acmid     = {1639632},
    location  = {Chicago, Illinois},
    url       = {http://doi.acm.org/10.1145/1639622.1639632},
    keywords  = {atomicity, concurrent programs, synchronization idioms},
}


@Inbook{automaticSynthesis,
    title         = {Towards Automatic Synthesis of Software Verification Tools},
    author        = {Rybalchenko, Andrey},
    editor        = {Donaldson, Alastair and Parker, David},
    bookTitle     = {Model Checking Software: 19th International Workshop, SPIN 2012, Oxford, UK, July 23-24, 2012. Proceedings},
    year          = {2012},
    volume        = {7385},
    publisher     = {Springer},
    address       = {Berlin, Germany},
    pages         = {22--22},
    abstract      = {Software complexity is growing, so is the demand for software verification. Soon,
                    perhaps within a decade, wide deployment of software verification tools will be
                    indispensable or even mandatory to ensure software reliability in a large number of
                    application domains, including but not restricted to safety and security critical
                    systems. To adequately respond to the demand we need to eliminate tedious aspects of
                    software verifier development, while providing support for the accomplishment of
                    creative aspects.},
    location      = {},
    doi           = {10.1007/978-3-642-31759-0\_3},
    isbn          = {978-3-642-31759-0},
    url           = {https://link.springer.com/chapter/10.1007/978-3-642-31759-0_3},
    urlaccessdate = {2017-10-30},
}

