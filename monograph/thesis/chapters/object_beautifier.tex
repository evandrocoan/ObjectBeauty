

% The \phantomsection command is needed to create a link to a place in the document that is not a
% figure, equation, table, section, subsection, chapter, etc.
%
% When do I need to invoke \phantomsection?
% https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection
\phantomsection


% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{Object Beautifier}\label{sec:software_implementation}


\section{Introduction}

This work aims to create a formatter (single software) of easy configuration
and expansion capable of encompassing the programming languages that exist,
based on a specific use of regular expressions. The strategy is not to be
relaying on the syntax of the programming languages parsed. With it in mind,
we will treat them as a common text, and it will be up to the end user to
configure the transformations/formatting to be applied in the text, giving
reasonably more freedom to easily configure several programming languages
(if not them all), taking advantage of the fact which many of them share
similar structures if not identical.

As a result, it is expected to have a Universal Beautifier capable of
covering existing languages, and which is easily extendable to cover new
languages. The key points of this approach are the reusability of components
between languages. For example, `if/for/while'\s in C++ and Java have of the
same structure, therefore accordingly to this approach we have to write only
once the specification for that language component.

Such software ideia may to a certain extent may continue a branch of the of
the student `Lucas Boppre Niehues'\s graduation thesis, oriented by the
Professor `Olinto José Varela Furtado', entitled 'Study and Creating a
Structured Code Editor' defended in 2013/1 \cite{structuredEditorStudy}.
While reading its work, the following section that links to one of the
proposals of this work, in the chapter: `8.1.2 Separation of display and
output format\footnote{Translation of: \brazilword{Separação de formato de
exibição e de saída}}':

\begin{citacao}
The ways that code is displayed to the user and that it is saved to disk are
controlled by different configuration files. The `theme.ini' file contains,
among other settings, information on how to serialize the syntax tree.
\cite[our translation]{structuredEditorStudy} \footnote{\brazilword{As
formas que o código é exibido ao usuário e que ele é salvo em disco são
controladas por arquivos de configuração distintos. O arquivo `theme.ini'
contém, entre outras configurações, informações de como serializar a árvore
sintática.}}
\end{citacao}
\begin{citacao}
The output format setting is given the same way, but in a separate file,
called `output \_format.ini'. The decision of this separation was in view of
teams of programmers who want to use a single convention for the saved
files, but keep the display the choice of each. So members of this team can
share their `output\_format.ini 'files while customizing the `theme.ini'
file to their liking. \cite[our translation]{structuredEditorStudy}
\footnote{\brazilword{A configuração de formato de saída é dada da mesma
forma, mas em um arquivo separado, chamado `output\_format.ini'. A decisão
desta separação foi em vista de equipes de programadores que queiram
utilizar uma convenção única para os arquivos salvos, mas manter a exibição
a escolha de cada um. Assim os integrantes desta equipe podem compartilhar
os seus arquivos `output\_format.ini' enquanto personalizam o arquivo
`theme.ini' a seu gosto.}}
\end{citacao}

Based on this, we may think about writing plugins for common text
editors/IDEs as Sublime Text. So while loading files from the disk, such
plugin calls the formatter and does the formatting according to the display
settings for the user. After that, when the user saves the file, the file
with the original formatting is returned.

To assist in this process, an autoconfiguration module is a great help. It
detects how the source code is formatted and creates configuration files for
it. So when saving the file, the file is automatically saved in the
formatting it was originally read from the file system. So we have the same
benefit of structured editors as the proposed work of
\textcite{structuredEditorStudy}. At first we can think with the following
goal/idea for a new automated software tool:

\medskip
\begin{bluebox}
\begin{enumerate}[nolistsep]
    \item Create an easy-to-configure and expandable formatter for the
    existing and coming up programming languages.
\end{enumerate}
\end{bluebox}



\section{The Problem}

The problem proposed to solve is the creation of a Universal Beautifier.
Current softwares are limited to a similar/restricted set, or even a single
language and in addition, many are limited in what they can do for you when
processing/formatting/beautifying your source code.
\cite{universalCodeFormatter}


\subsection{Goals}

The object in the proposed thesis is not initially to support all the
formatting rules for all programming languages, but the creation of an
initial and robust basic formatter capable of being developed to the point
of being easily expanded by programmers with new processing modules and by
end users writing the formatting configuration files.

The theory of the technique proposed is quite simple, but different from the
usual approach because the end user is assigned the responsibility to
dictate more precisely how the beautifying being configured will be
performed. Such tradeoff is the price to pay to allow the creation of a
Universal Beautifier. But notice when it is said, it is supposed to be easy
to set up, it is meant to not be required to do `C++' programming, i.e.
change the source code of the program to set/specify where the beautifying
changes are supposed to be performed.


\subsection{General Goals}

\begin{enumerate}[leftmargin=*]

    \item Write the program in C++ for greater performance, allowing the
    formating/beautifying to be dynamic, i.e.,
    as you type the text,
    the text is formatted for you dynamically.
    So on,
    you can focus more on writing code,
    rather than worrying about spacing,
    alignment, parenthesis control, new lines, and whatsoever else.

    \item Use the `doctest' Framework for writing Unit Tests. Because,
    after searching and testing some frameworks for unit testing in C ++,
    this one was entered as serving very well the project requirements.
    As it causes a very low increment in compile time and allows the tests to be written to the same file where the
    program code is found,
    without including them into the final software.

    \item Using a multi-core version of the algorithm,
    then each one of the rules can be processed in parallel over the same original source code.
    This is a quite complex to write because the rules can easily generate conflicts between them, i.e.,
    over work they are producing.
    To resolve this problem,
    we put each rule to generate a change object which such rule is proposing, i.e.,
    the changes it is working on.
    At the end of the processing of all rules,
    a merging of the generated changes which each rule produced will be created,
    and if two rules wanted to change the same piece a.k.a.
    section of code,
    an exception will be thrown and a Changes\q Handler must be available to resolve this conflict.
    If the Changes\q Handler does not exist at the moment for the existing conflict,
    both changes are discarded and only changes without conflict are reflected, i.e.,
    incorporated into the code.

\end{enumerate}

This proposed work approach has the advantage of do not previously require we, this tools developers,
to be aware of the of programming languages syntaxes which will be parsed by its users.
This come from the fact that we will treat everything just as common plain text,
and end user will be hold responsible to correctly configure the formatting transformations to be applied into the
text or source code.
As so,
giving freedom to easily configure several programming languages,
taking advantage of the fact that many of them share similar but not identical structures.
TODO,
put reference to this.

Existing `Beautifiers' program\s are programming language dependent.
This proposal is to make this process independent of language,
but of dialects like this example:

\begin{lstlisting}
// This is the name used to reference this scope around the settings files.
Scope Name:
%c++_like_block_comment

// This set on which languages this block should be included. Setting it
// to empty will allow it to be parsed for any languages.
Language Inclusion:
Java, C++, Pawn

// Defines a expression which will map the beginning of a exclusion block.
Scope Start:
/\*\*

// Defines a expression which will map the ending of a exclusion block.
Scope End:
\\\*
\end{lstlisting}
\vspace*{-4mm}

In short,
the above approach is only briefly illustrative,
as the software engine is based on regular expressions and a stack of contexts.
This idea to be empowered was initially developed by the text editor `Sublime Text' \cite{Skinner}.
The `Sublime Text' editor uses such block structures to do the syntax highlighting of its source code languages.
The idea here is to use the same approach,
so the end user can define in which regions the `Object Beautifier' should propose, i.e.,
perform changes to the code.
Currently this would be equivalent to the same way `Sublime Text' users\q create their own syntaxes highlighting.
TODO,
put a reference to this.

The strengths of this approach to a code formatter are the reusability of components between languages by the end
user of the application rather than the beautifier programmer,
which makes this software much more generic and opens the possibilities of greater success for the definitive
creation of a Universal Code formatter for programming languages and even plain text files.
For example,
`if/for/while'\q in programming languages like `C++' and `Java' have the same syntax structuring,
so we have to write only once the specification for a language component like `if/for/while'\q.
This has the advantage of being configured by the end user rather than the programmer,
hence it is simpler to configure and expand the set of languages available for beautifying.


\subsection{Obfuscators}

Here you will find the opposite side of Source Code Beautifiers.
Source Code Obfuscators,
is useful to destroy the formatting of the code.
Often used to make it difficult for other people to read or to reduce the size of scripting languages that should be
uploaded/downloaded by internet browsers,
thus reducing internet traffic and saving download bandwidth:

\begin{sloppypar}
\begin{bluebox}\RaggedRight
\begin{enumerate}[leftmargin=*,parsep=0pt]

\item \url{https://en.wikipedia.org/wiki/Obfuscation_(software)}

\item \url{http://www.semdesigns.com/Products/Obfuscators/index.html}

\end{enumerate}
\end{bluebox}
\end{sloppypar}


\section{Future Works}

There is a great number of features and optimizations strategies to be implemented.
But these improvements can be integrated further after the basic toolset implemented on this work.
Nowadays,
the control of spaces in function calls,
class declarations, comments and etc,
are more easily to understand and think.
However,
there is currently a lack of study on how should be implemented,
features like text and source code indentation adjustment,
insertion and removal of redundant parenthesis, and such others.

The user scope definitions (of languages) are restricted to Context Free language\s syntax (powered by stack machines).
Therefore,
if the scope specifications need to be made in terms of Context Sensitive or Recursively Enumerable languages,
it will be necessary to treat these elements directly in the program coding (Turing Machine Complete),
instead of by user configuration files.

Moreover,
you can not easily think of cases where you need more than Free Context handlers to set which parts of the code you
would like to work on.
For reference,
the Sublime Text Editor uniquely uses this approach to perform source code highlight in most diverse languages,
and has showed to fulfill it purpose.
TODO put reference to this.




