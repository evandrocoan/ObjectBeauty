

% The \phantomsection command is needed to create a link to a place in the document that is not a
% figure, equation, table, section, subsection, chapter, etc.
%
% When do I need to invoke \phantomsection?
% https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection
\phantomsection


% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{Object Beautifier}\label{sec:software_implementation}


    \section{Introduction}

    This work aims to create a formatter (single software) of easy configuration
    and expansion capable of encompassing the programming languages that exist,
    based on a specific use of regular expressions. The strategy is not to be
    relaying on the syntax of the programming languages parsed. With it in mind,
    we will treat them as a common text, and it will be up to the end user to
    configure the transformations/formatting to be applied in the text, giving
    reasonably more freedom to easily configure several programming languages
    (if not them all), taking advantage of the fact which many of them share
    similar structures if not identical.

    As a result, it is expected to have a Universal Beautifier capable of
    covering existing languages, and which is easily extendable to cover new
    languages. The key points of this approach are the reusability of components
    between languages. For example, `if/for/while'\s in C++ and Java have of the
    same structure, therefore accordingly to this approach we have to write only
    once the specification for that language component.

    Such software ideia may to a certain extent may continue a branch of the of
    the student `Lucas Boppre Niehues'\s graduation thesis, oriented by the
    Professor `Olinto José Varela Furtado', entitled 'Study and Creating a
    Structured Code Editor' defended in 2013/1 \cite{structuredEditorStudy}.
    While reading its work, the following section that links to one of the
    proposals of this work, in the chapter: `8.1.2 Separation of display and
    output format\footnote{Translation of: \brazilword{Separação de formato de
    exibição e de saída}}':

    \begin{citacao}
    The ways that code is displayed to the user and that it is saved to disk are
    controlled by different configuration files. The `theme.ini' file contains,
    among other settings, information on how to serialize the syntax tree.
    \cite[our translation]{structuredEditorStudy} \footnote{\brazilword{As
    formas que o código é exibido ao usuário e que ele é salvo em disco são
    controladas por arquivos de configuração distintos. O arquivo `theme.ini'
    contém, entre outras configurações, informações de como serializar a árvore
    sintática.}}
    \end{citacao}
    \begin{citacao}
    The output format setting is given the same way, but in a separate file,
    called `output \_format.ini'. The decision of this separation was in view of
    teams of programmers who want to use a single convention for the saved
    files, but keep the display the choice of each. So members of this team can
    share their `output\_format.ini 'files while customizing the `theme.ini'
    file to their liking. \cite[our translation]{structuredEditorStudy}
    \footnote{\brazilword{A configuração de formato de saída é dada da mesma
    forma, mas em um arquivo separado, chamado `output\_format.ini'. A decisão
    desta separação foi em vista de equipes de programadores que queiram
    utilizar uma convenção única para os arquivos salvos, mas manter a exibição
    a escolha de cada um. Assim os integrantes desta equipe podem compartilhar
    os seus arquivos `output\_format.ini' enquanto personalizam o arquivo
    `theme.ini' a seu gosto.}}
    \end{citacao}

    Based on this, we may think about writing plugins for common text
    editors/IDEs as Sublime Text. So while loading files from the disk, such
    plugin calls the formatter and does the formatting according to the display
    settings for the user. After that, when the user saves the file, the file
    with the original formatting is returned.

    To assist in this process, an autoconfiguration module is a great help. It
    detects how the source code is formatted and creates configuration files for
    it. So when saving the file, the file is automatically saved in the
    formatting it was originally read from the file system. So we have the same
    benefit of structured editors as the proposed work of
    \textcite{structuredEditorStudy}. At first we can think with the following
    goal/idea for a new automated software tool:

    \medskip
    \begin{bluebox}
    \begin{enumerate}[nolistsep]
        \item Create an easy-to-configure and expandable formatter for the
        existing and coming up programming languages.
    \end{enumerate}
    \end{bluebox}



\subsection{The Problem}

    The problem proposed to solve is the creation of a Universal Beautifier.
    Current softwares are limited to a similar/restricted set, or even a single
    language and in addition, many are limited in what they can do for you when
    processing/formatting/beautifying your source code.
    \cite{universalCodeFormatter}


\subsection{Goals}

    The object in the proposed thesis is not initially to support all the
    formatting rules for all programming languages, but the creation of an
    initial and robust basic formatter capable of being developed to the point
    of being easily expanded by programmers with new processing modules and by
    end users writing the formatting configuration files.

    The theory of the technique proposed is quite simple, but different from the
    usual approach because the end user is assigned the responsibility to
    dictate more precisely how the beautifying being configured will be
    performed. Such tradeoff is the price to pay to allow the creation of a
    Universal Beautifier. But notice when it is said, it is supposed to be easy
    to set up, it is meant to not be required to do `C++' programming, i.e.
    change the source code of the program to set/specify where the beautifying
    changes are supposed to be performed.


\subsubsection{General Goals}

    \begin{enumerate}[leftmargin=*]

        \item Write the program in C++ for greater performance, allowing the
        formating/beautifying to be dynamic, i.e.,
        as you type the text,
        the text is formatted for you dynamically.
        So on,
        you can focus more on writing code,
        rather than worrying about spacing,
        alignment, parenthesis control, new lines, and whatsoever else.

        \item Use the `doctest' Framework for writing Unit Tests. Because,
        after searching and testing some frameworks for unit testing in C ++,
        this one was entered as serving very well the project requirements.
        As it causes a very low increment in compile time and allows the tests to be written to the same file where the
        program code is found,
        without including them into the final software.

        \item Using a multi-core version of the algorithm,
        then each one of the rules can be processed in parallel over the same original source code.
        This is a quite complex to write because the rules can easily generate conflicts between them, i.e.,
        over work they are producing.
        To resolve this problem,
        we put each rule to generate a change object which such rule is proposing, i.e.,
        the changes it is working on.
        At the end of the processing of all rules,
        a merging of the generated changes which each rule produced will be created,
        and if two rules wanted to change the same piece a.k.a.
        section of code,
        an exception will be thrown and a Changes\q Handler must be available to resolve this conflict.
        If the Changes\q Handler does not exist at the moment for the existing conflict,
        both changes are discarded and only changes without conflict are reflected, i.e.,
        incorporated into the code.

    \end{enumerate}


    A vantagem nesta abordagem é não ter a necessidade de ter-se conhecimento da sintaxe das linguagens de programação
    que se irão fazer o parsing.
    Isso porque trataremos elas como texto comum,
    e será o usuário final que fará a configuração das transformações que serão aplicados no texto,
    dando liberdade de facilmente se configurar várias linguagens de programação,
    aproveitando o fato de que muitas deles compartilham estruturas semelhantes senão idênticas.

    The advantage of this approach is that we do not need to be aware of the syntax of programming languages that will
    parse.
    This is because we will treat them as common text,
    and it will be the end user that will configure the transformations that will be applied in the text,
    giving freedom to easily configure several programming languages,
    taking advantage of the fact that many of them share similar but not identical structures.

    A literatura/programas atuais são dependentes de linguagem de programação. Minha proposta é
    fazer este processo independente de linguagem, mas de dialetos como este exemplo tirado do PDF
    em anexo a este e-mail `Initial check list tasks to do.pdf':

    \begin{lstlisting}
    // This is the name used to reference this scope around the settings files.
    Scope Name:
    %c++_like_block_comment

    // This set on which languages this block should be included. Setting it
    // to empty will allow it to be parsed for any languages.
    Language Inclusion:
    Java, C++, Pawn

    // Defines a expression which will map the beginning of a exclusion block.
    Scope Start:
    /\*\*

    // Defines a expression which will map the ending of a exclusion block.
    Scope End:
    \\\*
    \end{lstlisting}
    \vspace*{-4mm}

    A abordagem acima é uma abordagem ingênua, portanto somente brevemente ilustrativa. O real motor
    para o software é baseado em expressões regulares e um pilha de contextos. Esta ideia foi
    inicialmente desenvolvida pelo editor de texto `Sublime Text' \cite{Skinner}. Este editor
    utiliza essa estrutura de blocos para fazer a sintaxe highlighting do códigos das linguagens
    através de expressões regulares alocação de contextos/escopos. Essa mesma abordagem pode ser
    utilizada pelo usuário para definir em quais regiões uma Máquina de Turing (linguagens C++/Rust)
    devem fazer/propor as alterações no código.


\subsubsection{Ideas}

    Os pontos positivos dessa abordagem para um formatador de código são a reusabilidade de
    componentes entre as linguagens pelo usuário final da aplicação ao invés do programador, o que
    torna este software muito mais genérico e abre a possibilidades de maior sucesso para a criação
    definitiva de um formatador Universal de códigos das linguagens de programação, quaisquer sejam
    elas. Por exemplo, `if/for/while'\textquotesingle s em linguagens de programação como C++ e Java
    são da mesma estrutura. Assim temos que escrever somente uma vez a especificação para um
    componente da linguagem sem recorrer a programação de do código do programa. Isso tem a vantagem
    de por der ser configurado pelo usuário final ao invés do programador, assim fica mais simples
    de configurar e expandir o conjunto de linguagens disponíveis ao processamento/beautifying.

    Ideas for implementation:

\medskip
\begin{bluebox}
\begin{enumerate}[leftmargin=*]

    \item Implement tabstops with white space align. The solution - move
    tabstops to fit the text between them and align them with matching tabstops
    on adjacent lines. \url{http://nickgravgaard.com/elastic-tabstops/}
    \url{https://forum.sublimetext.com/t/elastic-tabs/128}

\end{enumerate}
\end{bluebox}


\subsubsection{Listings}

    Algumas bibliotecas existentes, e potencialmente utilizadas como `syntect` para o auxílio na
    construção do produto de software:

    \begin{bluebox}
    \begin{enumerate}[leftmargin=*,parsep=0pt]

        \item \url{https://github.com/jbeder/yaml-cpp}
        \item \url{https://github.com/trishume/syntect}
        \item \url{https://github.com/onqtam/doctest}
        \item \url{https://github.com/c42f/tinyformat}
        \item \url{https://github.com/limetext/lime}
        \item \url{https://forum.sublimetext.com/t/disassembling-sublime-text/24824}

    \end{enumerate}
    \end{bluebox}

    Segue-se uma lista básica de formatters/beautifiers acessado no endereço
    \lword{\url{http://www.softpanorama.org/Utilities/beautifiers.shtml}} em março/2017:

    \medskip
    \begin{sloppypar}
    \begin{bluebox}\RaggedRight
    \begin{enumerate}[leftmargin=*,parsep=0pt]

        \item CB210.ZIP - C Beautifier 2.10 - polish C source code (19,406 bytes, 06/22/92)
        \item CL121.ZIP - Codelister 1.21 - print C code with stats (51,110 bytes, 01/10/94)

        \item CPC200.ZIP - CodePrint for C/C++ 2.00 is a full-featured command line driven source
        code reformatter and pretty printer for C++ and C; over 20 customization features including
        auto-indent, adjustable tab spacing, indent styles, flow lines, comment alignment, and line
        editing for consistent white space (140,605 bytes, 01/26/96)

        \item CSCOP120.ZIP - c-scope 1.20 analyzes C source code and produces various reports
        (48,505 bytes, 06/30/95)

        \item HTML : \url{http://www.digital-mines.com/htb/}
        \item HTML : \url{http://www.datacomm.ch/mwoog/software/perl/beautifier.html}
        \item HTML : \url{http://www.watson-net.com/free/perl/s_fhtml.asp}
        \item SQL : \url{http://www.netbula.com/products/sqlb}
        \item Oracle PLSQL : \url{http://www.revealnet.com}
        \item GPL \url{http://www.geocities.com/~starkville/vancbj.html}
        \item GPL \url{http://kevinkelley.mystarband.net/java/dent.html}
        \item Free \url{http://www.tiobe.com/jacobe.htm}
        \item Free \url{http://www.mmsindia.com/JPretty.html}
        \item Free \url{http://members.magnet.at/johann.langhofer/products/jxbeauty/overview.html} (has JBuilder support)
        \item Free \url{http://www.semdesigns.com/Products/Formatters/JavaFormatter.html}
        \item Commercial \$24.99 \url{http://smartbeautify.com}
        \item Commercial \$129 \url{http://www.jindent.com}
        \item Google \url{http://directory.google.com/Top/Computers/Programming/Languages/Java/Development_Tools/Code_Beautifiers/?tc=1}
        \item Java, SQL, HTML, C++ : \url{http://www.semdesigns.com/Products/DMS/DMSToolkit.html}
        \item Java JIndent \url{http://home.wtal.de/software-solutions/jindent}
        \item Java Pat \url{http://javaregex.com/cgi-bin/pat/jbeaut.asp}
        \item Java JStyle \url{http://www.redrival.com/greenrd/java/jstyle}
        \item Java JPrettyPrinter \url{http://www.epoch.com.tw/download/ms/java/java.htm}
        \item Java JxBeauty \url{http://members.nextra.at/johann.langhofer/download/jxbeauty} and the JxBeauty Home
        \item Java beautify percolator
        \item Java list \url{http://www.java.about.com/compute/java/library/weekly/aa102499.htm}
        \item Java html present VasJava2HTML
        \item Java code colorifier and beautifier \url{http://www.mycgiserver.com/~lisali/jccb}
        \item Perl : \url{http://www.consultix-inc.com/www.consultix-inc.com/talk.htm}
        \item Perl : \url{http://www.consultix-inc.com/www.consultix-inc.com/perl_beautifier.html}
        \item Fortran beautifier : \url{http://www.aeem.iastate.edu/Fortran/tools.html}

        \item C++ : BCPP site is at \url{http://dickey.his.com/bcpp/bcpp.html} or at \url{http://www.clark.net/pub/dickey}.
        BCPP ftp site is at \url{ftp://dickey.his.com/bcpp/bcpp.tar.gz}

        \item C++ : \url{http://www.consultix-inc.com/c++b.html}
        \item C : \url{http://www.chips.navy.mil/oasys/c/} and mirror at Oasys
        \item C++, C, Java, Oracle Pro-C Beautifier \url{http://www.geocities.com/~starkville/main.html}

        \item C++, C beautifier \url{http://users.erols.com/astronaut/vim/ccb-1.07.tar.gz} and site at
        \url{http://users.erols.com/astronaut/vim/#vimlinks_src}

        \item GC! GreatCode! is a powerful C/C++ source code beautifier Windows 95/98/NT/2000
        \url{http://perso.club-internet.fr/cbeaudet}

        \item C++ beautifier `SourceStyler' \url{https://web.archive.org/web/20061205061102/http://ochresoftware.com/}
        \item JavaScript : \url{http://jsbeautifier.org/}

    \end{enumerate}
    \end{bluebox}
    \end{sloppypar}


\subsubsection{Related Works}

    Após a busca do que há de publicações científicas sobre o assunto e entra-se alguns trabalhos na
    área específica e similar aos trabalhos feitos pelor formatadores de códigos (Beautifiers).
    Nessa modalidade de trabalho, pode-se confundir-se com artigos que tratam sobre o `Prettyprint`,
    que trata-se de colorir o texto e exibir-lo ao usuário. O que não é o que se busca nesse
    trabalho, mas sim fazer alterações no texto sobre a forma como ele é estruturado, apresentado ao
    usuário e salvo em disco. Seguem as seguintes publicações:

% How to add `parsep` to `itemsep` and set `parsep` to 0pt, when declaring my list?
% https://tex.stackexchange.com/questions/366904/how-to-add-parsep-to-itemsep-and-set-parsep-to-0pt-when-declaring-my-list
\begin{sloppypar}
\begin{bluebox}\RaggedRight
\begin{enumerate}[leftmargin=*,parsep=0pt]

    \item CodeBeautify is an online code beautifier which allows you to beautify
    your source code: \url{http://codebeautify.org/}.

    \item A universal code formatter, written in Dart:
    \url{https://pub.dartlang.org/packages/unifmt}.

    \item Google-java-format is a program that reformats Java source code to
    comply with Google Java Style:
    \url{https://github.com/google/google-java-format}.

    \item CodeFormatter is a Sublime Text 2/3 plugin that supports format
    (beautify) source code.
    \url{https://github.com/akalongman/sublimetext-codeformatter} and
    \url{https://github.com/aukaost/SublimePrettyYAML}

    \item UniversalIndentGUI offers a live preview for setting the parameters of
    nearly any indenter. You change the value of a parameter and directly see
    how your reformatted code will look like. Save your beauty looking code or
    create an anywhere usable batch/shell script to reformat whole directories
    or just one file even out of the editor of your choice that supports
    external tool calls: \url{http://universalindent.sourceforge.net/} and
    \url{https://github.com/danblakemore/universal-indent-gui}.

    \item Language-agnostic pretty-printing through machine learning (uh, like,
    is this possible? YES, apparently). By Terence Parr (primary developer),
    Fangzhou (Morgan) Zhang (help with initial development), Jurgen Vinju
    (co-author of academic paper, help with empirical results and algorithm
    discussions). \url{https://github.com/antlr/codebuff}

    \item To every developer in this world, the closest thing to their heart is
    the text editor of their choice. Over the last few years many new text
    editors has come into the market in both free and paid model, but
    unfortunately not all of them were able to make a real dent on the developer
    community. I remember in my college days we uses to use Notepad++ as our
    beloved text editor, as at that point of time it was one of the popular and
    free text editor with a lot of features for coding. But as time goes on, the
    entire development community started to lean towards sublime text since it’s
    launch.
    \url{https://www.isaumya.com/sublime-text-vs-atom-which-one-i-prefer-most-and-why/}

    \item As a developer, your code editor is one of the most important parts of
    your setup. It can save your wrists and fingers from repetitive strain
    injuries. It can save your eyes from going blind after a coding marathon.
    \url{https://hackernoon.com/virtualstudio-code-the-editor-i-didnt-think-i-needed-16970c8356d5}

    \item VS Code is an Editor while VS is an IDE.
    \url{https://stackoverflow.com/questions/30527522/what-are-the-differences-between-visual-studio-code-and-visual-studio}

    \item What is the difference between VS Code and VS Community?
    Visual Studio Code is a streamlined code editor with support for development operations like
    debugging, task running and version control. It aims to provide just the tools a developer needs
    for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs.
    For more details about the goals of VS Code, see Why VS Code.
    \url{https://code.visualstudio.com/docs/supporting/faq#_licensing}

    \item Reg Replace is a plugin for Sublime Text 2 that allows the creating of commands consisting of
    sequences of find and replace instructions.
    \url{https://forum.sublimetext.com/t/regreplace-plugin/3810}

    \item The main reason I moved was that I find that it’s much slower, the simple things like opening a
    new window for a project should be instantaneous and sadly it’s far from it. As I've said before
    it's all about personal preference, I've gone back to Sublime but Adam for example is sticking
    with it...
    \url{http://engageinteractive.co.uk/blog/atom-review}

    \item \citeonline{aPrettyGoodFormatting}

    \item \url{https://www.researchgate.net/publication/228540036_An_industrial_application_of_context-sensitive_formatting}

    \item \url{http://www.suodenjoki.dk/us/archive/2010/cpp-checkstyle.htm}

    \item \url{http://www.basicinputoutput.com/2014/08/uncrustify-your-bios.html}

    \item \url{http://prettyprinter.de/}

    \item \url{https://github.com/ryanmaxwell/UncrustifyX}

    \item \url{http://www.softpanorama.org/Utilities/beautifiers.shtml}

    \item Understanding the Syntax Parsing
    \url{https://forum.sublimetext.com/t/understanding-the-syntax-parsing/28569}

    "So, part of what I've been working on is a code beautifier that, more or less, aligns and
    indents the code properly based on scanning through the source document."
    ...
    "It hasn't escaped my notice that this is to some degree exactly what the syntax file is doing."

    \item

    {\bfseries Towards a universal code formatter through machine learning:}
    In this paper, we solve the formatter construction problem using a novel approach, one that
    automatically derives formatters for any given language without intervention from a language
    expert. We introduce a code formatter called CODEBUFF that uses machine learning to abstract
    formatting rules from a representative corpus, using a carefully designed feature set. Our
    experiments on Java, SQL, and ANTLR grammars show that CODEBUFF is efficient, has excellent
    accuracy, and is grammar invariant for a given language. It also generalizes to a 4th language
    tested during manuscript preparation.
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{http://dl.acm.org/citation.cfm?id=2997383}
        \item \url{http://homepages.cwi.nl/~jurgenv/papers/SLE16.pdf}
    \end{enumerate}

    \item \url{https://www.google.com/search?q=universal+source+code+formatter}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://www.google.com/search?q=universal+source+code+beautifier}
    \end{enumerate}

    \item \url{http://en.wikipedia.org/wiki/Indent_style}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://en.wikipedia.org/wiki/Programming_style}
        \item \url{https://en.wikipedia.org/wiki/Scope_(computer_science)}
    \end{enumerate}

    \item \url{http://wiki.c2.com/?CodingStyle}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://github.com/google/code-prettify}
        \item \url{https://github.com/uncrustify/uncrustify}
    \end{enumerate}

    \item \url{https://en.wikipedia.org/wiki/Prettyprint}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://www.researchgate.net/search.Search.html?query=formatting%20source%20code&type=publication}
        \item \url{https://www.researchgate.net/search.Search.html?query=pretty%20print%20source%20code&type=publication}
    \end{enumerate}

    \item \url{https://github.com/gchpaco/gopprint}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{http://dl.acm.org.sci-hub.io/citation.cfm?id=357115}
        \item \url{https://www.cs.indiana.edu/~sabry/papers/yield-pp.pdf}
    \end{enumerate}

    \item \url{http://www.worldcat.org/title/beautiful-code-a-customizable-code-beautifier-for-java/oclc/56564674}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://www.researchgate.net/publication/34736049_Beautiful_code_a_customizable_code_beautifier_for_Java}
        \item \url{https://vufind.carli.illinois.edu/vf-ncc/Record/ncc_118189/Holdings}
    \end{enumerate}

    \item \url{https://www.researchgate.net/publication/4283921_Smart_Formatter_Learning_Coding_Style_from_Existing_Source_Code}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{http://www.ing.unisannio.it/mdipenta/index.html}
        \item \url{https://github.com/iain/rspec-smart-formatter}
    \end{enumerate}

    \item \url{https://www.researchgate.net/publication/2543984_Source_Code_Files_as_Structured_Documents}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://en.wikipedia.org/wiki/SrcML}
    \end{enumerate}

    \item \url{https://www.researchgate.net/publication/228540036_An_industrial_application_of_context-sensitive_formatting}
    \begin{enumerate}[nolistsep,topsep=0pt,label=$\star$]
        \item \url{https://www.researchgate.net/publication/234809222_Program_indentation_and_comprehensibility}
    \end{enumerate}

\end{enumerate}
\end{bluebox}
\end{sloppypar}


\subsubsection{Obfuscators}

    Aqui encontra-se o lado oposto dessas ferramentas, Source Code Obfuscators, que servem para
    destruir o visual do código. Usualmente utilizado para dificultar a leitura por outras pessoas
    ou ainda reduzir o tamanho de códigos de linguagens scripting que devem ser carregadas/baixadas
    por navegadores de internet, assim diminuindo o tráfego de internet e salvando/economizando
    largura de banda para download:

    \begin{sloppypar}
    \begin{bluebox}\RaggedRight
    \begin{enumerate}[leftmargin=*,parsep=0pt]

    \item \url{https://en.wikipedia.org/wiki/Obfuscation_(software)}

    \item \url{http://www.semdesigns.com/Products/Obfuscators/index.html}

    \end{enumerate}
    \end{bluebox}
    \end{sloppypar}


\subsubsection{Future Works}

    There is a great number of features and optimizations strategies to be implemented.
    But these improvements can be integrated further after the basic toolset implemented on this work.
    Nowadays,
    the control of spaces in function calls,
    class declarations, comments and etc,
    are more easily to understand and think.
    However,
    there is currently a lack of study on how should be implemented,
    features like text and source code indentation adjustment,
    insertion and removal of redundant parenthesis, and such others.

    However,
    the user scope definitions (of languages) are restricted to Context Free languages (powered by stack machines).
    Therefore,
    if the scope specifications need to be made in terms of Context Sensitive or Recursively Enumerable languages,
    it will be necessary to treat these elements directly in the program coding (Turing Machine),
    instead of by user configuration files.

    Moreover,
    you can not easily think of cases where you need more than Free Context handlers to set which parts of the code you
    would like to work on.
    For reference,
    the Sublime Text Editor uniquely uses this approach to perform source code highlight in most diverse languages,
    and has showed to fulfill it purpose.
    TODO put reference to this.


