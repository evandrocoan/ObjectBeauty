

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{\lang{Theory base}{Fundamentação Teórica}}

Fazer depois que a fundamentação teórica estiver concluída.


\section{Compiladores e Tradutores}

\lang{%
    This work aims to propose a translator \cite{generatingInterpretiveTranslators},
    where the input and output languages are the same language.
    Such translation objective is to change the language representational structure,
    but without affecting the language lex,
    syntactic or semantics, i.e.,
    the language meaning.

    This program class is commonly know as text formatters.
    The differential from this work from others is the goal of a single expandable tool,
    capable of manipulating all existent and future programming languages,
    based on the use of deterministic \cite{introductionToContextFreeGrammars}
    and controlled nondeterministic
    % \cite{TODO:section explaning what does controlled means}
    context free grammars.
}{%
    Em linguagens formais,
    tradutores são ferramentas que operam realizando a transformação de um programa de entrada,
    em um programa de saída \cite{generatingInterpretiveTranslators}.
    Diferente de um compilador,
    a linguagem de destino da ``tradução'' é do \textbf{mesmo nível} que a linguagem de origem.
    Por exemplo,
    dado um programa de entrada em C++ e
    um programa de saída em Java,
    tem~=se um processo de tradução (Figura \ref{fig:pictures/ProcessoTraducao.png}).
    \advisor{A tradução é diferente de um processo de compilação,
    que é dotado de mais etapas \cite{translatorGenerationCompilier}.
    }{Pelo outro lado,
    dado um programa de entrada em C++ e
    um programa de saída em \textit{Assembly},
    tem~=se um processo de compilação \cite{translatorGenerationCompilier}.
    }
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/ProcessoTraducao.png}
    \caption{Processo de Tradução -- Adaptação de \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/ProcessoTraducao.png}
    \end{figure}

    No processo de compilação ou tradução,
    um analisador léxico cria múltiplos \textit{tokens} \cite{ahoCompilerDragonBook}.
    Um token é composto por diversos atributos como a posição e
    o \textit{lexema}, i.e.,
    a sequencia de caracteres que este token representa no programa de entrada.
    Uma vez que o programa é ``\textit{tokenizado}'' pelo analisador léxico,
    o analisador sintático constrói a árvore da sintaxe do programa.
    Utilizando a árvore sintática do programa de entrada,
    o tradutor constrói uma nova árvore sintática correspondente a
    árvore sintática da linguagem do programa destino,
    utilizada para construir o código~=fonte do programa destino.
    Em um processo de compilação,
    não seria criado uma nova árvore como no processo de tradução,
    mas sim a geração de código objeto ou binário.

    Analisadores Sintáticos podem ser Ascendentes ou Descendentes.
    Devido a essa característica ambos possuem as suas vantagens e
    desvantagens.
    Um analisador Ascendente realiza a construção da árvore sintática das folhas até a raíz,
    o contrário de um Analisador Descendente que realiza a construção
    da árvore sintática a partir da raíz até as folhas.
    Uma vantagem de um analisador ascendente é o suporte
    de uma maior classe de Gramáticas Determinísticas.
    Uma vantagem de um Analisador Descendente é a facilidade da recuperação de erros
    em relação aos \textit{parsers} LR(K)\footnote{Conceito abordado na
    \fullref{analisadoresSintaticos}} \cite{sippu1982,lr1ErrorRecovery,larkJosefGrosch}.


\section{Gramáticas}

    Gramáticas são conjuntos de regras que definem uma linguagem.
    Em linguagens formais,
    sendo $\alpha$ um não~=terminal,
    $\beta$ um terminal,
    $V_n$ um conjunto de não~=terminais,
    $V_t$ um conjunto de terminais e
    $V = V_n \cup V_t$,
    uma Gramática é definida por quatro componentes:
    \begin{enumerate}%[nosep,nolistsep]
        \item \advisor{O}{Um} conjunto $V_t$ de símbolos terminais\advisor{ (também chamados
        de tokens ou símbolos do alfabeto da linguagem).
        Cada terminal corresponde a um símbolo presente na linguagem.
        }{,
        chamados algumas vezes de ``\textit{tokens}'' devido a sua forte conexão.
        Cada terminal corresponde a um símbolo presente no alfabeto da linguagem.
        }
        Durante a análise léxica,
        os símbolos terminais serão utilizados definir os lexemas que são a base principal dos tokens.
        Na composição da árvore sintática,
        os ``\textit{tokens}'' ou terminais,
        serão sempre as folhas da árvore.

        \item \advisor{O}{Um} conjunto $V_n$ de símbolos
        não~=terminais\advisor{ (algumas vezes chamados de ``variáveis sintáticas'').}{,
        algumas vezes chamados de ``variáveis sintáticas''.
        }
        Não~=terminais servem para agrupar vários não~=terminais e/ou terminais.
        Na composição da árvore sintática,
        os símbolos não~=terminais sempre serão os nós da árvore\footnote{Desde
        que a Gramática da linguagem não contenha símbolos inúteis,
        i.e.,
        todos os símbolos da Gramática são férteis e
        permitem a geração de palavras além do conjunto vazio $\varnothing$}.
        Por convenção,
        a intersecção entre o conjunto de símbolos terminais e
        não~=terminais é sempre vazia,
        i.e.,
        $V_n \cap V_t = \varnothing$,
        uma vez que não respeitando essa convenção,
        não se tem como deterministicamente analisar o programa de entrada,
        podendo~=se indefinidamente realizar a substituição da mesma regra de produção.

        \item \label{definicaoDeGramatica}Um conjunto de produções $P$.
        Uma produção consiste em uma dupla elementos.
        O primeiro elemento é a cabeça ou lado esquerdo e
        representa a substituição ou consumo que será feito no programa de entrada.
        Ele é obrigatoriamente constituído de no mínimo um não~=terminal e
        um ou mais não~=terminais ou terminais.
        O segundo elemento é a cauda ou lado direito da produção,
        composto de terminais e/ou não~=terminais.
        Formalmente defini~=se um produção pela seguinte regra,
        onde ``*'' representa o operador de fechamento do conjunto \cite{hopcroftBook}:
        $$P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^* \;\}$$

        \item Um símbolo inicial selecionado a partir do conjunto de símbolos não~=terminais.
        O símbolo inicial é utilizado para definir qual será a raíz da árvore sintática,
        i.e.,
        o primeira regra de produção utilizado para iniciar o reconhecimento do programa de entrada.
    \end{enumerate}

    A partir da adição restrições sobre a definição formal de Gramática recém apresentada,
    também pode~=se \advisor{compreender}{realizar diversas
    classificações como} a hierarquia de
    \citeonline{chomskyGrammars1956},
    onde uma linguagem pode ser classificada como Regular,
    Livre de Contexto,
    Sensível ao Contexto e
    Tipo 0 (Figura \ref{fig:pictures/HierarquiaDeChomsky.png}).
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/HierarquiaDeChomsky.png}
    \caption{Hierarquia de Chomsky -- Adaptação de \citeonline{sipserBook}}
    \label{fig:pictures/HierarquiaDeChomsky.png}
    \end{figure}

    Toda Gramática Regular ou Livre de Contexto,
    é também uma Gramática Tipo 0 ou Sensível ao Contexto,
    uma vez que Gramáticas Livres de Contexto ou Regulares são um
    subconjunto das Gramáticas Tipo 0 ou Sensíveis ao Contexto como
    apresentado na Figura \ref{fig:pictures/HierarquiaDeChomsky.png}.
    Por isso,
    também pode~=se chamar uma dada Gramática Regular de Tipo 0 ou Livre de Contexto.
    Quando diz~=se que existe Gramática Livre de Contexto para um dada Linguagem,
    pode~=se ter o equívoco de pensar que este é o melhor tipo,
    i.e.,
    o tipo mais eficiente em tempo computational de Gramática
    no qual dada Linguagem pode ser representada.
    Entretanto,
    precisa~=se tomar cuidado quando fala~=se sobre Gramáticas e
    Linguagens.
    Para uma dada Linguagem,
    dizer que existe uma Gramática Livre de Contexto para ela
    não significa que esta Linguagem é Livre de Contexto.
    Sempre pode~=se escrever uma Gramática menos eficiente do que o
    tipo mínimo de Gramática que uma Linguagem pode ser escrita.
    Utilizando o Lema do Bombeamento\footnote{Do inglês \textit{Pumping Lemma}} \cite{hopcroftBook}
    pode-se determinar se dada Gramática é o tipo mínimo de Gramática para dada Linguagem.
    Assim,
    não pode~=se dizer uma dada Linguagem é Livre de Contexto simplesmente
    por que existe uma Gramática Livre de Contexto para dada Linguagem,
    pois também é preciso que esta Gramática seja o tipo
    mínimo no qual esta Linguagem pode ser escrita.


\subsection*{Gramáticas Regulares}

    Gramáticas Regulares (também conhecidas como Tipo 3) são todas aquelas reconhecidas
    por Automatos Finitos Determinísticos e/ou Não~=Determinísticos e
    Gramaticas de Linguagens Regulares pela definição formal,
    são todas aquelas nos quais todas as produções da Gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= a \beta \;|\; \alpha \in V_n \land a \in V_t
                \land \beta \in \{\; V_n \cup \varepsilon\; \} \;\} $$

\subsection*{Gramáticas Livres de Contexto}

    Gramáticas Livres de Contexto (também conhecidas como Tipo 2) são todas
    aquelas reconhecidas por Automatos de Pilha Não~=Determinísticos e
    Gramaticas de Linguagens Livre de Contexto pela definição formal,
    são todas aquelas nos quais todas as produções da Gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V_n \land \beta \in V^* \;\} $$


\subsection*{Gramáticas Sensíveis ao Contexto}

    Gramáticas Sensíveis ao Contexto (também conhecidas como Tipo 1) são
    todas aquelas reconhecidas por Automatos Linearmente Limitados,
    que se tratam somente de Máquinas de Turing com Fita (ou memória) Finita.
    Gramaticas de Linguagens Sensíveis ao Contexto pela definição formal,
    são todas aquelas nos quais todas as produções da Gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^*
                \land \vert\alpha\vert \leq \vert\beta\vert \;\} $$


\subsection*{Gramáticas Tipo 0}

    Por fim,
    as Linguagens do Tipo 0 possuem a mesma definição do que a definição
    válida de uma Gramática como apresentado anteriormente (no
    \fullref{definicaoDeGramatica}):
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^* \;\} $$

    Gramáticas do Tipo 0 são reconhecidas somente por Máquinas de Turing\footnote{Máquinas
    de Turing possuem por definição fita (ou memória) infinita
    },
    e diferente das Gramáticas Sensíveis ao Contexto,
    a Máquina de Turing não possui parada garantida,
    i.e.,
    Linguagens do Tipo 0 representam problemas incomputáveis e
    que podem ser representados de procedimentos \cite{sipserBook}.
    Já Linguagens do Tipo 1 ou Sensíveis ao Contexto,
    representam todos os problemas computáveis e
    sua implementação pode ser representada por algoritmos,
    pois possuem parada garantida,
    apesar de terem em pior caso,
    tempo exponential.


\section{Analisadores Sintáticos}
\label{analisadoresSintaticos}

    A maior classe de Gramáticas Determinísticas suportadas por analisadores
    sintáticos são as Gramáticas LR(K)\footnote{\textit{Left~=to~=right,
    Rightmost derivation in reverse by ``K'' lookahead symbols
    }}.
    Analisadores LR(K) \cite{ahoCompilerDragonBook} são Ascendentes e
    reconhecem um subconjunto das Linguagens Livre de Contexto
    (Figura \ref{fig:pictures/LinguagensDeterministicas.png}).
    Já os Analisadores LL(K) são Descendente e
    reconhecem somente um subconjunto das Linguagens LR(K)\footnote{Diz~=se que
    uma linguagem é LR(K) ou LL(K) quando ela é reconhecida por um dos mesmos}.
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/LinguagensDeterministicas.png}
    \caption{Mapa Mental das Linguagens e
    Gramáticas \newline Adaptação de \citeonline{beatty1982} e
    \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/LinguagensDeterministicas.png}
    \end{figure}

    A Figura \ref{fig:pictures/LinguagensDeterministicas.png} não é
    um Diagrama de Venn \cite{generalizedVennDiagrams},
    somente uma relação abstrata entre Linguagens Ambíguas e
    Gramáticas Determinísticas.
    O primeiro nível significa que todas as Linguagens Inerentemente
    Ambíguas são representáveis somente por Gramáticas Ambíguas.
    O segundo nível significa que Linguagens Não~=Inerentemente Ambíguas podem
    ser representadas por Gramáticas Ambíguas e/ou Determinísticas.
    No terceiro nível encontra~=se as Gramáticas que são mais importantes,
    as Gramáticas Determinísticas,
    que podem ser classificadas como LR(K),
    LL(K), \advisor{}{entre outros, }i.e.,
    de acordo com o tipo de \textit{parser} que poder ser construído para reconhecer elas.

    É importante fazer a distinção entre Gramáticas Livre de Contexto e
    as Linguagens Livre de Contexto.
    \citeonline{parikh1966} provou que existem linguagens nas quais não
    existem Gramáticas Não~=Ambíguas que representem estas linguagens.
    Tais linguagens são conhecidas como Linguagens Inerentemente Ambíguas\footnote{Do
    inglês \textit{Inherently ambiguous languages}} onde não existem Gramáticas
    Livre de Contexto Determinísticas capazes de representa~=las e
    tais Linguagens somente podem ser reconhecidas por Automatos de Pilha Não~=Determinísticos.

    Uma vez que \textit{parsers} LR(K) requerem grandes quantidades de memória para operar,
    \citeonline{lalrDeRemer1982} criaram os \textit{parsers}
    LALR(K)\footnote{\textit{Look~=Ahead} LA(K) LR(0),
    onde LR(0) é um \textit{parser} LR(K) com $K=0$
    } e
    SLR(K)\footnote{\textit{Simple} LR(K) \textit{parser}} com o objeto de
    viabilizar a implementação de \textit{parsers} Ascendentes Determinísticos.
    Gramáticas de Linguagens Determinísticas são chamadas de LR por que todas
    as Linguagens Determinísticas são reconhecidas por Analisadores LR(K).
    \citeonline{knuthLrParser1965} provou que todas as Gramáticas
    Determinísticas são aceitas por um \textit{parser} LR(K).
    Assim,
    além da hierarquia de Chomsky,
    também classifica~=se as Gramáticas de acordo com o tipo de
    \textit{parser} que reconhece as linguagens representadas por elas.
    Como mostrado na Figura \ref{fig:pictures/LinguagensDeterministicas.png},
    nem todas as Gramáticas Livre de Contexto são de Determinísticas e
    uma Gramática é Determinística somente se ela pode ser reconhecida por um \textit{parser} LR(K).
    Portanto uma maneira fácil de decidir se uma dada Gramática é Determinística ou não,
    é tentar construir a tabela de \textit{parser} dela para um \textit{parser} LR(K).
    Caso consiga~=se construir com sucesso a Tabela de Parsing \cite{ahoCompilerDragonBook},
    a Gramática é LR(K),
    caso contrário a Gramática não é Determinística.
    A mesma técnica pode ser aplicada no caso de \textit{parsers} menos poderosos como LALR(K),
    entretanto,
    uma vez que não se consiga construir a Tabela de Parsing,
    não se pode ter certeza se dada Gramática não é Determinística.

    Usualmente,
    somente depois que a Árvore Sintática é construída,
    realiza~=se o processo de Análise Semântica,
    i.e.,
    a verificação da corretude do programa escrito em relação os aspectos não~=estruturais,
    por exemplo,
    é sintaticamente correta escrever a declaração de uma mesma variável duas vezes ou mais,
    entretanto,
    é semanticamente errado redeclarar uma variável duas vezes ou mais.
    O analisador sintático representado por uma Gramática Livre de Contexto não tem poder
    suficiente para realizar tais verificações devido as limitações desse tipo de Gramática.
    Quando devidamente construídas,
    linguagens Sensíveis ao Contexto podem ser Turing Completa\footnote{A Turing Completude
    acontece quando uma dada linguagem pode simular o funcionamento completo de uma Máquina
    de Turing} \cite{areThereDomainSpecificLanguages,contextSensitiveParsing} e
    são capazes de realizar qualquer operação computacional algorítmica.
    Uma vez que o programa foi verificado sintaticamente,
    inicia~=se o processo de análise semântica.

    Nem todas as linguagens podem ser analisadas completamente em diferentes etapas,
    como análise léxica, sintática e semântica. Muitas vezes,
    estas três etapas acontecem em paralelo como realizado na implementação do
    compilador da Linguagem C \cite{jourdan2017,whyCcannotBeParsedWithALR1Parser}.
    A Gramática da linguagem C não é Livre de Contexto devido as
    ambiguidades existentes como a expressão ``\textit{x * y ;}''.
    Tal sentença pode ser ou a declaração de um ponteiro chamado \textit{y} do tipo \textit{x},
    ou a multiplicação de dois números armazenados nas variáveis \textit{x} e
    \textit{y},
    portanto ela não pode ser aceita por um \textit{parser} LR(K) tradicional.

    Uma otimização que o compilador C faz para poder fazer o \textit{parser} Determinístico da linguagem C,
    e assim saber se a expressão ``\textit{x * y ;}'' trata~=se de
    de uma mera multiplicação ou a declaração de uma variável,
    é exatamente a realização simultânea da análise léxica,
    sintática e
    semântica.
    Uma vez que um novo \textit{token} é reconhecido,
    ele é alimentado para o analisador sintático,
    que também o alimenta para o Analisador Semântico.
    Assim,
    o Analisador Sintático é capaz de consultar a Tabela de Símbolos e
    descobrir se dado token ou tratar~=se de um tipo ou uma variável numérica.
    Portanto,
    pode dizer que as Gramáticas de todas as Linguagens de Programação são Livres de Contexto e
    Determinísticas,
    pois uma vez que a Gramática não é mais Livre de Contexto ou Determinística,
    pode~=se mover aspectos sensíveis ao contexto para o Analisador Semântico,
    assim,
    deixando a Gramática somente com aspectos determinísticos.


\section{Classes de Complexidade}

    As Gramáticas Regulares e
    Livres de Contexto Não~=Determinísticas possuem Complexidade Exponential.
    Como um todo,
    o conjunto de Linguagens Regulares podem ser considerados com Complexidade
    Linear por que toda Gramática Regular Não~=Determinística pode ser
    convertida em uma Gramática Regular Determinística \cite{sipserBook}.
    Infelizmente isso não é verdade para Gramáticas Livres de Contexto
    por que Gramáticas Livre de Contexto Determinísticas e
    Não~=Determinísticas não são equivalentes.
    Gramáticas Não~=Determinísticas possuem Complexidade Exponential por que
    somente pode~=se simular o funcionamento de um \textit{Parser}
    Não~=Determinístico utilizando uma máquina determinística,
    tal como os computadores atuais,
    que somente podem realizar a execução de um ramo de computação Não~=Determinístico,
    exceto para Computadores Quânticos \cite{nonlinearQuantumComputers}.

    Na Figura \ref{fig:pictures/ParserNonDeterministic.png} encontra~=se uma
    Árvore de Computação de um \textit{Parser} Não~=Determinístico.
    Diz~=se que que o tempo de execução de um \textit{Parser} Não~=Determinístico é Linear ou
    Polinomial ao tamanho da entrada por que um \textit{Parser} Não~=Determinístico
    executa simultaneamente todos os Ramos de Computação Não~=Determinísticos.
    Como mostrado na Figura \ref{fig:pictures/ParserNonDeterministic.png},
    após a cada um dos passo de computação 1,
    2, 3 e 4,
    todos os 15 ramos de computação foram concluídos.
    Cada um desses passos é corresponde a um item a ser analisado na entrada do programa.
    O que torna a computação Não~=Determinística é o fato de cada um dos itens 1,
    2, 3 e 4 da entrada,
    permitirem simultaneamente a escolha de mais de um caminho
    na escolha do próximo estado do \textit{Parser},
    i.e.,
    mais de um Ramo de Computação.
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/ParserNonDeterministic.png}
    \caption{Árvore de Computação com 4 Passos -- Fonte Própria}
    \label{fig:pictures/ParserNonDeterministic.png}
    \end{figure}

    O tempo de execução será Linear ao tamanho da entrada caso o
    \textit{Parser} Não~=Determinístico seja de uma Linguagem Regular e,
    Polinomial caso o \textit{Parser} Não~=Determinístico seja de uma linguagem Livre de Contexto.
    Uma fez que o conjunto de Linguagens Determinísticas LR(K) (com tempo
    Polinomial) está contida no conjunto das Linguagens Livres de Contexto,
    não faz sentido em falar em tempos Lineares ou Polinomiais
    de execução para Linguagens Sensíveis ao Contexto,
    por que os algoritmos de \textit{parsing} são exponenciais e
    quando analisados por uma Máquinas de Turing Não~=Determinísticas
    terão no máximo tempo Polinomial de execução.
    Como um \textit{addendum} para Computação Quântica,
    pode~=se encontrar pessoas dizendo que Computadores Quânticos
    são equivalentes a \textit{Parsers} Não-Determinísticos.
    Entretanto,
    Computadores Quânticos não são equivalentes a \textit{Parsers}
    Não~=Determinísticos devido a sua execução ser probabilística
    \cite{polynomialQuantumComputers},
    que é diferente de Não~=Determinística.

    Diferente dos Computadores Tradicionais,
    Computadores Quânticos são construídos com base nas leis da Física Quântica,
    que são completamente diferentes das Leis da Física
    Tradicional (ou Clássica)
    \cite{churchTuringQuantumComputer}.
    Assim,
    Computadores Quânticos podem em alguns casos e
    para problemas específicos,
    realizar a execução de todos os Ramos Não~=determinísticos
    de Computação em tempo Linear ou Polinomial.
    Esta é a gama de problemas nos quais Computadores Quânticos são úteis,
    não sendo assim,
    substitutos completos da Computação Tradicional (ou Clássica),
    somente otimizadores na resolução de alguns problemas específicos.
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/ParserDeterministic.png}
    \caption{Árvore de Computação com 15 Passos -- Fonte Própria}
    \label{fig:pictures/ParserDeterministic.png}
    \end{figure}

    Na Figura \ref{fig:pictures/ParserDeterministic.png} encontra-se
}

