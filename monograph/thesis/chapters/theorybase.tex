

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{\lang{Theory base}{Fundamentação Teórica}}

Fazer depois que a fundamentação teórica estiver concluída.


\section{\lang{What does coding is}{Programação de computadores}}

\lang{
    Coding is like writing and reading a book for the large people, you like it
    to look beautifully. Or at least do you expect such when you buy a book, for
    example, to learn programming for you first time \cite{howNovicesRead}.
    You expect:
    \begin{enumerate}
        \item
            Things to be well organized,
            so you do not get lost.
        \item
            The colors to be properly placed,
            so you do not get distracted from the main content.
        \item
            The spacing between paragraphs, words, chapters, sections
            subsections, etc, to be well adjusted.
            Not everything cluttered in only one file,
            line, function, class, or whatsoever so.
    \end{enumerate}
}{%
    Programar pode ser considerado pela maioria das pessoas como escrever um livro,
    e para tal,
    \advisor{busca-se mais a ideia de facilidade de leitura.
    Existem livros muito horríveis de se ler:
    fontes inadequadas ou pequenas,
    com folhas que brilham contra a luz.
    }{gostar~=se mais caso este ``livro'' tenha uma boa aparência.
    }No mínimo espera~=se algumas características chave ao comprar~=se
    um livro \cite{visualizationsInAFunctionalProgramming}.
    Por exemplo,
    quando compra~=se um livro,
    \advisor{}{para aprender a programar pela primeira vez,
    }espera-se que \cite{howNovicesRead}:
    \begin{enumerate}
        \item
            Seu conteúdo esteja bem organizado,
            para que o leitor não se perca durante sua leitura.
        \item
            Que suas cores \advisor{sejam}{estejam} propriamente escolhidas e
            utilizadas,
            para que elas não distraiam o leitor ou tirem o foco do principal,
            o conteúdo do livro.
        \item
            Que o espaçamento entre os parágrafos,
            palavras, capítulos, seções, subseções, etc, estejam propriamente ajustados,
            e não\advisor{}{ todo} aglomerado ou desordenado em um único parágrafo,
            frase, capítulo\advisor{.}{, etc.}
    \end{enumerate}
}

\advisor{}{%
    \subsection{\lang{Computer Assisted Programming}{Programação auxiliada}}

    \lang{%
        Your computer should help you with these unforeseen tasks.
        Why should I spend my precious time checking whether I am actually copying
        something space indented,
        when I am actually coping something tab indented?
        Perhaps we should sit and cry while waiting for some greater force to come
        and rescue us. Or may be you should stop crying and actually do something
        about other than keep waiting for you mommy to come and save you from the
        darkness growing behind you back leading you to endless unsleepy nights
        fixing your code just because everything just went wrong.
    }{%
        Seu computador deveria ajudar você com aquelas imprevistas tarefas.
        Por que eu deveria gastar meu precioso tempo verificando se algo que estou copiando,
        está indentado por ``TAB''\s ou espaços?
        Talvez devêssemos sentar e
        chorar enquanto aguardamos que alguma força maior do Universo venha e
        nos salve.
        Ou talvez você deva para de chorar e
        realmente fazer alguma coisa a respeito além de continuar esperando que sua mamãe venha e
        resgate você da escuridão crescendo pela suas costas levando você a infinitas noites
        acordado corrigindo seu código simplesmente por que tudo deu errado.
    }
}

% \section{Gramáticas}

% O que são Gramáticas?


% \subsection{Expressões Regulares}

% O que são Gramáticas?


% \subsection{Gramáticas Livre de Contexto}


% \subsection{Sintaxes de linguagens}

% O que são sintaxes de linguagens?


\subsection{Tradução de Código}

\lang{%
    This work aims to propose a translator \cite{generatingInterpretiveTranslators},
    where the input and output languages are the same language.
    Such translation objective is to change the language representational structure,
    but without affecting the language lex,
    syntactic or semantics, i.e.,
    the language meaning.

    This program class is commonly know as text formatters.
    The differential from this work from others is the goal of a single expandable tool,
    capable of manipulating all existent and future programming languages,
    based on the use of deterministic \cite{introductionToContextFreeGrammars}
    and controlled nondeterministic
    % \cite{TODO:section explaning what does controlled means}
    context free grammars.
}{%
    Em linguagens formais,
    tradutores são ferramentas que operam realizando a transformação de um programa de entrada,
    em um programa de saída \cite{generatingInterpretiveTranslators}.
    Diferente de um compilador,
    a linguagem de destino da ``tradução'' é do \textbf{mesmo nível} que a linguagem de origem.
    Por exemplo,
    dado um programa de entrada em C++ e
    um programa de saída em Java,
    tem-se um processo de tradução.
    \advisor{A tradução é diferente de um processo de compilação,
    que é dotado de mais etapas \cite{translatorGenerationCompilier}.
    }{Pelo outro lado,
    dado um programa de entrada em C++ e
    um programa de saída em Assembly,
    tem-se um processo de compilação \cite{translatorGenerationCompilier}.
    }
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/ProcessoTraducao.png}
    \caption{Processo de Tradução -- Adaptação de \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/ProcessoTraducao.png}
    \end{figure}

    No processo de compilação ou tradução,
    um analisador léxico cria múltiplos \textit{tokens} \cite{ahoCompilerDragonBook}.
    Um token é composto por diversos atributos como a posição e
    o \textit{lexema}, i.e.,
    a sequencia de caracteres que este token representa no programa de entrada.
    Uma vez que o programa é ``\textit{tokenizado}'' pelo analisador léxico,
    o analisador sintático constrói a árvore da sintaxe do programa.
    Utilizando a árvore sintática do programa de entrada,
    o tradutor constrói uma nova árvore sintática correspondente a
    árvore sintática da linguagem do programa destino,
    utilizada para construir o código~=fonte do programa destino.
    Em um processo de compilação,
    não seria criado uma nova árvore como no processo de tradução,
    mas sim a geração de código objeto ou binário.

    Analisadores Sintáticos podem ser Ascendentes ou Descendentes.
    Devido a essa característica ambos possuem as suas vantagens e
    desvantagens.
    Um analisador Ascendente realiza a construção da árvore sintática das folhas até a raíz,
    o contrário de um analisador Descendente que realiza a construção
    da árvore sintática a partir da raíz até as folhas.
    Uma vantagem de um analisador ascendente é o suporte
    de uma maior classe de gramáticas determinísticas.
    Uma vantagem de um analisador descendente é a facilidade
    da recuperação de erros \cite{ahoCompilerDragonBook}.

    Gramáticas são conjuntos de regras de definem uma linguagem.
    Em linguagens formais,
    sendo $\alpha$ um não~=terminal,
    $\beta$ um terminal,
    $Vn$ um conjunto de não~=terminais,
    $Vt$ um conjunto de terminais e
    $V = Vn \cup Vt$,
    uma gramática é definida por quatro componentes:
    \begin{enumerate}%[nosep,nolistsep]
        \item Um conjunto de símbolos terminais $Vt$,
        chamados algumas vezes de ``\textit{tokens}'' devido a sua forte conexão.
        Durante a análise léxica,
        os símbolos terminais serão utilizados definir os lexemas que são a base principal dos tokens.
        Na composição da árvore sintática,
        os ``\textit{tokens}'' ou terminais,
        serão sempre as folhas da árvore.

        \item Um conjunto de símbolos não-terminais $Vn$,
        algumas vezes chamados de ``variáveis sintáticas''.
        Não-terminais servem para agrupar vários não-terminais e/ou terminais.
        Na composição da árvore sintática,
        os símbolos não-terminais sempre serão os nós da árvore.
        Por convenção,
        a intersecção entre o conjunto de símbolos terminais e
        não terminais é sempre vazia, i.e., $Vn \cap Vt = \varnothing$,
        uma vez que não respeitando essa convenção,
        não se tem como deterministicamente analisar o programa de entrada,
        podendo-se infinitamente realizar a substituição da mesma regra de produção infinitamente.

        \item Um conjunto de produções.
        Uma produção consiste em uma dupla de dois elementos.
        O primeiro elemento é a cabeça ou lado esquerdo e
        representa a substituição ou consumo que será feito no programa de entrada.
        Ele é obrigatoriamente constituído de no mínimo um não~=terminal e
        um ou mais não-terminais ou terminais.
        O segundo elemento é a cauda ou lado direito da produção,
        composto de terminais e/ou não-terminais.
        Formalmente defini-se um produção pela seguinte regra,
        onde ``*'' representa o operador de fechamento do conjunto \cite{hopcroftBook}:
        $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^* \;\} $$

        \item Um símbolo inicial selecionado a partir do conjunto de símbolos não~=terminais.
        O símbolo inicial é utilizado para definir qual será a raíz da árvore sintática,
        i.e.,
        o primeira regra de produção utilizado para iniciar o reconhecimento do programa de entrada.
    \end{enumerate}

    A partir da definição formal de gramática,
    é possível realizar diversas classificações como as classificações Chomsky \cite{sipserBook},
    de acordo com a forma de produção da gramática,
    ela pode ser classificada como Regular,
    Livre de Contexto,
    Sensível ao Contexto e
    Tipo 0:
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/HierarquiaDeChomsky.png}
    \caption{Hierarquia de Chomsky -- Adaptação de \citeonline{sipserBook}}
    \label{fig:pictures/HierarquiaDeChomsky.png}
    \end{figure}

    A maior classe de gramáticas determinísticas suportadas por
    analisadores sintáticos são as gramáticas LR(K)
    [\textit{Left-to-right,
    Rightmost derivation in reverse by ``K'' lookahead symbols},
    \citeonline{ahoCompilerDragonBook}].
    Analisadores LR(K) são Ascendentes e
    são um subconjunto das linguagens Livre de Contexto.
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/LinguagensDeterministicas.png}
    \caption{Linguagens Determinísticas -- Adaptação de \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/LinguagensDeterministicas.png}
    \end{figure}

}

\subsection{Formatadores de código}

\lang{%
    A robust Code Beautifier can get a lot more complicated just with the basic
    definitions of formatting (\nameref{source_code_beautifiers})
    applied over each language own characteristics
    as for example:
}{%
    Conhecido como ``pretty~=printing'' ou embelezadores\footnote{do inglês:
    \textit{Beautifiers}} \cite{prettyPrintingForSoftware},
    uma ferramenta de formatação pode ser complicada de
    utilizar somente com um conjunto básico de definições.
    Por exemplo,
}%
\lang{%
    \begin{enumerate}[nosep,nolistsep]
        \item
            Add spaces before if\s name as in `if(var)' versus `if (var)'
        \item
            Add spaces inside if\s as in `if(var)' versus `if( var )'
        \item
            Add spaces before for\s name as in `for(var)' versus `for (var)'
        \item
            Add spaces inside for\s as in `for(var)' versus `for( var )'
    \end{enumerate}
}{%
    para permitir um melhor controle do usuário,
    a ferramenta de formatação pode permitir que exista uma
    configuração específica para cada aspecto da linguagem.
    Uma possível implementação para tal ajuste fino,
    pode ser uma configuração específica para cada aspecto da linguagem como uma
    entrada booleana ``\textit{use\_spaces\_after\_if}'' em um arquivo de
    configuração para definir caso deva-se ou não ser adicionados espaços antes
    de cada ``if'' ao fazer a formatação da linguagem,
    ``if (var)'' contra ``if(var)''.
}

    As may be noticed, the list may became quite big,
    and if fact such big list of rules has been implemented.
    Looking over the Beautifier called
    `Uncrustify'\footnote{\url{https://github.com/uncrustify/uncrustify}},
    we can find about 500 settings with specifications like these above.

    The problem about is, even if you go through all these settings,
    which will take you quite some time,
    you still only configuring a few languages closely related.
    On this case, C, C++, Java, Pawn, etc.
    For all other languages you still need to find out another source code
    formatter tool, which will be certainly
    limited\footnote{\url{https://stackoverflow.com/questions/31438377/how-can-i-get-eclipse-to-wrap-lines-after-a-period-instead-of-before}}
    and still need to configure all over again.

