

% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{\lang{Theory base}{Fundamentação Teórica}}

Fazer depois que a fundamentação teórica estiver concluída.


\section{\lang{What does coding is}{Programação de computadores}}

\lang{
    Coding is like writing and reading a book for the large people, you like it
    to look beautifully. Or at least do you expect such when you buy a book, for
    example, to learn programming for you first time \cite{howNovicesRead}.
    You expect:
    \begin{enumerate}
        \item
            Things to be well organized,
            so you do not get lost.
        \item
            The colors to be properly placed,
            so you do not get distracted from the main content.
        \item
            The spacing between paragraphs, words, chapters, sections
            subsections, etc, to be well adjusted.
            Not everything cluttered in only one file,
            line, function, class, or whatsoever so.
    \end{enumerate}
}{%
    Programar pode ser considerado pela maioria das pessoas como escrever um livro,
    e para tal,
    \advisor{busca~=se mais a ideia de facilidade de leitura.
    Existem livros muito horríveis de se ler:
    fontes inadequadas ou pequenas,
    com folhas que brilham contra a luz.
    }{gostar~=se mais caso este ``livro'' tenha uma boa aparência.
    }No mínimo espera~=se algumas características chave ao comprar~=se
    um livro \cite{visualizationsInAFunctionalProgramming}.
    Por exemplo,
    quando compra~=se um livro,
    \advisor{}{para aprender a programar pela primeira vez,
    }espera~=se que \cite{howNovicesRead}:
    \begin{enumerate}
        \item
            Seu conteúdo esteja bem organizado,
            para que o leitor não se perca durante sua leitura.
        \item
            Que suas cores \advisor{sejam}{estejam} propriamente escolhidas e
            utilizadas,
            para que elas não distraiam o leitor ou tirem o foco do principal,
            o conteúdo do livro.
        \item
            Que o espaçamento entre os parágrafos,
            palavras, capítulos, seções, subseções, etc, estejam propriamente ajustados,
            e não\advisor{}{ todo} aglomerado ou desordenado em um único parágrafo,
            frase, capítulo\advisor{.}{, etc.}
    \end{enumerate}
}

\advisor{}{%
    \subsection{\lang{Computer Assisted Programming}{Programação auxiliada}}

    \lang{%
        Your computer should help you with these unforeseen tasks.
        Why should I spend my precious time checking whether I am actually copying
        something space indented,
        when I am actually coping something tab indented?
        Perhaps we should sit and cry while waiting for some greater force to come
        and rescue us. Or may be you should stop crying and actually do something
        about other than keep waiting for you mommy to come and save you from the
        darkness growing behind you back leading you to endless unsleepy nights
        fixing your code just because everything just went wrong.
    }{%
        Seu computador deveria ajudar você com aquelas imprevistas tarefas.
        Por que eu deveria gastar meu precioso tempo verificando se algo que estou copiando,
        está indentado por ``TAB''\s ou espaços?
        Talvez devêssemos sentar e
        chorar enquanto aguardamos que alguma força maior do Universo venha e
        nos salve.
        Ou talvez você deva para de chorar e
        realmente fazer alguma coisa a respeito além de continuar esperando que sua mamãe venha e
        resgate você da escuridão crescendo pela suas costas levando você a infinitas noites
        acordado corrigindo seu código simplesmente por que tudo deu errado.
    }
}

% \section{Gramáticas}

% O que são Gramáticas?


% \subsection{Expressões Regulares}

% O que são Gramáticas?


% \subsection{Gramáticas Livre de Contexto}


% \subsection{Sintaxes de linguagens}

% O que são sintaxes de linguagens?


\subsection{Tradução de Código}

\lang{%
    This work aims to propose a translator \cite{generatingInterpretiveTranslators},
    where the input and output languages are the same language.
    Such translation objective is to change the language representational structure,
    but without affecting the language lex,
    syntactic or semantics, i.e.,
    the language meaning.

    This program class is commonly know as text formatters.
    The differential from this work from others is the goal of a single expandable tool,
    capable of manipulating all existent and future programming languages,
    based on the use of deterministic \cite{introductionToContextFreeGrammars}
    and controlled nondeterministic
    % \cite{TODO:section explaning what does controlled means}
    context free grammars.
}{%
    Em linguagens formais,
    tradutores são ferramentas que operam realizando a transformação de um programa de entrada,
    em um programa de saída \cite{generatingInterpretiveTranslators}.
    Diferente de um compilador,
    a linguagem de destino da ``tradução'' é do \textbf{mesmo nível} que a linguagem de origem.
    Por exemplo,
    dado um programa de entrada em C++ e
    um programa de saída em Java,
    tem~=se um processo de tradução (figura \ref{fig:pictures/ProcessoTraducao.png}).
    \advisor{A tradução é diferente de um processo de compilação,
    que é dotado de mais etapas \cite{translatorGenerationCompilier}.
    }{Pelo outro lado,
    dado um programa de entrada em C++ e
    um programa de saída em \textit{Assembly},
    tem~=se um processo de compilação \cite{translatorGenerationCompilier}.
    }
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/ProcessoTraducao.png}
    \caption{Processo de Tradução -- Adaptação de \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/ProcessoTraducao.png}
    \end{figure}

    No processo de compilação ou tradução,
    um analisador léxico cria múltiplos \textit{tokens} \cite{ahoCompilerDragonBook}.
    Um token é composto por diversos atributos como a posição e
    o \textit{lexema}, i.e.,
    a sequencia de caracteres que este token representa no programa de entrada.
    Uma vez que o programa é ``\textit{tokenizado}'' pelo analisador léxico,
    o analisador sintático constrói a árvore da sintaxe do programa.
    Utilizando a árvore sintática do programa de entrada,
    o tradutor constrói uma nova árvore sintática correspondente a
    árvore sintática da linguagem do programa destino,
    utilizada para construir o código~=fonte do programa destino.
    Em um processo de compilação,
    não seria criado uma nova árvore como no processo de tradução,
    mas sim a geração de código objeto ou binário.

    Analisadores Sintáticos podem ser Ascendentes ou Descendentes.
    Devido a essa característica ambos possuem as suas vantagens e
    desvantagens.
    Um analisador Ascendente realiza a construção da árvore sintática das folhas até a raíz,
    o contrário de um analisador Descendente que realiza a construção
    da árvore sintática a partir da raíz até as folhas.
    Uma vantagem de um analisador ascendente é o suporte
    de uma maior classe de gramáticas determinísticas.
    Uma vantagem de um analisador descendente é a facilidade da recuperação de erros em relação
    aos \textit{parsers} LR(K) \cite{sippu1982,lr1ErrorRecovery,larkJosefGrosch}.

    Gramáticas são conjuntos de regras de definem uma linguagem.
    Em linguagens formais,
    sendo $\alpha$ um não~=terminal,
    $\beta$ um terminal,
    $Vn$ um conjunto de não~=terminais,
    $Vt$ um conjunto de terminais e
    $V = Vn \cup Vt$,
    uma gramática é definida por quatro componentes:
    \begin{enumerate}%[nosep,nolistsep]
        \item Um conjunto de símbolos terminais $Vt$,
        chamados algumas vezes de ``\textit{tokens}'' devido a sua forte conexão.
        Durante a análise léxica,
        os símbolos terminais serão utilizados definir os lexemas que são a base principal dos tokens.
        Na composição da árvore sintática,
        os ``\textit{tokens}'' ou terminais,
        serão sempre as folhas da árvore.

        \item Um conjunto de símbolos não-terminais $Vn$,
        algumas vezes chamados de ``variáveis sintáticas''.
        Não-terminais servem para agrupar vários não-terminais e/ou terminais.
        Na composição da árvore sintática,
        os símbolos não-terminais sempre serão os nós da árvore.
        Por convenção,
        a intersecção entre o conjunto de símbolos terminais e
        não terminais é sempre vazia, i.e., $Vn \cap Vt = \varnothing$,
        uma vez que não respeitando essa convenção,
        não se tem como deterministicamente analisar o programa de entrada,
        podendo~=se infinitamente realizar a substituição da mesma regra de produção infinitamente.

        \item \label{definicaoDeGramatica}Um conjunto de produções.
        Uma produção consiste em uma dupla de dois elementos.
        O primeiro elemento é a cabeça ou lado esquerdo e
        representa a substituição ou consumo que será feito no programa de entrada.
        Ele é obrigatoriamente constituído de no mínimo um não~=terminal e
        um ou mais não-terminais ou terminais.
        O segundo elemento é a cauda ou lado direito da produção,
        composto de terminais e/ou não-terminais.
        Formalmente defini~=se um produção pela seguinte regra,
        onde ``*'' representa o operador de fechamento do conjunto \cite{hopcroftBook}:
        $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^* \;\} $$

        \item Um símbolo inicial selecionado a partir do conjunto de símbolos não~=terminais.
        O símbolo inicial é utilizado para definir qual será a raíz da árvore sintática,
        i.e.,
        o primeira regra de produção utilizado para iniciar o reconhecimento do programa de entrada.
    \end{enumerate}

    A partir da definição formal de gramática ou de seu mecanismo reconhecedor,
    é possível realizar diversas classificações como a
    hierarquia \citeonline{chomskyGrammars1956},
    onde uma linguagem pode ser classificada como Regular,
    Livre de Contexto,
    Sensível ao Contexto e
    Tipo 0 (figura \ref{fig:pictures/HierarquiaDeChomsky.png}).
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/HierarquiaDeChomsky.png}
    \caption{Hierarquia de Chomsky -- Adaptação de \citeonline{sipserBook}}
    \label{fig:pictures/HierarquiaDeChomsky.png}
    \end{figure}

    Toda Gramática Regular ou Livre de Contexto,
    é também uma gramática Tipo 0 ou Sensível ao contexto,
    uma vez que Gramáticas Livre de Contexto ou Regulares são um
    subconjunto das gramáticas Tipo 0 ou Sensível ao Contexto como
    apresentado na figura \ref{fig:pictures/HierarquiaDeChomsky.png}.
    Quando diz~=se que uma dada Gramática ou Linguagem é Livre de Contexto,
    tem~=se a convenção de pensar que este é o melhor tipo (mais eficiente em tempo
    computational) no qual dada Gramática ou Linguagem pode ser representada.

    Linguagens Regulares são todas aquelas reconhecidas por
    Automatos Finitos Determinísticos ou
    Não~=Determinísticos e
    Gramaticas de Linguagens Regulares pela definição formal,
    são todas aquelas nos quais todas as produções da gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= a \beta \;|\; \alpha \in V_n \land a \in Vt
                \land \beta \in \{\; Vn \cup \varepsilon\; \} \;\} $$

    Linguagens Livre de Contexto são todas aquelas
    reconhecidas por Automatos de Pinha
    Não~=Determinísticos e
    Gramaticas de Linguagens Livre de Contexto pela definição formal,
    são todas aquelas nos quais todas as produções da gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V_n \land \beta \in V^* \;\} $$

    Linguagens Sensíveis ao Contexto são todas aquelas
    reconhecidas por Automatos Linearmente Limitados,
    que se tratam somente de Máquinas de Turing com Fita (ou memória) Finita.
    Gramaticas de Linguagens Sensíveis ao Contexto pela definição formal,
    são todas aquelas nos quais todas as produções da gramática possuem a seguinte forma:
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^*
                \land \vert\alpha\vert \leq \vert\beta\vert \;\} $$

    Por fim,
    as Linguagens do Tipo 0 possuem a mesma definição do que a definição válida de
    uma gramática como apresentado anteriormente (em \ref{definicaoDeGramatica}):
    $$ P = \{\; \alpha ::= \beta \;|\; \alpha \in V^* V_n V^* \land \beta \in V^* \;\} $$

    Gramáticas do Tipo 0 são reconhecidas somente por Máquinas de Turing\footnote{Máquinas
    de Turing possuem por definição fita (ou memória) infinita.
    },
    e diferente das Gramáticas Sensíveis ao Contexto,
    a Máquina de Turing não possui parada garantida,
    i.e.,
    Linguagens do Tipo 0 representam problemas incomputáveis e
    que podem ser representados de procedimentos.
    Já Linguagens do Tipo 1 ou Sensíveis ao Contexto,
    representam todos os problemas computáveis e
    sua implementação pode ser representada por algoritmos,
    pois possuem parada garantida,
    apesar de terem em pior caso,
    tempo exponential.
    A maior classe de gramáticas determinísticas suportadas por analisadores
    sintáticos são as gramáticas LR(K)\footnote{\textit{Left-to-right,
    Rightmost derivation in reverse by ``K'' lookahead symbols
    }}.
    Analisadores LR(K) \cite{ahoCompilerDragonBook} são Ascendentes e
    reconhecem um subconjunto das Linguagens Livre de Contexto
    (figura \ref{fig:pictures/LinguagensDeterministicas.png}).
    \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{pictures/LinguagensDeterministicas.png}
    \caption{Mapa Mental das Linguagens e
    Gramáticas \newline Adaptação de \citeonline{beatty1982} e
    \citeonline{ahoCompilerDragonBook}}
    \label{fig:pictures/LinguagensDeterministicas.png}
    \end{figure}

    A figura \ref{fig:pictures/LinguagensDeterministicas.png} não é
    um Diagrama de Venn \cite{generalizedVennDiagrams},
    somente uma relação abstrata entre linguagens ambíguas e
    gramática determinísticas.
    O primeiro nível significa que todas as Linguagens Inerentemente
    Ambíguas são representadas somente por Gramáticas Ambíguas.
    O segundo nível significa que Linguagens Não Inerentemente Ambíguas podem
    ser representadas por Gramáticas Ambíguas e/ou Determinísticas.
    No terceiro nível encontra~=se as gramáticas que são mais importantes,
    as Gramáticas Determinísticas,
    que podem ser classificadas como LR(K),
    LL(K), i.e.,
    de acordo com o tipo de parser que poder ser construído para reconhecer elas.

    É importante fazer a distinção entre Gramáticas Livre de Contexto e
    as Linguagens Livre de Contexto.
    \citeonline{parikh1966} provou que existem linguagens nas quais não
    existem gramáticas não~=ambíguas que representem estas linguagens.
    Tais linguagens são conhecidas como Linguagens Inerentemente Ambíguas\footnote{Do
    inglês \textit{Inherently ambiguous languages}} onde não existem Gramáticas
    Livre de Contexto determinísticas capazes de representa~=las.

    \citeonline{lalrDeRemer1982} criaram os parsers
    LALR(K)\footnote{\textit{Look-Ahead} LA(K) LR(0),
    onde LR(0) é um parser LR(K) com $K=0$
    } e
    SLR(K)\footnote{Simple LR(K) \textit{parser}} com o objeto
    de viabilizar a implementação de parsers LR(K),
    que requerem grandes quantidades de memória para operar.
    Gramáticas de Linguagens Determinísticas são chamadas de LR por que todas
    as Linguagens Determinísticas são reconhecidas por Analisadores LR(K).
    \citeonline{knuthLrParser1965} provou que todas as gramáticas
    determinísticas são aceitas por um parser LR(K).
    Assim,
    além da hierarquia de Chomsky,
    também classificasse as gramáticas de acordo com o tipo de parser
    que reconhece as linguagens representadas por elas.
    Como mostrado na figura \ref{fig:pictures/LinguagensDeterministicas.png},
    nem todas as gramáticas Livre de Contexto são de determinísticas e
    uma gramática é determinística somente se ela pode ser reconhecida por um parser LR(K).

    Usualmente,
    somente depois que a Árvore Sintática é construída,
    realiza~=se o processo de Análise Semântica,
    i.e.,
    a verificação da corretude do programa escrito em relação os aspectos não-estruturais,
    por exemplo,
    é sintaticamente correta escrever a declaração de uma mesma variável duas vezes ou mais,
    entretanto,
    é semanticamente errado redeclarar uma variável duas vezes ou mais.
    O analisador sintático representado por uma Gramática Livre de Contexto,
    não tem poder suficiente para realizar tais verificações
    devido as limitações das gramáticas livre de contexto.
    Entretanto,
    linguagens Sensíveis ao Contexto podem ser Turing Completa quando devidamente
    construídas \cite{areThereDomainSpecificLanguages,contextSensitiveParsing},
    são capazes de realizar qualquer operação computacional algorítmica.
    Portanto,
    uma vez que o programa foi verificado sintaticamente,
    inicia~=se o processo de análise semântica.

    Nem todas as linguagens podem ser analisadas completamente em diferentes etapas,
    como análise léxica, sintática e semântica. Muitas vezes,
    estas três etapas acontecem em paralelo como realizado na implementação do
    compilador da Linguagem C \cite{jourdan2017,whyCcannotBeParsedWithALR1Parser}.
    A gramática da linguagem C não é Livre de Contexto devido as
    ambiguidades existentes como a expressão ``\textit{x * y ;}''.
    Tal sentença pode ser ou a declaração de um ponteiro chamado \textit{y} do tipo \textit{x},
    ou a multiplicação de dois números armazenados nas variáveis \textit{x} e
    \textit{y},
    portanto ela não pode ser aceita por um \textit{parser} LR(K) tradicional.
    Uma otimização que o compilador C faz para poder fazer o parser Determinístico da linguagem C,
    e assim saber se a expressão ``\textit{x * y ;}'' trata~=se de
    de uma mera multiplicação ou a declaração de uma variável,
    é exatamente a realização simultânea da análise léxica,
    sintática e
    semântica.
    Uma vez que um novo \textit{token} é reconhecido,
    ele é alimentado para o analisador sintático,
    que também o alimenta para o Analisador Semântico.
    Assim,
    o Analisador Sintático é capaz de consultar a Tabela de Símbolos e
    descobrir se dado token ou tratar~=se de um tipo ou uma variável numérica.
    Portanto,
    pode dizer que as gramáticas de todas as Linguagens de Programação são Livres de Contexto e
    Determinísticas,
    pois uma vez que a gramática não é mais Livre de Contexto ou determinística,
    pode~=se mover aspectos sensíveis ao contexto para o Analisador Semântico,
    assim,
    deixando a gramática somente com aspectos determinísticos.
}

\subsection{Formatadores de código}

\lang{%
    A robust Code Beautifier can get a lot more complicated just with the basic
    definitions of formatting (\nameref{source_code_beautifiers})
    applied over each language own characteristics
    as for example:
}{%
    Conhecido como ``pretty~=printing'' ou embelezadores\footnote{Do
    inglês \textit{Beautifiers}} \cite{prettyPrintingForSoftware},
    uma ferramenta de formatação pode ser complicada de
    utilizar somente com um conjunto básico de definições.
    Por exemplo,
}%
\lang{%
    \begin{enumerate}[nosep,nolistsep]
        \item
            Add spaces before if\s name as in `if(var)' versus `if (var)'
        \item
            Add spaces inside if\s as in `if(var)' versus `if( var )'
        \item
            Add spaces before for\s name as in `for(var)' versus `for (var)'
        \item
            Add spaces inside for\s as in `for(var)' versus `for( var )'
    \end{enumerate}
}{%
    para permitir um melhor controle do usuário,
    a ferramenta de formatação pode permitir que exista uma
    configuração específica para cada aspecto da linguagem.
    Uma possível implementação para tal ajuste fino,
    pode ser uma configuração específica para cada aspecto da linguagem como uma
    entrada booleana ``\textit{use\_spaces\_after\_if}'' em um arquivo de
    configuração para definir caso deva~=se ou não ser adicionados espaços antes
    de cada ``if'' ao fazer a formatação da linguagem,
    por exemplo,
    ``if (var)'' ao invés de ``if(var)''.
}

\lang{
    As may be noticed, the list may became quite big,
    and if fact such big list of rules has been implemented.
    Looking over the Beautifier called
    `Uncrustify'\footnote{\url{https://github.com/uncrustify/uncrustify}},
    we can find about 500 settings with specifications like these above.
}{%
    Como pode ser percebido,
    uma lista contendo todas as configurações de formatação para cada
    aspecto da linguagem ficará muito grande quando todos os aspectos
    das linguagens mais complexas como C ou C++ forem implementados.
    Em softwares como
    \textit{Uncrustify}\footnote{\url{https://github.com/uncrustify/uncrustify}}
    encontra~=se mais de 500 configurações tais como as a seguir:
}
\begin{lstlisting}
# If the body of the namespace is longer than this
# number, it won't be indented. Requires
# indent_namespace=true. Default=0 (no limit)
indent_namespace_limit = 0  # number

# Whether the 'extern "C"' body is indented
indent_extern = false       # false/true

# Whether the 'class' body is indented
indent_class = true         # false/true

# Whether to indent the stuff after a
# leading base class colon
indent_class_colon = false  # false/true

# Whether to indent the stuff after a
# leading class initializer colon
indent_constr_colon = false # false/true
\end{lstlisting}

\lang{%
    The problem about is, even if you go through all these settings,
    which will take you quite some time,
    you still only configuring a few languages closely related.
    On this case, C, C++, Java, Pawn, etc.
    For all other languages you still need to find out another source code
    formatter tool, which will be certainly
    limited\footnote{\url{https://stackoverflow.com/questions/31438377/how-can-i-get-eclipse-to-wrap-lines-after-a-period-instead-of-before}}
    and still need to configure all over again.
}{%
    O problema é,
    mesmo que se passe por todas essas configurações,
    levará um bom tempo,
    mas você ainda está apenas configurando algumas linguagens fortemente relacionadas.
    No caso da ferramenta \textit{Uncrustify},
    serão configurados as linguagens \textit{C},
    \textit{C++}, \textit{Java}, \textit{Pawn}\advisor{.}{,
    etc.} Para todos os outras linguagens,
    você ainda precisará encontrar outra ferramenta de formatação,
    que será certamente mais
    limitada\footnote{\url{https://stackoverflow.com/questions/31438377/how-can-i-get-eclipse-to-wrap-lines-after-a-period-instead-of-before}}
    no que ela pode customizar,
    uma vez que \textit{Uncrustify} já é uma das mais completas.
    Além disso,
    ainda precisa-se configurar todas as novas opções já configuradas.
    Outra forte desvantagem do arquivo de configurações do
    \textit{Uncrustify} segue na dificuldade de entender e
    visualizar o que está sendo configurado.
    Algumas opções são claras e
    fáceis de se entender,
    já outras,
    não consegue-se ter a mínima ideia do que elas estão fazendo e
    qual será o seu resultado final.
}
