

% The \phantomsection command is needed to create a link to a place in the document that is not a
% figure, equation, table, section, subsection, chapter, etc.
%
% When do I need to invoke \phantomsection?
% https://tex.stackexchange.com/questions/44088/when-do-i-need-to-invoke-phantomsection
\phantomsection


% Is it possible to keep my translation together with original text?
% https://tex.stackexchange.com/questions/5076/is-it-possible-to-keep-my-translation-together-with-original-text
\chapter{\lang{Introduction}{Introdução}}


\begin{englishtext}

    Questions like ``What are good programming practices?'' Or ``Why are these
    practices are good?''Are not easy to answer. But each programmer learns to
    write their codes in a certain way, with certain features like using 4 or 8
    spaces to indent lines, always leave a blank line before each control
    structure as if or for statements, and alike rules.
    \cite{naturalCodingConventions}

    But entering the universe of good practices, there are many things for
    discoursing. Nonetheless, in this work is presented the implementation of
    tool called `Object Beautifier', which specifically dedicates on how to
    perform the best layout/display of programming code on the computer screen,
    so that maximize and facilitate the understanding of same
    \cite{automaticSynthesis}. Therefore, allowing the programmer to disperse
    more tempe thinking about its coding algorithms problem, other than trying
    to decipher the information that is presented to it on the screen through
    infinit different code layouts.


    % TODO, put reference for this
    Within this work\s area, we need to also think long and hard about how to
    share the programming code of the programmers among you. Now, the problem of
    human diversity, like all big scientific questions -- how do you explain
    something like that -- It can be broken down into sub-questions. It happens
    many times, which is a good practice for a `Programmer A', is not the same
    to another `Programmer B'. For example, imagine some code where a programmer
    decided to put before each `if' statement, a blank line. It is therefore
    expected that whenever we see a blank line we can potentially find a
    matching `if', which can be considered a quite useful pattern matching as
    empty line may call better your attention.

    % TODO, put reference for this
    But again this is something heavily dependent of what each one learning
    through their life time. Imagine another programmer do not liked this rule,
    and when he was writing your code involving an `if', he did not put such
    blank line another programmer is expecting. So when the first programmer
    start reading its the code and look for `if', he will be expecting for blank
    lines before its if\s. But will lose some time searching until realize
    another programmer does not put them, or perhaps he forgot to insert them.

    % TODO, put reference for this
    These differences are due to the diversity of ways we learn programming,
    i.e., to the ways we are used to doing coding, as much as the abilities and
    objectives of every programmer developed. Hence, nowadays it becomes a big
    problem because we increasingly need more and more programmers working
    together developing several and diverse computing systems. Where the latter
    is due to the fact of the complexity of computer systems growing
    increasingly, therefore over requiring programmers working and sharing their
    codes and ideas.

    % TODO, put reference for this
    Moreover besides only worrying about how the code is displayed on their
    computer screen, we need to worry about on how it will be saved in the file
    system on its `plain-text' mode. Since for code sharing, it is vital for you
    to use a versioning control system which enable project manager\s and
    programmers themselves, take control of their code changes. It does allow to
    easily perform the tracking of code changes and allow you to better
    understand what each programmer is doing every time he formalizes a change
    in the code through a `commit', as in `git' systems for example.

    % TODO, put reference for this (ref coding\_horror)
    That is because while working with a versioning system like `git', we need
    to keep the code among a single style or which we may call a `good practice'
    set as standard for everybody, due the fact of letting each programmer to
    write as he pleases, there will be plenty of noise on the code review and we
    are figuring out what actually each programmer did. Hence, if every
    programmer re-writes the history making changes like inserting new lines
    before each if, we end up with too much noise and focus of a versioning
    system is to look at only those changes that are significant to the code,
    such as the creation of new functions and not the addition of new blank
    lines (ref find\_some).

    % TODO, put reference for this
    Talking about the last thing pointed out, we could also think about an
    approach to creating a new version control system which focuses only on
    significant changes to the code, while reviewing code changes. However, this
    approach could not be ideal, as for example, it would allow programmers to
    start tedious wars of unproductive code adjustments. For example, imagine
    how it would be for your every day and have to go through your code
    re-adding new lines before each one of your beloved if\s, just because some
    night shift programmer had just removed them?


    Application fields for code beautifiers:
    \citeonline{annotationAssistant},
    \citeonline{codePlagiarismDetection},
    \citeonline{softwarePortfolio},
    \citeonline{legacyAssets},
    \citeonline{massMaintenance},
    \citeonline{prettyPrinting},
    \citeonline{architectureFormatting},
    \citeonline{independentFramework},
    \citeonline{programIndentation},
    \citeonline{industrialApplication},
    \citeonline{toolsForProjectManagement},
    \citeonline{codeClassification},
    \citeonline{codeScanningPatterns},

    \section{Goals}

    Establish relationships between good programming practices and efficiency in
    programming, in addition to a new tool to support programmers in order to
    automate the long and diverse programming process in teams of developers
    with different programming `best practices'. \cite{pushdownAutomata}


    \subsection{Specific Goals}

    \begin{enumerate}
        \item A study on universal programming tools, which from a single
        software, to work well behaved across all programming languages.
        Moreover, explain the differences for other softwares and the benefits
        of a unique tool, instead of several heavily different ones.

        \item Define, determine and classify which one are good programming
        practices and perform an in-depth study on the good practices on visual
        layout area, also known as code `Beautifying'.

        \item A study on the variety of existing tools for the support of good
        programming practices, beyond a comparative analysis between them,
        determining their weaknesses and strengths.

        \item The definition of a flow pattern of development allowing teams of
        developers with different programming best practices, to work without
        intervene with each other up to start wars of `best good practices'.

        \item Propose a unique tool that allowing several and distinct
        programming `best practices' being implemented in several programming
        languages, which can be configured and set accordingly to their wishes.
    \end{enumerate}



    \section{Search Method}

    The work will be based on research in articles, books, theses,
    dissertations, trusted authors websites, and through new demonstrated
    evidences based on arguments in the monograph evolution road. Also, present
    results after building a new tool which proposes a solution for the problems
    presented and detailed. \cite{aspectOriented}

    In this proposal last chapter which lies in the topic
    \autoref{sec:implementation}, there is a series of weblinks and references
    preselected and may be used in the release build of this work. Noticing the
    texts of the last section probably will end up gradually moved to the first
    section of the text where there is the theoretical research, while
    correlated research are incorporated in the main written work.
    \cite{aspectOrientationReview}

    Moreover, at the end of the first part of this work, the completion of the
    subject entitled of Course Conclusion Work 1, leaving only the information
    for the implementation of the proposed tool to be implemented in the second
    part of this named thesis on \nameref{sec:implementation}.



    \section{What does coding is?}

    Coding is like writing and reading a book for the large people, you like it
    to look beautifully. Or at least do you expect such when you buy a book, for
    example, to learn programming for you first time. You expect: % Reference to
    % book writing style/formatting articles

    \begin{enumerate}
        \item Things to be well organized, so you do not get lost.

        \item The colors to be properly placed, so you do not get distracted
           from the main content.

        \item The spacing between paragraphs, words, chapters, sections
           subsections, etc, to be well adjusted. Not everything cluttered in
           only one file, line, function, class, or whatsoever so.
    \end{enumerate}



    \section{Spaces and Tabs}

    The problem is that I will certainly not notice when I paste something
    indented with spaces instead of tabs. This is problem because for some file
    types as `.sublime-settings' files (or a Makefile), which has the setting
    `translate\_tabs\_to\_spaces' set to false, so I would expect to all
    `.sublime-settings' files to be indented with tabs, not spaces.
    \cite{tabsAndSpacesConversion}

    The setting `translate\_tabs\_to\_spaces' set to false works fine until I paste
    something on a setting's files which is indented with spaces, instead of
    tabs. This is a problem because as I am over git versioning, I can easily
    create files with mixed tabs and spaces on the history, and some day later
    Sublime Text will fix the indentation to tabs, which will cause noise on the
    git history due the tab/space conversion war. % Cite reference to the war

    I think this can have a performance problem as when I am pasting something
    big on Sublime Text. Then to perform the conversion on the would not be
    easily possible and it should be performed afterwards by the user. Now
    Sublime Text should warn the user when he is pasting something indented with
    spaces instead of tabs in a file which is expected to be indented with tabs?

    The detection of whether the contents of the clipboard should not be
    expensive as we should just check some lines (which would not cover the
    cases where there is already mixed indentation on the clipboard contents).
    But there would be a performance problem when pasting something with very
    big first lines. On this case a threshold should stop Sublime Text from
    looking forward and ceases the detection as inconclusive for this paste and
    just paste like it is.



    \subsection{Computer Assisted Programming}

    Your computer should help you with with these unforeseen tasks. Why should I
    spend my precious time checking whether I am actually copying something
    space indented, when I am actually coping something tab indented?

    Therefore, how to do such a thing on this 21\q{}st century? Perhaps we
    should sit and cry while waiting for some greater force to come and rescue
    us. Or may be you should stop crying and actually do something about other
    than keep waiting for you mommy to come and save you from the darkness
    growing behind you back leading you to endless unsleepy nights fixing your
    code just because everything just went wrong.



    \section{The Upper Stream}

    TODO.

    Do related and small commits, i.e., one change per commit.

    What is upstream?

    \url{https://help.github.com/articles/configuring-a-remote-for-a-fork/}

    \url{https://stackoverflow.com/questions/2739376/definition-of-downstream-and-upstream}

    What is origin?

    Is there a downstream?

    \citeonline{redesignOfGit}


    \subsection{How to keep up with the upstream}

    TODO.



    \section{Common Tasks}

    So you are developing a software which is under version control, however to
    deploy your tests, you need to copy some big folders into the deployment or
    testing system. Then how do you do it?

    Copying and pasting them probably the most straight forward idea, which is
    nice if you are going to it only a few times in a life time like two or
    three. However if you are going to do it move than these limits,
    please don\q t do that. It is bad for the planet and is worsening your
    health for nothing other than more headaches.

    As a promptly good computer user, at this point you already have some tool,
    either graphical or by command line which can help you easily and fastly
    setup the folder\q s. Easily like:

    \begin{enumerate}
        \item You open the tool
        \item Click on the new button
        \item Name your sync task as `My cuttie'
        \item Copy and paste there source and destine addresses
        \item Hit the `sync now' button
    \end{enumerate}



    \section{The rsync side}

    Doing everything out of the box by a graphical interface seems not
    practical. Command Line Interfaces (CLI) are simpler to be built and allows
    their programmers to saver their efforts in actually writing the tool
    instead of designing a reasonable Graphical User Interface (GUI)
    \cite{quantificationOfInterface}.

    GUI interfaces are awesome but for their proper usage, which is mostly
    defined by their aim public. Non-computer programmers, perhaps even novice
    programmers, cannot easily deal with command lines, but experienced
    programmers should be able to get great advantage from it usage.
    \cite{commandLineInterface}.

    Following we may see an example about the simpleness of a shell script,
    which runs several commands to accomplish a clean build of the testing
    environment:

    \begin{lstlisting}[caption={rebuild\_workspace.sh}]
    #!/bin/sh
    printf "$(date)\nRemoving folders...\n"

    rm -rf "Installed Packages"
    rm -rf "Lib"
    rm -rf "Local"
    rm -rf "Packages"

    printf "Unzipping files...\n"
    unzip -q "Packages.zip"

    mkdir -p "./Deployment/Code A"
    mkdir -p "./Deployment/Code B"

    printf "Syncing folders...\n"
    rsync -r \
         "/cygdrive/d/Development/Environment/Code A/" \
         "/cygdrive/c/Test/Deployment/Code A/"

    rsync -r \
         "/cygdrive/d/Development/Environment/Code B/" \
         "/cygdrive/c/Test/Deployment/Code B/"
    \end{lstlisting}
    \vspace*{-4mm}

    On preceding example, the `rebuild\_workspace.sh' script is located on the
    testing folder `/cygdrive/c/Test', then when calling it we get some folders
    removed, a file unpacked on the current folder, and our code synced from the
    versioning system directly to testing environment. You can read more about
    `rsync' utility on \citeonline{synchronizingFolders}.



    \section{How to Write Good Code}

    If you ask around, you will probably listen you need to write code to learn
    how to write good code. This seems to make sense like training for the next
    Olympics. As long as you train very hard, you get results.

    However, the same way as for gymnasium training there is the right or
    perhaps nice way to do it and the wrong way, for computer programming is the
    same.


    \section{Good Coding Practices}


    \subsection{Variable Naming}

    Variables naming are extremely important. That is it, a dot.

    \begin{itemize}

    \item Global identifiers must start with `g\_' prefix.

    \item Global identifiers which are constant must be written in ALLCAPS.

    \item Boolean variables must be prefix with `is\_' even when they are in
    global scope, meaning double prefixed as `g\_is\_'.

    \end{itemize}

    All other cases not cited must not be prefixed. Now we can continue the most
    infamous wars about Hungarian notation versus ?.

    Nonetheless, looking over this list we can quickly pop up about different
    programming languages whereas such rules are applied and not. The most
    notorious cases are about Java and C.

    Java programming language has no such idealism as exhaustively prefixing as
    `g\_' as explicitly there is not such concept. Although a more hawk-eyed
    reader may spot about the Java classes atributes being the global variables.
    And in fact they are so. But within their scope limited to the classes body,
    and perhaps the instance objects which may or may not provide access to
    them.

    Regardless, Java also suffers from the same evil as remaining programming
    languages with the common global variable concept. Here we enter on the
    war about the evil global variable usage. However, keeping such bias against
    global variable usage is not correct. Each one of the cases, either passing
    the variables by reference, copy, or sharing globally is a correct approach.

    TODO, reference the reader to proper reading and stop this discussion.


    \subsection{Hungarian Notation}

    TODO.


    \subsection{?. Notation}

    TODO.

\end{englishtext}


% Portuguese
\lang{}{\input{chapters/introdução}}


